
@c %start of fragment

The functions from this section may be had by loading the module:

@example 
(use-modules (gl low-level)
@end example

This section of the manual was derived from the upstream OpenGL
documentation.  Each function's documentation has its own copyright
statement; for full details, see the upstream documentation.  The
copyright notices and licenses present in this section are as follows.

Copyright @copyright{} 1991-2006 Silicon Graphics, Inc.  This document
is licensed under the SGI Free Software B License.  For details, see
@uref{http://oss.sgi.com/projects/FreeB/,http://oss.sgi.com/projects/FreeB/}.

Copyright @copyright{} 2003-2005 3Dlabs Inc.  Ltd.  This material may be
distributed subject to the terms and conditions set forth in the Open
Publication License, v 1.0, 8 June 1999.
@uref{http://opencontent.org/openpub/,http://opencontent.org/openpub/}.

Copyright @copyright{} 2005 Addison-Wesley.  This material may be
distributed subject to the terms and conditions set forth in the Open
Publication License, v 1.0, 8 June 1999.
@uref{http://opencontent.org/openpub/,http://opencontent.org/openpub/}.

Copyright @copyright{} 2006 Khronos Group.  This material may be
distributed subject to the terms and conditions set forth in the Open
Publication License, v 1.0, 8 June 1999.
@uref{http://opencontent.org/openpub/,http://opencontent.org/openpub/}.

@deftypefun void glAccum op value
Operate on the accumulation buffer.

@table @asis
@item @var{op}
Specifies the accumulation buffer operation.  Symbolic constants
@code{GL_ACCUM}, @code{GL_LOAD}, @code{GL_ADD}, @code{GL_MULT}, and
@code{GL_RETURN} are accepted.

@item @var{value}
Specifies a floating-point value used in the accumulation buffer
operation.  @var{op} determines how @var{value} is used.

@end table

The accumulation buffer is an extended-range color buffer.  Images are
not rendered into it.  Rather, images rendered into one of the color
buffers are added to the contents of the accumulation buffer after
rendering.  Effects such as antialiasing (of points, lines, and
polygons), motion blur, and depth of field can be created by
accumulating images generated with different transformation matrices.

Each pixel in the accumulation buffer consists of red, green, blue, and
alpha values.  The number of bits per component in the accumulation
buffer depends on the implementation.  You can examine this number by
calling @code{glGetIntegerv} four times, with arguments
@code{GL_ACCUM_RED_BITS}, @code{GL_ACCUM_GREEN_BITS},
@code{GL_ACCUM_BLUE_BITS}, and @code{GL_ACCUM_ALPHA_BITS}.  Regardless
of the number of bits per component, the range of values stored by each
component is @r{[-1,1]}.  The accumulation buffer pixels are mapped
one-to-one with frame buffer pixels.

@code{glAccum} operates on the accumulation buffer.  The first argument,
@var{op}, is a symbolic constant that selects an accumulation buffer
operation.  The second argument, @var{value}, is a floating-point value
to be used in that operation.  Five operations are specified:
@code{GL_ACCUM}, @code{GL_LOAD}, @code{GL_ADD}, @code{GL_MULT}, and
@code{GL_RETURN}.

All accumulation buffer operations are limited to the area of the
current scissor box and applied identically to the red, green, blue, and
alpha components of each pixel.  If a @code{glAccum} operation results
in a value outside the range @r{[-1,1]}, the contents of an accumulation
buffer pixel component are undefined.

The operations are as follows:

@table @asis
@item @code{GL_ACCUM}
Obtains R, G, B, and A values from the buffer currently selected for
reading (see @code{glReadBuffer}).  Each component value is divided by
@r{2^@var{n}-1}, where @r{@var{n}} is the number of bits allocated to
each color component in the currently selected buffer.  The result is a
floating-point value in the range @r{[0,1]}, which is multiplied by
@var{value} and added to the corresponding pixel component in the
accumulation buffer, thereby updating the accumulation buffer.

@item @code{GL_LOAD}
Similar to @code{GL_ACCUM}, except that the current value in the
accumulation buffer is not used in the calculation of the new value.
That is, the R, G, B, and A values from the currently selected buffer
are divided by @r{2^@var{n}-1}, multiplied by @var{value}, and then
stored in the corresponding accumulation buffer cell, overwriting the
current value.

@item @code{GL_ADD}
Adds @var{value} to each R, G, B, and A in the accumulation buffer.

@item @code{GL_MULT}
Multiplies each R, G, B, and A in the accumulation buffer by @var{value}
and returns the scaled component to its corresponding accumulation
buffer location.

@item @code{GL_RETURN}
Transfers accumulation buffer values to the color buffer or buffers
currently selected for writing.  Each R, G, B, and A component is
multiplied by @var{value}, then multiplied by @r{2^@var{n}-1}, clamped
to the range @r{[0,2^@var{n}-1]}, and stored in the corresponding
display buffer cell.  The only fragment operations that are applied to
this transfer are pixel ownership, scissor, dithering, and color
writemasks.

@end table

To clear the accumulation buffer, call @code{glClearAccum} with R, G, B,
and A values to set it to, then call @code{glClear} with the
accumulation buffer enabled.

@code{GL_INVALID_ENUM} is generated if @var{op} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if there is no accumulation
buffer.

@code{GL_INVALID_OPERATION} is generated if @code{glAccum} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glActiveTexture texture
Select active texture unit.

@table @asis
@item @var{texture}
Specifies which texture unit to make active.  The number of texture
units is implementation dependent, but must be at least two.
@var{texture} must be one of @code{GL_TEXTURE}@r{@var{i}}, where i
ranges from 0 to the larger of (@code{GL_MAX_TEXTURE_COORDS} - 1) and
(@code{GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS} - 1).  The initial value is
@code{GL_TEXTURE0}.

@end table

@code{glActiveTexture} selects which texture unit subsequent texture
state calls will affect.  The number of texture units an implementation
supports is implementation dependent, but must be at least 2.

Vertex arrays are client-side GL resources, which are selected by the
@code{glClientActiveTexture} routine.

@code{GL_INVALID_ENUM} is generated if @var{texture} is not one of
@code{GL_TEXTURE}@r{@var{i}}, where i ranges from 0 to the larger of
(@code{GL_MAX_TEXTURE_COORDS} - 1) and
(@code{GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS} - 1).

@end deftypefun

@deftypefun void glAlphaFunc func ref
Specify the alpha test function.

@table @asis
@item @var{func}
Specifies the alpha comparison function.  Symbolic constants
@code{GL_NEVER}, @code{GL_LESS}, @code{GL_EQUAL}, @code{GL_LEQUAL},
@code{GL_GREATER}, @code{GL_NOTEQUAL}, @code{GL_GEQUAL}, and
@code{GL_ALWAYS} are accepted.  The initial value is @code{GL_ALWAYS}.

@item @var{ref}
Specifies the reference value that incoming alpha values are compared
to.  This value is clamped to the range @r{[0,1]}, where 0 represents
the lowest possible alpha value and 1 the highest possible value.  The
initial reference value is 0.

@end table

The alpha test discards fragments depending on the outcome of a
comparison between an incoming fragment's alpha value and a constant
reference value.  @code{glAlphaFunc} specifies the reference value and
the comparison function.  The comparison is performed only if alpha
testing is enabled.  By default, it is not enabled.  (See
@code{glEnable} and @code{glDisable} of @code{GL_ALPHA_TEST}.)

@var{func} and @var{ref} specify the conditions under which the pixel is
drawn.  The incoming alpha value is compared to @var{ref} using the
function specified by @var{func}.  If the value passes the comparison,
the incoming fragment is drawn if it also passes subsequent stencil and
depth buffer tests.  If the value fails the comparison, no change is
made to the frame buffer at that pixel location.  The comparison
functions are as follows:

@table @asis
@item @code{GL_NEVER}
Never passes.

@item @code{GL_LESS}
Passes if the incoming alpha value is less than the reference value.

@item @code{GL_EQUAL}
Passes if the incoming alpha value is equal to the reference value.

@item @code{GL_LEQUAL}
Passes if the incoming alpha value is less than or equal to the
reference value.

@item @code{GL_GREATER}
Passes if the incoming alpha value is greater than the reference value.

@item @code{GL_NOTEQUAL}
Passes if the incoming alpha value is not equal to the reference value.

@item @code{GL_GEQUAL}
Passes if the incoming alpha value is greater than or equal to the
reference value.

@item @code{GL_ALWAYS}
Always passes (initial value).

@end table

@code{glAlphaFunc} operates on all pixel write operations, including
those resulting from the scan conversion of points, lines, polygons, and
bitmaps, and from pixel draw and copy operations.  @code{glAlphaFunc}
does not affect screen clear operations.

@code{GL_INVALID_ENUM} is generated if @var{func} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glAlphaFunc} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLboolean glAreTexturesResident n textures residences
Determine if textures are loaded in texture memory.

@table @asis
@item @var{n}
Specifies the number of textures to be queried.

@item @var{textures}
Specifies an array containing the names of the textures to be queried.

@item @var{residences}
Specifies an array in which the texture residence status is returned.
The residence status of a texture named by an element of @var{textures}
is returned in the corresponding element of @var{residences}.

@end table

GL establishes a ``working set'' of textures that are resident in
texture memory.  These textures can be bound to a texture target much
more efficiently than textures that are not resident.

@code{glAreTexturesResident} queries the texture residence status of the
@var{n} textures named by the elements of @var{textures}.  If all the
named textures are resident, @code{glAreTexturesResident} returns
@code{GL_TRUE}, and the contents of @var{residences} are undisturbed.  If
not all the named textures are resident, @code{glAreTexturesResident}
returns @code{GL_FALSE}, and detailed status is returned in the @var{n}
elements of @var{residences}.  If an element of @var{residences} is
@code{GL_TRUE}, then the texture named by the corresponding element of
@var{textures} is resident.

The residence status of a single bound texture may also be queried by
calling @code{glGetTexParameter} with the @var{target} argument set to
the target to which the texture is bound, and the @var{pname} argument
set to @code{GL_TEXTURE_RESIDENT}.  This is the only way that the
residence status of a default texture can be queried.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_VALUE} is generated if any element in @var{textures} is
0 or does not name a texture.  In that case, the function returns
@code{GL_FALSE} and the contents of @var{residences} is indeterminate.

@code{GL_INVALID_OPERATION} is generated if @code{glAreTexturesResident}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glArrayElement i
Render a vertex using the specified vertex array element.

@table @asis
@item @var{i}
Specifies an index into the enabled vertex data arrays.

@end table

@code{glArrayElement} commands are used within
@code{glBegin}/@code{glEnd} pairs to specify vertex and attribute data
for point, line, and polygon primitives.  If @code{GL_VERTEX_ARRAY} is
enabled when @code{glArrayElement} is called, a single vertex is drawn,
using vertex and attribute data taken from location @var{i} of the
enabled arrays.  If @code{GL_VERTEX_ARRAY} is not enabled, no drawing
occurs but the attributes corresponding to the enabled arrays are
modified.

Use @code{glArrayElement} to construct primitives by indexing vertex
data, rather than by streaming through arrays of data in first-to-last
order.  Because each call specifies only a single vertex, it is possible
to explicitly specify per-primitive attributes such as a single normal
for each triangle.

Changes made to array data between the execution of @code{glBegin} and
the corresponding execution of @code{glEnd} may affect calls to
@code{glArrayElement} that are made within the same
@code{glBegin}/@code{glEnd} period in nonsequential ways.  That is, a
call to @code{glArrayElement} that precedes a change to array data may
access the changed data, and a call that follows a change to array data
may access original data.

@code{GL_INVALID_VALUE} may be generated if @var{i} is negative.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to an enabled array and the buffer object's data store is
currently mapped.

@end deftypefun

@deftypefun void glAttachShader program shader
Attaches a shader object to a program object.

@table @asis
@item @var{program}
Specifies the program object to which a shader object will be attached.

@item @var{shader}
Specifies the shader object that is to be attached.

@end table

In order to create an executable, there must be a way to specify the
list of things that will be linked together.  Program objects provide
this mechanism.  Shaders that are to be linked together in a program
object must first be attached to that program object.
@code{glAttachShader} attaches the shader object specified by
@var{shader} to the program object specified by @var{program}.  This
indicates that @var{shader} will be included in link operations that
will be performed on @var{program}.

All operations that can be performed on a shader object are valid
whether or not the shader object is attached to a program object.  It is
permissible to attach a shader object to a program object before source
code has been loaded into the shader object or before the shader object
has been compiled.  It is permissible to attach multiple shader objects
of the same type because each may contain a portion of the complete
shader.  It is also permissible to attach a shader object to more than
one program object.  If a shader object is deleted while it is attached
to a program object, it will be flagged for deletion, and deletion will
not occur until @code{glDetachShader} is called to detach it from all
program objects to which it is attached.

@code{GL_INVALID_VALUE} is generated if either @var{program} or
@var{shader} is not a value generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is not a shader
object.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is already
attached to @var{program}.

@code{GL_INVALID_OPERATION} is generated if @code{glAttachShader} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBeginQuery target id
@deftypefunx void glEndQuery target
Delimit the boundaries of a query object.

@table @asis
@item @var{target}
Specifies the target type of query object established between
@code{glBeginQuery} and the subsequent @code{glEndQuery}.  The symbolic
constant must be @code{GL_SAMPLES_PASSED}.

@item @var{id}
Specifies the name of a query object.

@end table

@code{glBeginQuery} and @code{glEndQuery} delimit the boundaries of a
query object.  If a query object with name @var{id} does not yet exist
it is created.

When @code{glBeginQuery} is executed, the query object's samples-passed
counter is reset to 0.  Subsequent rendering will increment the counter
once for every sample that passes the depth test.  When
@code{glEndQuery} is executed, the samples-passed counter is assigned to
the query object's result value.  This value can be queried by calling
@code{glGetQueryObject} with @var{pname}@code{GL_QUERY_RESULT}.

Querying the @code{GL_QUERY_RESULT} implicitly flushes the GL pipeline
until the rendering delimited by the query object has completed and the
result is available.  @code{GL_QUERY_RESULT_AVAILABLE} can be queried to
determine if the result is immediately available or if the rendering is
not yet complete.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_SAMPLES_PASSED}.

@code{GL_INVALID_OPERATION} is generated if @code{glBeginQuery} is
executed while a query object of the same @var{target} is already
active.

@code{GL_INVALID_OPERATION} is generated if @code{glEndQuery} is
executed when a query object of the same @var{target} is not active.

@code{GL_INVALID_OPERATION} is generated if @var{id} is 0.

@code{GL_INVALID_OPERATION} is generated if @var{id} is the name of an
already active query object.

@code{GL_INVALID_OPERATION} is generated if @code{glBeginQuery} or
@code{glEndQuery} is executed between the execution of @code{glBegin}
and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBegin mode
@deftypefunx void glEnd 
Delimit the vertices of a primitive or a group of like primitives.

@table @asis
@item @var{mode}
Specifies the primitive or primitives that will be created from vertices
presented between @code{glBegin} and the subsequent @code{glEnd}.  Ten
symbolic constants are accepted: @code{GL_POINTS}, @code{GL_LINES},
@code{GL_LINE_STRIP}, @code{GL_LINE_LOOP}, @code{GL_TRIANGLES},
@code{GL_TRIANGLE_STRIP}, @code{GL_TRIANGLE_FAN}, @code{GL_QUADS},
@code{GL_QUAD_STRIP}, and @code{GL_POLYGON}.

@end table

@code{glBegin} and @code{glEnd} delimit the vertices that define a
primitive or a group of like primitives.  @code{glBegin} accepts a
single argument that specifies in which of ten ways the vertices are
interpreted.  Taking @r{@var{n}} as an integer count starting at one,
and @r{@var{N}} as the total number of vertices specified, the
interpretations are as follows:

@table @asis
@item @code{GL_POINTS}
Treats each vertex as a single point.  Vertex @r{@var{n}} defines point
@r{@var{n}}.  @r{@var{N}} points are drawn.

@item @code{GL_LINES}
Treats each pair of vertices as an independent line segment.  Vertices
@r{2⁢@var{n}-1} and @r{2⁢@var{n}} define line @r{@var{n}}.  @r{@var{N}/2}
lines are drawn.

@item @code{GL_LINE_STRIP}
Draws a connected group of line segments from the first vertex to the
last.  Vertices @r{@var{n}} and @r{@var{n}+1} define line @r{@var{n}}.
@r{@var{N}-1} lines are drawn.

@item @code{GL_LINE_LOOP}
Draws a connected group of line segments from the first vertex to the
last, then back to the first.  Vertices @r{@var{n}} and @r{@var{n}+1}
define line @r{@var{n}}.  The last line, however, is defined by vertices
@r{@var{N}} and @r{1}.  @r{@var{N}} lines are drawn.

@item @code{GL_TRIANGLES}
Treats each triplet of vertices as an independent triangle.  Vertices
@r{3⁢@var{n}-2}, @r{3⁢@var{n}-1}, and @r{3⁢@var{n}} define triangle
@r{@var{n}}.  @r{@var{N}/3} triangles are drawn.

@item @code{GL_TRIANGLE_STRIP}
Draws a connected group of triangles.  One triangle is defined for each
vertex presented after the first two vertices.  For odd @r{@var{n}},
vertices @r{@var{n}}, @r{@var{n}+1}, and @r{@var{n}+2} define triangle
@r{@var{n}}.  For even @r{@var{n}}, vertices @r{@var{n}+1}, @r{@var{n}},
and @r{@var{n}+2} define triangle @r{@var{n}}.  @r{@var{N}-2} triangles
are drawn.

@item @code{GL_TRIANGLE_FAN}
Draws a connected group of triangles.  One triangle is defined for each
vertex presented after the first two vertices.  Vertices @r{1},
@r{@var{n}+1}, and @r{@var{n}+2} define triangle @r{@var{n}}.
@r{@var{N}-2} triangles are drawn.

@item @code{GL_QUADS}
Treats each group of four vertices as an independent quadrilateral.
Vertices @r{4⁢@var{n}-3}, @r{4⁢@var{n}-2}, @r{4⁢@var{n}-1}, and
@r{4⁢@var{n}} define quadrilateral @r{@var{n}}.  @r{@var{N}/4}
quadrilaterals are drawn.

@item @code{GL_QUAD_STRIP}
Draws a connected group of quadrilaterals.  One quadrilateral is defined
for each pair of vertices presented after the first pair.  Vertices
@r{2⁢@var{n}-1}, @r{2⁢@var{n}}, @r{2⁢@var{n}+2}, and @r{2⁢@var{n}+1}
define quadrilateral @r{@var{n}}.  @r{@var{N}/2-1} quadrilaterals are
drawn.  Note that the order in which vertices are used to construct a
quadrilateral from strip data is different from that used with
independent data.

@item @code{GL_POLYGON}
Draws a single, convex polygon.  Vertices @r{1} through @r{@var{N}}
define this polygon.

@end table

Only a subset of GL commands can be used between @code{glBegin} and
@code{glEnd}.  The commands are @code{glVertex}, @code{glColor},
@code{glSecondaryColor}, @code{glIndex}, @code{glNormal},
@code{glFogCoord}, @code{glTexCoord}, @code{glMultiTexCoord},
@code{glVertexAttrib}, @code{glEvalCoord}, @code{glEvalPoint},
@code{glArrayElement}, @code{glMaterial}, and @code{glEdgeFlag}.  Also,
it is acceptable to use @code{glCallList} or @code{glCallLists} to
execute display lists that include only the preceding commands.  If any
other GL command is executed between @code{glBegin} and @code{glEnd},
the error flag is set and the command is ignored.

Regardless of the value chosen for @var{mode}, there is no limit to the
number of vertices that can be defined between @code{glBegin} and
@code{glEnd}.  Lines, triangles, quadrilaterals, and polygons that are
incompletely specified are not drawn.  Incomplete specification results
when either too few vertices are provided to specify even a single
primitive or when an incorrect multiple of vertices is specified.  The
incomplete primitive is ignored; the rest are drawn.

The minimum specification of vertices for each primitive is as follows:
1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral,
and 3 for a polygon.  Modes that require a certain multiple of vertices
are @code{GL_LINES} (2), @code{GL_TRIANGLES} (3), @code{GL_QUADS} (4),
and @code{GL_QUAD_STRIP} (2).

@code{GL_INVALID_ENUM} is generated if @var{mode} is set to an
unaccepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glBegin} is executed
between a @code{glBegin} and the corresponding execution of
@code{glEnd}.

@code{GL_INVALID_OPERATION} is generated if @code{glEnd} is executed
without being preceded by a @code{glBegin}.

@code{GL_INVALID_OPERATION} is generated if a command other than
@code{glVertex}, @code{glColor}, @code{glSecondaryColor},
@code{glIndex}, @code{glNormal}, @code{glFogCoord}, @code{glTexCoord},
@code{glMultiTexCoord}, @code{glVertexAttrib}, @code{glEvalCoord},
@code{glEvalPoint}, @code{glArrayElement}, @code{glMaterial},
@code{glEdgeFlag}, @code{glCallList}, or @code{glCallLists} is executed
between the execution of @code{glBegin} and the corresponding execution
@code{glEnd}.

Execution of @code{glEnableClientState}, @code{glDisableClientState},
@code{glEdgeFlagPointer}, @code{glFogCoordPointer},
@code{glTexCoordPointer}, @code{glColorPointer},
@code{glSecondaryColorPointer}, @code{glIndexPointer},
@code{glNormalPointer}, @code{glVertexPointer},
@code{glVertexAttribPointer}, @code{glInterleavedArrays}, or
@code{glPixelStore} is not allowed after a call to @code{glBegin} and
before the corresponding call to @code{glEnd}, but an error may or may
not be generated.

@end deftypefun

@deftypefun void glBindAttribLocation program index name
Associates a generic vertex attribute index with a named attribute
variable.

@table @asis
@item @var{program}
Specifies the handle of the program object in which the association is
to be made.

@item @var{index}
Specifies the index of the generic vertex attribute to be bound.

@item @var{name}
Specifies a null terminated string containing the name of the vertex
shader attribute variable to which @var{index} is to be bound.

@end table

@code{glBindAttribLocation} is used to associate a user-defined
attribute variable in the program object specified by @var{program} with
a generic vertex attribute index.  The name of the user-defined
attribute variable is passed as a null terminated string in @var{name}.
The generic vertex attribute index to be bound to this variable is
specified by @var{index}.  When @var{program} is made part of current
state, values provided via the generic vertex attribute @var{index} will
modify the value of the user-defined attribute variable specified by
@var{name}.

If @var{name} refers to a matrix attribute variable, @var{index} refers
to the first column of the matrix.  Other matrix columns are then
automatically bound to locations @var{index+1} for a matrix of type
mat2; @var{index+1} and @var{index+2} for a matrix of type mat3; and
@var{index+1}, @var{index+2}, and @var{index+3} for a matrix of type
mat4.

This command makes it possible for vertex shaders to use descriptive
names for attribute variables rather than generic variables that are
numbered from 0 to @code{GL_MAX_VERTEX_ATTRIBS} -1.  The values sent to
each generic attribute index are part of current state, just like
standard vertex attributes such as color, normal, and vertex position.
If a different program object is made current by calling
@code{glUseProgram}, the generic vertex attributes are tracked in such a
way that the same values will be observed by attributes in the new
program object that are also bound to @var{index}.

Attribute variable name-to-generic attribute index bindings for a
program object can be explicitly assigned at any time by calling
@code{glBindAttribLocation}.  Attribute bindings do not go into effect
until @code{glLinkProgram} is called.  After a program object has been
linked successfully, the index values for generic attributes remain
fixed (and their values can be queried) until the next link command
occurs.

Applications are not allowed to bind any of the standard OpenGL vertex
attributes using this command, as they are bound automatically when
needed.  Any attribute binding that occurs after the program object has
been linked will not take effect until the next time the program object
is linked.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to @code{GL_MAX_VERTEX_ATTRIBS}.

@code{GL_INVALID_OPERATION} is generated if @var{name} starts with the
reserved prefix "gl_".

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @code{glBindAttribLocation}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBindBuffer target buffer
Bind a named buffer object.

@table @asis
@item @var{target}
Specifies the target to which the buffer object is bound.  The symbolic
constant must be @code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@item @var{buffer}
Specifies the name of a buffer object.

@end table

@code{glBindBuffer} lets you create or use a named buffer object.
Calling @code{glBindBuffer} with @var{target} set to
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER} or @code{GL_PIXEL_UNPACK_BUFFER} and
@var{buffer} set to the name of the new buffer object binds the buffer
object name to the target.  When a buffer object is bound to a target,
the previous binding for that target is automatically broken.

Buffer object names are unsigned integers.  The value zero is reserved,
but there is no default buffer object for each buffer object target.
Instead, @var{buffer} set to zero effectively unbinds any buffer object
previously bound, and restores client memory usage for that buffer
object target.  Buffer object names and the corresponding buffer object
contents are local to the shared display-list space (see
@code{glXCreateContext}) of the current GL rendering context; two
rendering contexts share buffer object names only if they also share
display lists.

You may use @code{glGenBuffers} to generate a set of new buffer object
names.

The state of a buffer object immediately after it is first bound is an
unmapped zero-sized memory buffer with @code{GL_READ_WRITE} access and
@code{GL_STATIC_DRAW} usage.

While a non-zero buffer object name is bound, GL operations on the
target to which it is bound affect the bound buffer object, and queries
of the target to which it is bound return state from the bound buffer
object.  While buffer object name zero is bound, as in the initial
state, attempts to modify or query state on the target to which it is
bound generates an @code{GL_INVALID_OPERATION} error.

When vertex array pointer state is changed, for example by a call to
@code{glNormalPointer}, the current buffer object binding
(@code{GL_ARRAY_BUFFER_BINDING}) is copied into the corresponding client
state for the vertex array type being changed, for example
@code{GL_NORMAL_ARRAY_BUFFER_BINDING}.  While a non-zero buffer object
is bound to the @code{GL_ARRAY_BUFFER} target, the vertex array pointer
parameter that is traditionally interpreted as a pointer to client-side
memory is instead interpreted as an offset within the buffer object
measured in basic machine units.

While a non-zero buffer object is bound to the
@code{GL_ELEMENT_ARRAY_BUFFER} target, the indices parameter of
@code{glDrawElements}, @code{glDrawRangeElements}, or
@code{glMultiDrawElements} that is traditionally interpreted as a
pointer to client-side memory is instead interpreted as an offset within
the buffer object measured in basic machine units.

While a non-zero buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target, the following commands are affected:
@code{glGetCompressedTexImage}, @code{glGetConvolutionFilter},
@code{glGetHistogram}, @code{glGetMinmax}, @code{glGetPixelMap},
@code{glGetPolygonStipple}, @code{glGetSeparableFilter},
@code{glGetTexImage}, and @code{glReadPixels}.  The pointer parameter
that is traditionally interpreted as a pointer to client-side memory
where the pixels are to be packed is instead interpreted as an offset
within the buffer object measured in basic machine units.

While a non-zero buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target, the following commands are
affected: @code{glBitmap}, @code{glColorSubTable}, @code{glColorTable},
@code{glCompressedTexImage1D}, @code{glCompressedTexImage2D},
@code{glCompressedTexImage3D}, @code{glCompressedTexSubImage1D},
@code{glCompressedTexSubImage2D}, @code{glCompressedTexSubImage3D},
@code{glConvolutionFilter1D}, @code{glConvolutionFilter2D},
@code{glDrawPixels}, @code{glPixelMap}, @code{glPolygonStipple},
@code{glSeparableFilter2D}, @code{glTexImage1D}, @code{glTexImage2D},
@code{glTexImage3D}, @code{glTexSubImage1D}, @code{glTexSubImage2D}, and
@code{glTexSubImage3D}.  The pointer parameter that is traditionally
interpreted as a pointer to client-side memory from which the pixels are
to be unpacked is instead interpreted as an offset within the buffer
object measured in basic machine units.

A buffer object binding created with @code{glBindBuffer} remains active
until a different buffer object name is bound to the same target, or
until the bound buffer object is deleted with @code{glDeleteBuffers}.

Once created, a named buffer object may be re-bound to any target as
often as needed.  However, the GL implementation may make choices about
how to optimize the storage of a buffer object based on its initial
binding target.

@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @code{glBindBuffer} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBindTexture target texture
Bind a named texture to a texturing target.

@table @asis
@item @var{target}
Specifies the target to which the texture is bound.  Must be either
@code{GL_TEXTURE_1D}, @code{GL_TEXTURE_2D}, @code{GL_TEXTURE_3D}, or
@code{GL_TEXTURE_CUBE_MAP}.

@item @var{texture}
Specifies the name of a texture.

@end table

@code{glBindTexture} lets you create or use a named texture.  Calling
@code{glBindTexture} with @var{target} set to @code{GL_TEXTURE_1D},
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_3D} or @code{GL_TEXTURE_CUBE_MAP}
and @var{texture} set to the name of the new texture binds the texture
name to the target.  When a texture is bound to a target, the previous
binding for that target is automatically broken.

Texture names are unsigned integers.  The value zero is reserved to
represent the default texture for each texture target.  Texture names
and the corresponding texture contents are local to the shared
display-list space (see @code{glXCreateContext}) of the current GL
rendering context; two rendering contexts share texture names only if
they also share display lists.

You may use @code{glGenTextures} to generate a set of new texture names.

When a texture is first bound, it assumes the specified target: A
texture first bound to @code{GL_TEXTURE_1D} becomes one-dimensional
texture, a texture first bound to @code{GL_TEXTURE_2D} becomes
two-dimensional texture, a texture first bound to @code{GL_TEXTURE_3D}
becomes three-dimensional texture, and a texture first bound to
@code{GL_TEXTURE_CUBE_MAP} becomes a cube-mapped texture.  The state of
a one-dimensional texture immediately after it is first bound is
equivalent to the state of the default @code{GL_TEXTURE_1D} at GL
initialization, and similarly for two- and three-dimensional textures
and cube-mapped textures.

While a texture is bound, GL operations on the target to which it is
bound affect the bound texture, and queries of the target to which it is
bound return state from the bound texture.  If texture mapping is active
on the target to which a texture is bound, the bound texture is used.  In
effect, the texture targets become aliases for the textures currently
bound to them, and the texture name zero refers to the default textures
that were bound to them at initialization.

A texture binding created with @code{glBindTexture} remains active until
a different texture is bound to the same target, or until the bound
texture is deleted with @code{glDeleteTextures}.

Once created, a named texture may be re-bound to its same original
target as often as needed.  It is usually much faster to use
@code{glBindTexture} to bind an existing named texture to one of the
texture targets than it is to reload the texture image using
@code{glTexImage1D}, @code{glTexImage2D}, or @code{glTexImage3D}.  For
additional control over performance, use @code{glPrioritizeTextures}.

@code{glBindTexture} is included in display lists.

@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @var{texture} was previously
created with a target that doesn't match that of @var{target}.

@code{GL_INVALID_OPERATION} is generated if @code{glBindTexture} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBitmap width height xorig yorig xmove ymove bitmap
Draw a bitmap.

@table @asis
@item @var{width}
@itemx @var{height}
Specify the pixel width and height of the bitmap image.

@item @var{xorig}
@itemx @var{yorig}
Specify the location of the origin in the bitmap image.  The origin is
measured from the lower left corner of the bitmap, with right and up
being the positive axes.

@item @var{xmove}
@itemx @var{ymove}
Specify the @var{x} and @var{y} offsets to be added to the current
raster position after the bitmap is drawn.

@item @var{bitmap}
Specifies the address of the bitmap image.

@end table

A bitmap is a binary image.  When drawn, the bitmap is positioned
relative to the current raster position, and frame buffer pixels
corresponding to 1's in the bitmap are written using the current raster
color or index.  Frame buffer pixels corresponding to 0's in the bitmap
are not modified.

@code{glBitmap} takes seven arguments.  The first pair specifies the
width and height of the bitmap image.  The second pair specifies the
location of the bitmap origin relative to the lower left corner of the
bitmap image.  The third pair of arguments specifies @var{x} and @var{y}
offsets to be added to the current raster position after the bitmap has
been drawn.  The final argument is a pointer to the bitmap image itself.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
bitmap image is specified, @var{bitmap} is treated as a byte offset into
the buffer object's data store.

The bitmap image is interpreted like image data for the
@code{glDrawPixels} command, with @var{width} and @var{height}
corresponding to the width and height arguments of that command, and
with @var{type} set to @code{GL_BITMAP} and @var{format} set to
@code{GL_COLOR_INDEX}.  Modes specified using @code{glPixelStore} affect
the interpretation of bitmap image data; modes specified using
@code{glPixelTransfer} do not.

If the current raster position is invalid, @code{glBitmap} is ignored.
Otherwise, the lower left corner of the bitmap image is positioned at
the window coordinates

@r{@var{x}_@var{w}=⌊@var{x}_@var{r}-@var{x}_@var{o},⌋}

@r{@var{y}_@var{w}=⌊@var{y}_@var{r}-@var{y}_@var{o},⌋}

where @r{(@var{x}_@var{r},@var{y}_@var{r})} is the raster position and
@r{(@var{x}_@var{o},@var{y}_@var{o})} is the bitmap origin.  Fragments
are then generated for each pixel corresponding to a 1 (one) in the
bitmap image.  These fragments are generated using the current raster
@var{z} coordinate, color or color index, and current raster texture
coordinates.  They are then treated just as if they had been generated
by a point, line, or polygon, including texture mapping, fogging, and
all per-fragment operations such as alpha and depth testing.

After the bitmap has been drawn, the @var{x} and @var{y} coordinates of
the current raster position are offset by @var{xmove} and @var{ymove}.
No change is made to the @var{z} coordinate of the current raster
position, or to the current raster color, texture coordinates, or index.

@code{GL_INVALID_VALUE} is generated if @var{width} or @var{height} is
negative.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if @code{glBitmap} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glBlendColor red green blue alpha
Set the blend color.

@table @asis
@item @var{red}
@itemx @var{green}
@itemx @var{blue}
@itemx @var{alpha}
specify the components of @code{GL_BLEND_COLOR}

@end table

The @code{GL_BLEND_COLOR} may be used to calculate the source and
destination blending factors.  The color components are clamped to the
range @r{[0,1]} before being stored.  See @code{glBlendFunc} for a
complete description of the blending operations.  Initially the
@code{GL_BLEND_COLOR} is set to (0, 0, 0, 0).

@code{GL_INVALID_OPERATION} is generated if @code{glBlendColor} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.



@end deftypefun

@deftypefun void glBlendEquationSeparate modeRGB modeAlpha
Set the RGB blend equation and the alpha blend equation separately.

@table @asis
@item @var{modeRGB}
specifies the RGB blend equation, how the red, green, and blue
components of the source and destination colors are combined.  It must
be @code{GL_FUNC_ADD}, @code{GL_FUNC_SUBTRACT},
@code{GL_FUNC_REVERSE_SUBTRACT}, @code{GL_MIN}, @code{GL_MAX}.

@item @var{modeAlpha}
specifies the alpha blend equation, how the alpha component of the
source and destination colors are combined.  It must be
@code{GL_FUNC_ADD}, @code{GL_FUNC_SUBTRACT},
@code{GL_FUNC_REVERSE_SUBTRACT}, @code{GL_MIN}, @code{GL_MAX}.

@end table

The blend equations determines how a new pixel (the ''source'' color) is
combined with a pixel already in the framebuffer (the ''destination''
color).  This function specifies one blend equation for the RGB-color
components and one blend equation for the alpha component.

The blend equations use the source and destination blend factors
specified by either @code{glBlendFunc} or @code{glBlendFuncSeparate}.
See @code{glBlendFunc} or @code{glBlendFuncSeparate} for a description
of the various blend factors.

In the equations that follow, source and destination color components
are referred to as
@r{(@var{R}_@var{s},@var{G}_@var{s}@var{B}_@var{s}@var{A}_@var{s})} and
@r{(@var{R}_@var{d},@var{G}_@var{d}@var{B}_@var{d}@var{A}_@var{d})},
respectively.  The result color is referred to as
@r{(@var{R}_@var{r},@var{G}_@var{r}@var{B}_@var{r}@var{A}_@var{r})}.  The
source and destination blend factors are denoted
@r{(@var{s}_@var{R},@var{s}_@var{G}@var{s}_@var{B}@var{s}_@var{A})} and
@r{(@var{d}_@var{R},@var{d}_@var{G}@var{d}_@var{B}@var{d}_@var{A})},
respectively.  For these equations all color components are understood
to have values in the range @r{[0,1]}.

@table @asis
@item @strong{Mode}
@strong{RGB Components}, @strong{Alpha Component}

@item @code{GL_FUNC_ADD}
@r{@var{Rr}=@var{R}_@var{s}⁢@var{s}_@var{R}+@var{R}_@var{d}⁢@var{d}_@var{R}}@r{@var{Gr}=@var{G}_@var{s}⁢@var{s}_@var{G}+@var{G}_@var{d}⁢@var{d}_@var{G}}@r{@var{Br}=@var{B}_@var{s}⁢@var{s}_@var{B}+@var{B}_@var{d}⁢@var{d}_@var{B}},
@r{@var{Ar}=@var{A}_@var{s}⁢@var{s}_@var{A}+@var{A}_@var{d}⁢@var{d}_@var{A}}

@item @code{GL_FUNC_SUBTRACT}
@r{@var{Rr}=@var{R}_@var{s}⁢@var{s}_@var{R}-@var{R}_@var{d}⁢@var{d}_@var{R}}@r{@var{Gr}=@var{G}_@var{s}⁢@var{s}_@var{G}-@var{G}_@var{d}⁢@var{d}_@var{G}}@r{@var{Br}=@var{B}_@var{s}⁢@var{s}_@var{B}-@var{B}_@var{d}⁢@var{d}_@var{B}},
@r{@var{Ar}=@var{A}_@var{s}⁢@var{s}_@var{A}-@var{A}_@var{d}⁢@var{d}_@var{A}}

@item @code{GL_FUNC_REVERSE_SUBTRACT}
@r{@var{Rr}=@var{R}_@var{d}⁢@var{d}_@var{R}-@var{R}_@var{s}⁢@var{s}_@var{R}}@r{@var{Gr}=@var{G}_@var{d}⁢@var{d}_@var{G}-@var{G}_@var{s}⁢@var{s}_@var{G}}@r{@var{Br}=@var{B}_@var{d}⁢@var{d}_@var{B}-@var{B}_@var{s}⁢@var{s}_@var{B}},
@r{@var{Ar}=@var{A}_@var{d}⁢@var{d}_@var{A}-@var{A}_@var{s}⁢@var{s}_@var{A}}

@item @code{GL_MIN}
@r{@var{Rr}=@var{min}⁡(@var{R}_@var{s},@var{R}_@var{d})}@r{@var{Gr}=@var{min}⁡(@var{G}_@var{s},@var{G}_@var{d})}@r{@var{Br}=@var{min}⁡(@var{B}_@var{s},@var{B}_@var{d})},
@r{@var{Ar}=@var{min}⁡(@var{A}_@var{s},@var{A}_@var{d})}

@item @code{GL_MAX}
@r{@var{Rr}=@var{max}⁡(@var{R}_@var{s},@var{R}_@var{d})}@r{@var{Gr}=@var{max}⁡(@var{G}_@var{s},@var{G}_@var{d})}@r{@var{Br}=@var{max}⁡(@var{B}_@var{s},@var{B}_@var{d})},
@r{@var{Ar}=@var{max}⁡(@var{A}_@var{s},@var{A}_@var{d})}

@end table

The results of these equations are clamped to the range @r{[0,1]}.

The @code{GL_MIN} and @code{GL_MAX} equations are useful for
applications that analyze image data (image thresholding against a
constant color, for example).  The @code{GL_FUNC_ADD} equation is useful
for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are
set to @code{GL_FUNC_ADD}.



@code{GL_INVALID_ENUM} is generated if either @var{modeRGB} or
@var{modeAlpha} is not one of @code{GL_FUNC_ADD},
@code{GL_FUNC_SUBTRACT}, @code{GL_FUNC_REVERSE_SUBTRACT}, @code{GL_MAX},
or @code{GL_MIN}.

@code{GL_INVALID_OPERATION} is generated if
@code{glBlendEquationSeparate} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBlendEquation mode
Specify the equation used for both the RGB blend equation and the Alpha
blend equation.

@table @asis
@item @var{mode}
specifies how source and destination colors are combined.  It must be
@code{GL_FUNC_ADD}, @code{GL_FUNC_SUBTRACT},
@code{GL_FUNC_REVERSE_SUBTRACT}, @code{GL_MIN}, @code{GL_MAX}.

@end table

The blend equations determine how a new pixel (the ''source'' color) is
combined with a pixel already in the framebuffer (the ''destination''
color).  This function sets both the RGB blend equation and the alpha
blend equation to a single equation.

These equations use the source and destination blend factors specified
by either @code{glBlendFunc} or @code{glBlendFuncSeparate}.  See
@code{glBlendFunc} or @code{glBlendFuncSeparate} for a description of
the various blend factors.

In the equations that follow, source and destination color components
are referred to as
@r{(@var{R}_@var{s},@var{G}_@var{s}@var{B}_@var{s}@var{A}_@var{s})} and
@r{(@var{R}_@var{d},@var{G}_@var{d}@var{B}_@var{d}@var{A}_@var{d})},
respectively.  The result color is referred to as
@r{(@var{R}_@var{r},@var{G}_@var{r}@var{B}_@var{r}@var{A}_@var{r})}.  The
source and destination blend factors are denoted
@r{(@var{s}_@var{R},@var{s}_@var{G}@var{s}_@var{B}@var{s}_@var{A})} and
@r{(@var{d}_@var{R},@var{d}_@var{G}@var{d}_@var{B}@var{d}_@var{A})},
respectively.  For these equations all color components are understood
to have values in the range @r{[0,1]}.

@table @asis
@item @strong{Mode}
@strong{RGB Components}, @strong{Alpha Component}

@item @code{GL_FUNC_ADD}
@r{@var{Rr}=@var{R}_@var{s}⁢@var{s}_@var{R}+@var{R}_@var{d}⁢@var{d}_@var{R}}@r{@var{Gr}=@var{G}_@var{s}⁢@var{s}_@var{G}+@var{G}_@var{d}⁢@var{d}_@var{G}}@r{@var{Br}=@var{B}_@var{s}⁢@var{s}_@var{B}+@var{B}_@var{d}⁢@var{d}_@var{B}},
@r{@var{Ar}=@var{A}_@var{s}⁢@var{s}_@var{A}+@var{A}_@var{d}⁢@var{d}_@var{A}}

@item @code{GL_FUNC_SUBTRACT}
@r{@var{Rr}=@var{R}_@var{s}⁢@var{s}_@var{R}-@var{R}_@var{d}⁢@var{d}_@var{R}}@r{@var{Gr}=@var{G}_@var{s}⁢@var{s}_@var{G}-@var{G}_@var{d}⁢@var{d}_@var{G}}@r{@var{Br}=@var{B}_@var{s}⁢@var{s}_@var{B}-@var{B}_@var{d}⁢@var{d}_@var{B}},
@r{@var{Ar}=@var{A}_@var{s}⁢@var{s}_@var{A}-@var{A}_@var{d}⁢@var{d}_@var{A}}

@item @code{GL_FUNC_REVERSE_SUBTRACT}
@r{@var{Rr}=@var{R}_@var{d}⁢@var{d}_@var{R}-@var{R}_@var{s}⁢@var{s}_@var{R}}@r{@var{Gr}=@var{G}_@var{d}⁢@var{d}_@var{G}-@var{G}_@var{s}⁢@var{s}_@var{G}}@r{@var{Br}=@var{B}_@var{d}⁢@var{d}_@var{B}-@var{B}_@var{s}⁢@var{s}_@var{B}},
@r{@var{Ar}=@var{A}_@var{d}⁢@var{d}_@var{A}-@var{A}_@var{s}⁢@var{s}_@var{A}}

@item @code{GL_MIN}
@r{@var{Rr}=@var{min}⁡(@var{R}_@var{s},@var{R}_@var{d})}@r{@var{Gr}=@var{min}⁡(@var{G}_@var{s},@var{G}_@var{d})}@r{@var{Br}=@var{min}⁡(@var{B}_@var{s},@var{B}_@var{d})},
@r{@var{Ar}=@var{min}⁡(@var{A}_@var{s},@var{A}_@var{d})}

@item @code{GL_MAX}
@r{@var{Rr}=@var{max}⁡(@var{R}_@var{s},@var{R}_@var{d})}@r{@var{Gr}=@var{max}⁡(@var{G}_@var{s},@var{G}_@var{d})}@r{@var{Br}=@var{max}⁡(@var{B}_@var{s},@var{B}_@var{d})},
@r{@var{Ar}=@var{max}⁡(@var{A}_@var{s},@var{A}_@var{d})}

@end table

The results of these equations are clamped to the range @r{[0,1]}.

The @code{GL_MIN} and @code{GL_MAX} equations are useful for
applications that analyze image data (image thresholding against a
constant color, for example).  The @code{GL_FUNC_ADD} equation is useful
for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are
set to @code{GL_FUNC_ADD}.



@code{GL_INVALID_ENUM} is generated if @var{mode} is not one of
@code{GL_FUNC_ADD}, @code{GL_FUNC_SUBTRACT},
@code{GL_FUNC_REVERSE_SUBTRACT}, @code{GL_MAX}, or @code{GL_MIN}.

@code{GL_INVALID_OPERATION} is generated if @code{glBlendEquation} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBlendFuncSeparate srcRGB dstRGB srcAlpha dstAlpha
Specify pixel arithmetic for RGB and alpha components separately.

@table @asis
@item @var{srcRGB}
Specifies how the red, green, and blue blending factors are computed.
The following symbolic constants are accepted: @code{GL_ZERO},
@code{GL_ONE}, @code{GL_SRC_COLOR}, @code{GL_ONE_MINUS_SRC_COLOR},
@code{GL_DST_COLOR}, @code{GL_ONE_MINUS_DST_COLOR}, @code{GL_SRC_ALPHA},
@code{GL_ONE_MINUS_SRC_ALPHA}, @code{GL_DST_ALPHA},
@code{GL_ONE_MINUS_DST_ALPHA}, @code{GL_CONSTANT_COLOR},
@code{GL_ONE_MINUS_CONSTANT_COLOR}, @code{GL_CONSTANT_ALPHA},
@code{GL_ONE_MINUS_CONSTANT_ALPHA}, and @code{GL_SRC_ALPHA_SATURATE}.
The initial value is @code{GL_ONE}.

@item @var{dstRGB}
Specifies how the red, green, and blue destination blending factors are
computed.  The following symbolic constants are accepted:
@code{GL_ZERO}, @code{GL_ONE}, @code{GL_SRC_COLOR},
@code{GL_ONE_MINUS_SRC_COLOR}, @code{GL_DST_COLOR},
@code{GL_ONE_MINUS_DST_COLOR}, @code{GL_SRC_ALPHA},
@code{GL_ONE_MINUS_SRC_ALPHA}, @code{GL_DST_ALPHA},
@code{GL_ONE_MINUS_DST_ALPHA}.  @code{GL_CONSTANT_COLOR},
@code{GL_ONE_MINUS_CONSTANT_COLOR}, @code{GL_CONSTANT_ALPHA}, and
@code{GL_ONE_MINUS_CONSTANT_ALPHA}.  The initial value is
@code{GL_ZERO}.

@item @var{srcAlpha}
Specified how the alpha source blending factor is computed.  The same
symbolic constants are accepted as for @var{srcRGB}.  The initial value
is @code{GL_ONE}.

@item @var{dstAlpha}
Specified how the alpha destination blending factor is computed.  The
same symbolic constants are accepted as for @var{dstRGB}.  The initial
value is @code{GL_ZERO}.

@end table

In RGBA mode, pixels can be drawn using a function that blends the
incoming (source) RGBA values with the RGBA values that are already in
the frame buffer (the destination values).  Blending is initially
disabled.  Use @code{glEnable} and @code{glDisable} with argument
@code{GL_BLEND} to enable and disable blending.

@code{glBlendFuncSeparate} defines the operation of blending when it is
enabled.  @var{srcRGB} specifies which method is used to scale the
source RGB-color components.  @var{dstRGB} specifies which method is
used to scale the destination RGB-color components.  Likewise,
@var{srcAlpha} specifies which method is used to scale the source alpha
color component, and @var{dstAlpha} specifies which method is used to
scale the destination alpha component.  The possible methods are
described in the following table.  Each method defines four scale
factors, one each for red, green, blue, and alpha.

In the table and in subsequent equations, source and destination color
components are referred to as
@r{(@var{R}_@var{s},@var{G}_@var{s}@var{B}_@var{s}@var{A}_@var{s})} and
@r{(@var{R}_@var{d},@var{G}_@var{d}@var{B}_@var{d}@var{A}_@var{d})}.  The
color specified by @code{glBlendColor} is referred to as
@r{(@var{R}_@var{c},@var{G}_@var{c}@var{B}_@var{c}@var{A}_@var{c})}.
They are understood to have integer values between 0 and
@r{(@var{k}_@var{R},@var{k}_@var{G}@var{k}_@var{B}@var{k}_@var{A})},
where

@r{@var{k}_@var{c}=2^@var{m}_@var{c},-1}

and @r{(@var{m}_@var{R},@var{m}_@var{G}@var{m}_@var{B}@var{m}_@var{A})}
is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as
@r{(@var{s}_@var{R},@var{s}_@var{G}@var{s}_@var{B}@var{s}_@var{A})} and
@r{(@var{d}_@var{R},@var{d}_@var{G}@var{d}_@var{B}@var{d}_@var{A})}.  All
scale factors have range @r{[0,1]}.



@table @asis
@item @strong{Parameter}
@strong{RGB Factor}, @strong{Alpha Factor}

@item @code{GL_ZERO}
@r{(0,00)}, @r{0}

@item @code{GL_ONE}
@r{(1,11)}, @r{1}

@item @code{GL_SRC_COLOR}
@r{(@var{R}_@var{s}/@var{k}_@var{R},@var{G}_@var{s}/@var{k}_@var{G}@var{B}_@var{s}/@var{k}_@var{B})},
@r{@var{A}_@var{s}/@var{k}_@var{A}}

@item @code{GL_ONE_MINUS_SRC_COLOR}
@r{(1,111)-(@var{R}_@var{s}/@var{k}_@var{R},@var{G}_@var{s}/@var{k}_@var{G}@var{B}_@var{s}/@var{k}_@var{B})},
@r{1-@var{A}_@var{s}/@var{k}_@var{A}}

@item @code{GL_DST_COLOR}
@r{(@var{R}_@var{d}/@var{k}_@var{R},@var{G}_@var{d}/@var{k}_@var{G}@var{B}_@var{d}/@var{k}_@var{B})},
@r{@var{A}_@var{d}/@var{k}_@var{A}}

@item @code{GL_ONE_MINUS_DST_COLOR}
@r{(1,11)-(@var{R}_@var{d}/@var{k}_@var{R},@var{G}_@var{d}/@var{k}_@var{G}@var{B}_@var{d}/@var{k}_@var{B})},
@r{1-@var{A}_@var{d}/@var{k}_@var{A}}

@item @code{GL_SRC_ALPHA}
@r{(@var{A}_@var{s}/@var{k}_@var{A},@var{A}_@var{s}/@var{k}_@var{A}@var{A}_@var{s}/@var{k}_@var{A})},
@r{@var{A}_@var{s}/@var{k}_@var{A}}

@item @code{GL_ONE_MINUS_SRC_ALPHA}
@r{(1,11)-(@var{A}_@var{s}/@var{k}_@var{A},@var{A}_@var{s}/@var{k}_@var{A}@var{A}_@var{s}/@var{k}_@var{A})},
@r{1-@var{A}_@var{s}/@var{k}_@var{A}}

@item @code{GL_DST_ALPHA}
@r{(@var{A}_@var{d}/@var{k}_@var{A},@var{A}_@var{d}/@var{k}_@var{A}@var{A}_@var{d}/@var{k}_@var{A})},
@r{@var{A}_@var{d}/@var{k}_@var{A}}

@item @code{GL_ONE_MINUS_DST_ALPHA}
@r{(1,11)-(@var{A}_@var{d}/@var{k}_@var{A},@var{A}_@var{d}/@var{k}_@var{A}@var{A}_@var{d}/@var{k}_@var{A})},
@r{1-@var{A}_@var{d}/@var{k}_@var{A}}

@item @code{GL_CONSTANT_COLOR}
@r{(@var{R}_@var{c},@var{G}_@var{c}@var{B}_@var{c})},
@r{@var{A}_@var{c}}

@item @code{GL_ONE_MINUS_CONSTANT_COLOR}
@r{(1,11)-(@var{R}_@var{c},@var{G}_@var{c}@var{B}_@var{c})},
@r{1-@var{A}_@var{c}}

@item @code{GL_CONSTANT_ALPHA}
@r{(@var{A}_@var{c},@var{A}_@var{c}@var{A}_@var{c})},
@r{@var{A}_@var{c}}

@item @code{GL_ONE_MINUS_CONSTANT_ALPHA}
@r{(1,11)-(@var{A}_@var{c},@var{A}_@var{c}@var{A}_@var{c})},
@r{1-@var{A}_@var{c}}

@item @code{GL_SRC_ALPHA_SATURATE}
@r{(@var{i},@var{i}@var{i})}, @r{1}

@end table

In the table,

@r{@var{i}=@var{min}⁡(@var{A}_@var{s},1-@var{A}_@var{d},)}

To determine the blended RGBA values of a pixel when drawing in RGBA
mode, the system uses the following equations:

@r{@var{R}_@var{d}=@var{min}⁡(@var{k}_@var{R},@var{R}_@var{s}⁢@var{s}_@var{R}+@var{R}_@var{d}⁢@var{d}_@var{R})}@r{@var{G}_@var{d}=@var{min}⁡(@var{k}_@var{G},@var{G}_@var{s}⁢@var{s}_@var{G}+@var{G}_@var{d}⁢@var{d}_@var{G})}@r{@var{B}_@var{d}=@var{min}⁡(@var{k}_@var{B},@var{B}_@var{s}⁢@var{s}_@var{B}+@var{B}_@var{d}⁢@var{d}_@var{B})}@r{@var{A}_@var{d}=@var{min}⁡(@var{k}_@var{A},@var{A}_@var{s}⁢@var{s}_@var{A}+@var{A}_@var{d}⁢@var{d}_@var{A})}

Despite the apparent precision of the above equations, blending
arithmetic is not exactly specified, because blending operates with
imprecise integer color values.  However, a blend factor that should be
equal to 1 is guaranteed not to modify its multiplicand, and a blend
factor equal to 0 reduces its multiplicand to 0.  For example, when
@var{srcRGB} is @code{GL_SRC_ALPHA}, @var{dstRGB} is
@code{GL_ONE_MINUS_SRC_ALPHA}, and @r{@var{A}_@var{s}} is equal to
@r{@var{k}_@var{A}}, the equations reduce to simple replacement:

@r{@var{R}_@var{d}=@var{R}_@var{s}}@r{@var{G}_@var{d}=@var{G}_@var{s}}@r{@var{B}_@var{d}=@var{B}_@var{s}}@r{@var{A}_@var{d}=@var{A}_@var{s}}



@code{GL_INVALID_ENUM} is generated if either @var{srcRGB} or
@var{dstRGB} is not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glBlendFuncSeparate}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBlendFunc sfactor dfactor
Specify pixel arithmetic.

@table @asis
@item @var{sfactor}
Specifies how the red, green, blue, and alpha source blending factors
are computed.  The following symbolic constants are accepted:
@code{GL_ZERO}, @code{GL_ONE}, @code{GL_SRC_COLOR},
@code{GL_ONE_MINUS_SRC_COLOR}, @code{GL_DST_COLOR},
@code{GL_ONE_MINUS_DST_COLOR}, @code{GL_SRC_ALPHA},
@code{GL_ONE_MINUS_SRC_ALPHA}, @code{GL_DST_ALPHA},
@code{GL_ONE_MINUS_DST_ALPHA}, @code{GL_CONSTANT_COLOR},
@code{GL_ONE_MINUS_CONSTANT_COLOR}, @code{GL_CONSTANT_ALPHA},
@code{GL_ONE_MINUS_CONSTANT_ALPHA}, and @code{GL_SRC_ALPHA_SATURATE}.
The initial value is @code{GL_ONE}.

@item @var{dfactor}
Specifies how the red, green, blue, and alpha destination blending
factors are computed.  The following symbolic constants are accepted:
@code{GL_ZERO}, @code{GL_ONE}, @code{GL_SRC_COLOR},
@code{GL_ONE_MINUS_SRC_COLOR}, @code{GL_DST_COLOR},
@code{GL_ONE_MINUS_DST_COLOR}, @code{GL_SRC_ALPHA},
@code{GL_ONE_MINUS_SRC_ALPHA}, @code{GL_DST_ALPHA},
@code{GL_ONE_MINUS_DST_ALPHA}.  @code{GL_CONSTANT_COLOR},
@code{GL_ONE_MINUS_CONSTANT_COLOR}, @code{GL_CONSTANT_ALPHA}, and
@code{GL_ONE_MINUS_CONSTANT_ALPHA}.  The initial value is
@code{GL_ZERO}.

@end table

In RGBA mode, pixels can be drawn using a function that blends the
incoming (source) RGBA values with the RGBA values that are already in
the frame buffer (the destination values).  Blending is initially
disabled.  Use @code{glEnable} and @code{glDisable} with argument
@code{GL_BLEND} to enable and disable blending.

@code{glBlendFunc} defines the operation of blending when it is enabled.
@var{sfactor} specifies which method is used to scale the source color
components.  @var{dfactor} specifies which method is used to scale the
destination color components.  The possible methods are described in the
following table.  Each method defines four scale factors, one each for
red, green, blue, and alpha.  In the table and in subsequent equations,
source and destination color components are referred to as
@r{(@var{R}_@var{s},@var{G}_@var{s}@var{B}_@var{s}@var{A}_@var{s})} and
@r{(@var{R}_@var{d},@var{G}_@var{d}@var{B}_@var{d}@var{A}_@var{d})}.  The
color specified by @code{glBlendColor} is referred to as
@r{(@var{R}_@var{c},@var{G}_@var{c}@var{B}_@var{c}@var{A}_@var{c})}.
They are understood to have integer values between 0 and
@r{(@var{k}_@var{R},@var{k}_@var{G}@var{k}_@var{B}@var{k}_@var{A})},
where

@r{@var{k}_@var{c}=2^@var{m}_@var{c},-1}

and @r{(@var{m}_@var{R},@var{m}_@var{G}@var{m}_@var{B}@var{m}_@var{A})}
is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as
@r{(@var{s}_@var{R},@var{s}_@var{G}@var{s}_@var{B}@var{s}_@var{A})} and
@r{(@var{d}_@var{R},@var{d}_@var{G}@var{d}_@var{B}@var{d}_@var{A})}.  The
scale factors described in the table, denoted
@r{(@var{f}_@var{R},@var{f}_@var{G}@var{f}_@var{B}@var{f}_@var{A})},
represent either source or destination factors.  All scale factors have
range @r{[0,1]}.



@table @asis
@item @strong{Parameter}
@strong{@r{(@var{f}_@var{R},@var{f}_@var{G}@var{f}_@var{B}@var{f}_@var{A})}}

@item @code{GL_ZERO}
@r{(0,000)}

@item @code{GL_ONE}
@r{(1,111)}

@item @code{GL_SRC_COLOR}
@r{(@var{R}_@var{s}/@var{k}_@var{R},@var{G}_@var{s}/@var{k}_@var{G}@var{B}_@var{s}/@var{k}_@var{B}@var{A}_@var{s}/@var{k}_@var{A})}

@item @code{GL_ONE_MINUS_SRC_COLOR}
@r{(1,111)-(@var{R}_@var{s}/@var{k}_@var{R},@var{G}_@var{s}/@var{k}_@var{G}@var{B}_@var{s}/@var{k}_@var{B}@var{A}_@var{s}/@var{k}_@var{A})}

@item @code{GL_DST_COLOR}
@r{(@var{R}_@var{d}/@var{k}_@var{R},@var{G}_@var{d}/@var{k}_@var{G}@var{B}_@var{d}/@var{k}_@var{B}@var{A}_@var{d}/@var{k}_@var{A})}

@item @code{GL_ONE_MINUS_DST_COLOR}
@r{(1,111)-(@var{R}_@var{d}/@var{k}_@var{R},@var{G}_@var{d}/@var{k}_@var{G}@var{B}_@var{d}/@var{k}_@var{B}@var{A}_@var{d}/@var{k}_@var{A})}

@item @code{GL_SRC_ALPHA}
@r{(@var{A}_@var{s}/@var{k}_@var{A},@var{A}_@var{s}/@var{k}_@var{A}@var{A}_@var{s}/@var{k}_@var{A}@var{A}_@var{s}/@var{k}_@var{A})}

@item @code{GL_ONE_MINUS_SRC_ALPHA}
@r{(1,111)-(@var{A}_@var{s}/@var{k}_@var{A},@var{A}_@var{s}/@var{k}_@var{A}@var{A}_@var{s}/@var{k}_@var{A}@var{A}_@var{s}/@var{k}_@var{A})}

@item @code{GL_DST_ALPHA}
@r{(@var{A}_@var{d}/@var{k}_@var{A},@var{A}_@var{d}/@var{k}_@var{A}@var{A}_@var{d}/@var{k}_@var{A}@var{A}_@var{d}/@var{k}_@var{A})}

@item @code{GL_ONE_MINUS_DST_ALPHA}
@r{(1,111)-(@var{A}_@var{d}/@var{k}_@var{A},@var{A}_@var{d}/@var{k}_@var{A}@var{A}_@var{d}/@var{k}_@var{A}@var{A}_@var{d}/@var{k}_@var{A})}

@item @code{GL_CONSTANT_COLOR}
@r{(@var{R}_@var{c},@var{G}_@var{c}@var{B}_@var{c}@var{A}_@var{c})}

@item @code{GL_ONE_MINUS_CONSTANT_COLOR}
@r{(1,111)-(@var{R}_@var{c},@var{G}_@var{c}@var{B}_@var{c}@var{A}_@var{c})}

@item @code{GL_CONSTANT_ALPHA}
@r{(@var{A}_@var{c},@var{A}_@var{c}@var{A}_@var{c}@var{A}_@var{c})}

@item @code{GL_ONE_MINUS_CONSTANT_ALPHA}
@r{(1,111)-(@var{A}_@var{c},@var{A}_@var{c}@var{A}_@var{c}@var{A}_@var{c})}

@item @code{GL_SRC_ALPHA_SATURATE}
@r{(@var{i},@var{i}@var{i}1)}

@end table

In the table,

@r{@var{i}=@var{min}⁡(@var{A}_@var{s},@var{k}_@var{A}-@var{A}_@var{d})/@var{k}_@var{A}}

To determine the blended RGBA values of a pixel when drawing in RGBA
mode, the system uses the following equations:

@r{@var{R}_@var{d}=@var{min}⁡(@var{k}_@var{R},@var{R}_@var{s}⁢@var{s}_@var{R}+@var{R}_@var{d}⁢@var{d}_@var{R})}@r{@var{G}_@var{d}=@var{min}⁡(@var{k}_@var{G},@var{G}_@var{s}⁢@var{s}_@var{G}+@var{G}_@var{d}⁢@var{d}_@var{G})}@r{@var{B}_@var{d}=@var{min}⁡(@var{k}_@var{B},@var{B}_@var{s}⁢@var{s}_@var{B}+@var{B}_@var{d}⁢@var{d}_@var{B})}@r{@var{A}_@var{d}=@var{min}⁡(@var{k}_@var{A},@var{A}_@var{s}⁢@var{s}_@var{A}+@var{A}_@var{d}⁢@var{d}_@var{A})}

Despite the apparent precision of the above equations, blending
arithmetic is not exactly specified, because blending operates with
imprecise integer color values.  However, a blend factor that should be
equal to 1 is guaranteed not to modify its multiplicand, and a blend
factor equal to 0 reduces its multiplicand to 0.  For example, when
@var{sfactor} is @code{GL_SRC_ALPHA}, @var{dfactor} is
@code{GL_ONE_MINUS_SRC_ALPHA}, and @r{@var{A}_@var{s}} is equal to
@r{@var{k}_@var{A}}, the equations reduce to simple replacement:

@r{@var{R}_@var{d}=@var{R}_@var{s}}@r{@var{G}_@var{d}=@var{G}_@var{s}}@r{@var{B}_@var{d}=@var{B}_@var{s}}@r{@var{A}_@var{d}=@var{A}_@var{s}}



@code{GL_INVALID_ENUM} is generated if either @var{sfactor} or
@var{dfactor} is not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glBlendFunc} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBufferData target size data usage
Creates and initializes a buffer object's data store.

@table @asis
@item @var{target}
Specifies the target buffer object.  The symbolic constant must be
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@item @var{size}
Specifies the size in bytes of the buffer object's new data store.

@item @var{data}
Specifies a pointer to data that will be copied into the data store for
initialization, or @code{NULL} if no data is to be copied.

@item @var{usage}
Specifies the expected usage pattern of the data store.  The symbolic
constant must be @code{GL_STREAM_DRAW}, @code{GL_STREAM_READ},
@code{GL_STREAM_COPY}, @code{GL_STATIC_DRAW}, @code{GL_STATIC_READ},
@code{GL_STATIC_COPY}, @code{GL_DYNAMIC_DRAW}, @code{GL_DYNAMIC_READ},
or @code{GL_DYNAMIC_COPY}.

@end table

@code{glBufferData} creates a new data store for the buffer object
currently bound to @var{target}.  Any pre-existing data store is
deleted.  The new data store is created with the specified @var{size} in
bytes and @var{usage}.  If @var{data} is not @code{NULL}, the data store
is initialized with data from this pointer.  In its initial state, the
new data store is not mapped, it has a @code{NULL} mapped pointer, and
its mapped access is @code{GL_READ_WRITE}.

@var{usage} is a hint to the GL implementation as to how a buffer
object's data store will be accessed.  This enables the GL
implementation to make more intelligent decisions that may significantly
impact buffer object performance.  It does not, however, constrain the
actual usage of the data store.  @var{usage} can be broken down into two
parts: first, the frequency of access (modification and usage), and
second, the nature of that access.  The frequency of access may be one
of these:

@table @asis
@item STREAM
The data store contents will be modified once and used at most a few
times.

@item STATIC
The data store contents will be modified once and used many times.

@item DYNAMIC
The data store contents will be modified repeatedly and used many times.

@end table

The nature of access may be one of these:

@table @asis
@item DRAW
The data store contents are modified by the application, and used as the
source for GL drawing and image specification commands.

@item READ
The data store contents are modified by reading data from the GL, and
used to return that data when queried by the application.

@item COPY
The data store contents are modified by reading data from the GL, and
used as the source for GL drawing and image specification commands.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@code{GL_INVALID_ENUM} is generated if @var{usage} is not
@code{GL_STREAM_DRAW}, @code{GL_STREAM_READ}, @code{GL_STREAM_COPY},
@code{GL_STATIC_DRAW}, @code{GL_STATIC_READ}, @code{GL_STATIC_COPY},
@code{GL_DYNAMIC_DRAW}, @code{GL_DYNAMIC_READ}, or
@code{GL_DYNAMIC_COPY}.

@code{GL_INVALID_VALUE} is generated if @var{size} is negative.

@code{GL_INVALID_OPERATION} is generated if the reserved buffer object
name 0 is bound to @var{target}.

@code{GL_OUT_OF_MEMORY} is generated if the GL is unable to create a
data store with the specified @var{size}.

@code{GL_INVALID_OPERATION} is generated if @code{glBufferData} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glBufferSubData target offset size data
Updates a subset of a buffer object's data store.

@table @asis
@item @var{target}
Specifies the target buffer object.  The symbolic constant must be
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@item @var{offset}
Specifies the offset into the buffer object's data store where data
replacement will begin, measured in bytes.

@item @var{size}
Specifies the size in bytes of the data store region being replaced.

@item @var{data}
Specifies a pointer to the new data that will be copied into the data
store.

@end table

@code{glBufferSubData} redefines some or all of the data store for the
buffer object currently bound to @var{target}.  Data starting at byte
offset @var{offset} and extending for @var{size} bytes is copied to the
data store from the memory pointed to by @var{data}.  An error is thrown
if @var{offset} and @var{size} together define a range beyond the bounds
of the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@code{GL_INVALID_VALUE} is generated if @var{offset} or @var{size} is
negative, or if together they define a region of memory that extends
beyond the buffer object's allocated data store.

@code{GL_INVALID_OPERATION} is generated if the reserved buffer object
name 0 is bound to @var{target}.

@code{GL_INVALID_OPERATION} is generated if the buffer object being
updated is mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glBufferSubData} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCallLists n type lists
Execute a list of display lists.

@table @asis
@item @var{n}
Specifies the number of display lists to be executed.

@item @var{type}
Specifies the type of values in @var{lists}.  Symbolic constants
@code{GL_BYTE}, @code{GL_UNSIGNED_BYTE}, @code{GL_SHORT},
@code{GL_UNSIGNED_SHORT}, @code{GL_INT}, @code{GL_UNSIGNED_INT},
@code{GL_FLOAT}, @code{GL_2_BYTES}, @code{GL_3_BYTES}, and
@code{GL_4_BYTES} are accepted.

@item @var{lists}
Specifies the address of an array of name offsets in the display list.
The pointer type is void because the offsets can be bytes, shorts, ints,
or floats, depending on the value of @var{type}.

@end table

@code{glCallLists} causes each display list in the list of names passed
as @var{lists} to be executed.  As a result, the commands saved in each
display list are executed in order, just as if they were called without
using a display list.  Names of display lists that have not been defined
are ignored.

@code{glCallLists} provides an efficient means for executing more than
one display list.  @var{type} allows lists with various name formats to
be accepted.  The formats are as follows:

@table @asis
@item @code{GL_BYTE}
@var{lists} is treated as an array of signed bytes, each in the range
@r{-128} through 127.

@item @code{GL_UNSIGNED_BYTE}
@var{lists} is treated as an array of unsigned bytes, each in the range
0 through 255.

@item @code{GL_SHORT}
@var{lists} is treated as an array of signed two-byte integers, each in
the range @r{-32768} through 32767.

@item @code{GL_UNSIGNED_SHORT}
@var{lists} is treated as an array of unsigned two-byte integers, each
in the range 0 through 65535.

@item @code{GL_INT}
@var{lists} is treated as an array of signed four-byte integers.

@item @code{GL_UNSIGNED_INT}
@var{lists} is treated as an array of unsigned four-byte integers.

@item @code{GL_FLOAT}
@var{lists} is treated as an array of four-byte floating-point values.

@item @code{GL_2_BYTES}
@var{lists} is treated as an array of unsigned bytes.  Each pair of
bytes specifies a single display-list name.  The value of the pair is
computed as 256 times the unsigned value of the first byte plus the
unsigned value of the second byte.

@item @code{GL_3_BYTES}
@var{lists} is treated as an array of unsigned bytes.  Each triplet of
bytes specifies a single display-list name.  The value of the triplet is
computed as 65536 times the unsigned value of the first byte, plus 256
times the unsigned value of the second byte, plus the unsigned value of
the third byte.

@item @code{GL_4_BYTES}
@var{lists} is treated as an array of unsigned bytes.  Each quadruplet
of bytes specifies a single display-list name.  The value of the
quadruplet is computed as 16777216 times the unsigned value of the first
byte, plus 65536 times the unsigned value of the second byte, plus 256
times the unsigned value of the third byte, plus the unsigned value of
the fourth byte.

@end table

The list of display-list names is not null-terminated.  Rather, @var{n}
specifies how many names are to be taken from @var{lists}.

An additional level of indirection is made available with the
@code{glListBase} command, which specifies an unsigned offset that is
added to each display-list name specified in @var{lists} before that
display list is executed.

@code{glCallLists} can appear inside a display list.  To avoid the
possibility of infinite recursion resulting from display lists calling
one another, a limit is placed on the nesting level of display lists
during display-list execution.  This limit must be at least 64, and it
depends on the implementation.

GL state is not saved and restored across a call to @code{glCallLists}.
Thus, changes made to GL state during the execution of the display lists
remain after execution is completed.  Use @code{glPushAttrib},
@code{glPopAttrib}, @code{glPushMatrix}, and @code{glPopMatrix} to
preserve GL state across @code{glCallLists} calls.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of
@code{GL_BYTE}, @code{GL_UNSIGNED_BYTE}, @code{GL_SHORT},
@code{GL_UNSIGNED_SHORT}, @code{GL_INT}, @code{GL_UNSIGNED_INT},
@code{GL_FLOAT}, @code{GL_2_BYTES}, @code{GL_3_BYTES},
@code{GL_4_BYTES}.

@end deftypefun

@deftypefun void glCallList list
Execute a display list.

@table @asis
@item @var{list}
Specifies the integer name of the display list to be executed.

@end table

@code{glCallList} causes the named display list to be executed.  The
commands saved in the display list are executed in order, just as if
they were called without using a display list.  If @var{list} has not
been defined as a display list, @code{glCallList} is ignored.

@code{glCallList} can appear inside a display list.  To avoid the
possibility of infinite recursion resulting from display lists calling
one another, a limit is placed on the nesting level of display lists
during display-list execution.  This limit is at least 64, and it
depends on the implementation.

GL state is not saved and restored across a call to @code{glCallList}.
Thus, changes made to GL state during the execution of a display list
remain after execution of the display list is completed.  Use
@code{glPushAttrib}, @code{glPopAttrib}, @code{glPushMatrix}, and
@code{glPopMatrix} to preserve GL state across @code{glCallList} calls.

@end deftypefun

@deftypefun void glClearAccum red green blue alpha
Specify clear values for the accumulation buffer.

@table @asis
@item @var{red}
@itemx @var{green}
@itemx @var{blue}
@itemx @var{alpha}
Specify the red, green, blue, and alpha values used when the
accumulation buffer is cleared.  The initial values are all 0.

@end table

@code{glClearAccum} specifies the red, green, blue, and alpha values
used by @code{glClear} to clear the accumulation buffer.

Values specified by @code{glClearAccum} are clamped to the range
@r{[-1,1]}.

@code{GL_INVALID_OPERATION} is generated if @code{glClearAccum} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glClearColor red green blue alpha
Specify clear values for the color buffers.

@table @asis
@item @var{red}
@itemx @var{green}
@itemx @var{blue}
@itemx @var{alpha}
Specify the red, green, blue, and alpha values used when the color
buffers are cleared.  The initial values are all 0.

@end table

@code{glClearColor} specifies the red, green, blue, and alpha values
used by @code{glClear} to clear the color buffers.  Values specified by
@code{glClearColor} are clamped to the range @r{[0,1]}.

@code{GL_INVALID_OPERATION} is generated if @code{glClearColor} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glClearDepth depth
Specify the clear value for the depth buffer.

@table @asis
@item @var{depth}
Specifies the depth value used when the depth buffer is cleared.  The
initial value is 1.

@end table

@code{glClearDepth} specifies the depth value used by @code{glClear} to
clear the depth buffer.  Values specified by @code{glClearDepth} are
clamped to the range @r{[0,1]}.

@code{GL_INVALID_OPERATION} is generated if @code{glClearDepth} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glClearIndex c
Specify the clear value for the color index buffers.

@table @asis
@item @var{c}
Specifies the index used when the color index buffers are cleared.  The
initial value is 0.

@end table

@code{glClearIndex} specifies the index used by @code{glClear} to clear
the color index buffers.  @var{c} is not clamped.  Rather, @var{c} is
converted to a fixed-point value with unspecified precision to the right
of the binary point.  The integer part of this value is then masked with
@r{2^@var{m}-1}, where @r{@var{m}} is the number of bits in a color
index stored in the frame buffer.

@code{GL_INVALID_OPERATION} is generated if @code{glClearIndex} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glClearStencil s
Specify the clear value for the stencil buffer.

@table @asis
@item @var{s}
Specifies the index used when the stencil buffer is cleared.  The
initial value is 0.

@end table

@code{glClearStencil} specifies the index used by @code{glClear} to
clear the stencil buffer.  @var{s} is masked with @r{2^@var{m}-1}, where
@r{@var{m}} is the number of bits in the stencil buffer.

@code{GL_INVALID_OPERATION} is generated if @code{glClearStencil} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glClear mask
Clear buffers to preset values.

@table @asis
@item @var{mask}
Bitwise OR of masks that indicate the buffers to be cleared.  The four
masks are @code{GL_COLOR_BUFFER_BIT}, @code{GL_DEPTH_BUFFER_BIT},
@code{GL_ACCUM_BUFFER_BIT}, and @code{GL_STENCIL_BUFFER_BIT}.

@end table

@code{glClear} sets the bitplane area of the window to values previously
selected by @code{glClearColor}, @code{glClearIndex},
@code{glClearDepth}, @code{glClearStencil}, and @code{glClearAccum}.
Multiple color buffers can be cleared simultaneously by selecting more
than one buffer at a time using @code{glDrawBuffer}.

The pixel ownership test, the scissor test, dithering, and the buffer
writemasks affect the operation of @code{glClear}.  The scissor box
bounds the cleared region.  Alpha function, blend function, logical
operation, stenciling, texture mapping, and depth-buffering are ignored
by @code{glClear}.

@code{glClear} takes a single argument that is the bitwise OR of several
values indicating which buffer is to be cleared.

The values are as follows:

@table @asis
@item @code{GL_COLOR_BUFFER_BIT}
Indicates the buffers currently enabled for color writing.

@item @code{GL_DEPTH_BUFFER_BIT}
Indicates the depth buffer.

@item @code{GL_ACCUM_BUFFER_BIT}
Indicates the accumulation buffer.

@item @code{GL_STENCIL_BUFFER_BIT}
Indicates the stencil buffer.

@end table

The value to which each buffer is cleared depends on the setting of the
clear value for that buffer.

@code{GL_INVALID_VALUE} is generated if any bit other than the four
defined bits is set in @var{mask}.

@code{GL_INVALID_OPERATION} is generated if @code{glClear} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glClientActiveTexture texture
Select active texture unit.

@table @asis
@item @var{texture}
Specifies which texture unit to make active.  The number of texture
units is implementation dependent, but must be at least two.
@var{texture} must be one of @code{GL_TEXTURE}@r{@var{i}}, where i
ranges from 0 to the value of @code{GL_MAX_TEXTURE_COORDS} - 1, which is
an implementation-dependent value.  The initial value is
@code{GL_TEXTURE0}.

@end table

@code{glClientActiveTexture} selects the vertex array client state
parameters to be modified by @code{glTexCoordPointer}, and enabled or
disabled with @code{glEnableClientState} or @code{glDisableClientState},
respectively, when called with a parameter of
@code{GL_TEXTURE_COORD_ARRAY}.

@code{GL_INVALID_ENUM} is generated if @var{texture} is not one of
@code{GL_TEXTURE}@r{@var{i}}, where i ranges from 0 to the value of
@code{GL_MAX_TEXTURE_COORDS} - 1.

@end deftypefun

@deftypefun void glClipPlane plane equation
Specify a plane against which all geometry is clipped.

@table @asis
@item @var{plane}
Specifies which clipping plane is being positioned.  Symbolic names of
the form @code{GL_CLIP_PLANE}@var{i}, where @var{i} is an integer
between 0 and @code{GL_MAX_CLIP_PLANES}@r{-1}, are accepted.

@item @var{equation}
Specifies the address of an array of four double-precision
floating-point values.  These values are interpreted as a plane
equation.

@end table

Geometry is always clipped against the boundaries of a six-plane frustum
in @var{x}, @var{y}, and @var{z}.  @code{glClipPlane} allows the
specification of additional planes, not necessarily perpendicular to the
@var{x}, @var{y}, or @var{z} axis, against which all geometry is
clipped.  To determine the maximum number of additional clipping planes,
call @code{glGetIntegerv} with argument @code{GL_MAX_CLIP_PLANES}.  All
implementations support at least six such clipping planes.  Because the
resulting clipping region is the intersection of the defined
half-spaces, it is always convex.

@code{glClipPlane} specifies a half-space using a four-component plane
equation.  When @code{glClipPlane} is called, @var{equation} is
transformed by the inverse of the modelview matrix and stored in the
resulting eye coordinates.  Subsequent changes to the modelview matrix
have no effect on the stored plane-equation components.  If the dot
product of the eye coordinates of a vertex with the stored plane
equation components is positive or zero, the vertex is @var{in} with
respect to that clipping plane.  Otherwise, it is @var{out}.

To enable and disable clipping planes, call @code{glEnable} and
@code{glDisable} with the argument @code{GL_CLIP_PLANE}@var{i}, where
@var{i} is the plane number.

All clipping planes are initially defined as (0, 0, 0, 0) in eye
coordinates and are disabled.

@code{GL_INVALID_ENUM} is generated if @var{plane} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glClipPlane} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glColorMask red green blue alpha
Enable and disable writing of frame buffer color components.

@table @asis
@item @var{red}
@itemx @var{green}
@itemx @var{blue}
@itemx @var{alpha}
Specify whether red, green, blue, and alpha can or cannot be written
into the frame buffer.  The initial values are all @code{GL_TRUE},
indicating that the color components can be written.

@end table

@code{glColorMask} specifies whether the individual color components in
the frame buffer can or cannot be written.  If @var{red} is
@code{GL_FALSE}, for example, no change is made to the red component of
any pixel in any of the color buffers, regardless of the drawing
operation attempted.

Changes to individual bits of components cannot be controlled.  Rather,
changes are either enabled or disabled for entire color components.

@code{GL_INVALID_OPERATION} is generated if @code{glColorMask} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glColorMaterial face mode
Cause a material color to track the current color.

@table @asis
@item @var{face}
Specifies whether front, back, or both front and back material
parameters should track the current color.  Accepted values are
@code{GL_FRONT}, @code{GL_BACK}, and @code{GL_FRONT_AND_BACK}.  The
initial value is @code{GL_FRONT_AND_BACK}.

@item @var{mode}
Specifies which of several material parameters track the current color.
Accepted values are @code{GL_EMISSION}, @code{GL_AMBIENT},
@code{GL_DIFFUSE}, @code{GL_SPECULAR}, and
@code{GL_AMBIENT_AND_DIFFUSE}.  The initial value is
@code{GL_AMBIENT_AND_DIFFUSE}.

@end table

@code{glColorMaterial} specifies which material parameters track the
current color.  When @code{GL_COLOR_MATERIAL} is enabled, the material
parameter or parameters specified by @var{mode}, of the material or
materials specified by @var{face}, track the current color at all times.

To enable and disable @code{GL_COLOR_MATERIAL}, call @code{glEnable} and
@code{glDisable} with argument @code{GL_COLOR_MATERIAL}.
@code{GL_COLOR_MATERIAL} is initially disabled.

@code{GL_INVALID_ENUM} is generated if @var{face} or @var{mode} is not
an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glColorMaterial} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glColorPointer size type stride pointer
Define an array of colors.

@table @asis
@item @var{size}
Specifies the number of components per color.  Must be 3 or 4.  The
initial value is 4.

@item @var{type}
Specifies the data type of each color component in the array.  Symbolic
constants @code{GL_BYTE}, @code{GL_UNSIGNED_BYTE}, @code{GL_SHORT},
@code{GL_UNSIGNED_SHORT}, @code{GL_INT}, @code{GL_UNSIGNED_INT},
@code{GL_FLOAT}, and @code{GL_DOUBLE} are accepted.  The initial value
is @code{GL_FLOAT}.

@item @var{stride}
Specifies the byte offset between consecutive colors.  If @var{stride}
is 0, the colors are understood to be tightly packed in the array.  The
initial value is 0.

@item @var{pointer}
Specifies a pointer to the first component of the first color element in
the array.  The initial value is 0.

@end table

@code{glColorPointer} specifies the location and data format of an array
of color components to use when rendering.  @var{size} specifies the
number of components per color, and must be 3 or 4.  @var{type}
specifies the data type of each color component, and @var{stride}
specifies the byte stride from one color to the next, allowing vertices
and attributes to be packed into a single array or stored in separate
arrays.  (Single-array storage may be more efficient on some
implementations; see @code{glInterleavedArrays}.)

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a color array is specified,
@var{pointer} is treated as a byte offset into the buffer object's data
store.  Also, the buffer object binding (@code{GL_ARRAY_BUFFER_BINDING})
is saved as color vertex array client-side state
(@code{GL_COLOR_ARRAY_BUFFER_BINDING}).

When a color array is specified, @var{size}, @var{type}, @var{stride},
and @var{pointer} are saved as client-side state, in addition to the
current vertex array buffer object binding.

To enable and disable the color array, call @code{glEnableClientState}
and @code{glDisableClientState} with the argument @code{GL_COLOR_ARRAY}.
If enabled, the color array is used when @code{glDrawArrays},
@code{glMultiDrawArrays}, @code{glDrawElements},
@code{glMultiDrawElements}, @code{glDrawRangeElements}, or
@code{glArrayElement} is called.

@code{GL_INVALID_VALUE} is generated if @var{size} is not 3 or 4.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glColorSubTable target start count format type data
Respecify a portion of a color table.

@table @asis
@item @var{target}
Must be one of @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}.

@item @var{start}
The starting index of the portion of the color table to be replaced.

@item @var{count}
The number of table entries to replace.

@item @var{format}
The format of the pixel data in @var{data}.  The allowable values are
@code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_LUMINANCE}, @code{GL_LUMINANCE_ALPHA}, @code{GL_RGB},
@code{GL_BGR}, @code{GL_RGBA}, and @code{GL_BGRA}.

@item @var{type}
The type of the pixel data in @var{data}.  The allowable values are
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_UNSIGNED_SHORT},
@code{GL_SHORT}, @code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Pointer to a one-dimensional array of pixel data that is processed to
replace the specified region of the color table.

@end table

@code{glColorSubTable} is used to respecify a contiguous portion of a
color table previously defined using @code{glColorTable}.  The pixels
referenced by @var{data} replace the portion of the existing table from
indices @var{start} to @r{@var{start}+@var{count}-1}, inclusive.  This
region may not include any entries outside the range of the color table
as it was originally specified.  It is not an error to specify a
subtexture with width of 0, but such a specification has no effect.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
portion of a color table is respecified, @var{data} is treated as a byte
offset into the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if
@r{@var{start}+@var{count}>@var{width}}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glColorSubTable} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glColorTableParameterfv target pname params
@deftypefunx void glColorTableParameteriv target pname params
Set color lookup table parameters.

@table @asis
@item @var{target}
The target color table.  Must be @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}.

@item @var{pname}
The symbolic name of a texture color lookup table parameter.  Must be
one of @code{GL_COLOR_TABLE_SCALE} or @code{GL_COLOR_TABLE_BIAS}.

@item @var{params}
A pointer to an array where the values of the parameters are stored.

@end table

@code{glColorTableParameter} is used to specify the scale factors and
bias terms applied to color components when they are loaded into a color
table.  @var{target} indicates which color table the scale and bias
terms apply to; it must be set to @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}.

@var{pname} must be @code{GL_COLOR_TABLE_SCALE} to set the scale
factors.  In this case, @var{params} points to an array of four values,
which are the scale factors for red, green, blue, and alpha, in that
order.

@var{pname} must be @code{GL_COLOR_TABLE_BIAS} to set the bias terms.  In
this case, @var{params} points to an array of four values, which are the
bias terms for red, green, blue, and alpha, in that order.

The color tables themselves are specified by calling
@code{glColorTable}.

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not an acceptable value.

@code{GL_INVALID_OPERATION} is generated if @code{glColorTableParameter}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glColorTable target internalformat width format type data
Define a color lookup table.

@table @asis
@item @var{target}
Must be one of @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE},
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}, @code{GL_PROXY_COLOR_TABLE},
@code{GL_PROXY_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE}.

@item @var{internalformat}
The internal format of the color table.  The allowable values are
@code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8}, @code{GL_ALPHA12},
@code{GL_ALPHA16}, @code{GL_LUMINANCE}, @code{GL_LUMINANCE4},
@code{GL_LUMINANCE8}, @code{GL_LUMINANCE12}, @code{GL_LUMINANCE16},
@code{GL_LUMINANCE_ALPHA}, @code{GL_LUMINANCE4_ALPHA4},
@code{GL_LUMINANCE6_ALPHA2}, @code{GL_LUMINANCE8_ALPHA8},
@code{GL_LUMINANCE12_ALPHA4}, @code{GL_LUMINANCE12_ALPHA12},
@code{GL_LUMINANCE16_ALPHA16}, @code{GL_INTENSITY},
@code{GL_INTENSITY4}, @code{GL_INTENSITY8}, @code{GL_INTENSITY12},
@code{GL_INTENSITY16}, @code{GL_R3_G3_B2}, @code{GL_RGB},
@code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8}, @code{GL_RGB10},
@code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA}, @code{GL_RGBA2},
@code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8}, @code{GL_RGB10_A2},
@code{GL_RGBA12}, and @code{GL_RGBA16}.

@item @var{width}
The number of entries in the color lookup table specified by @var{data}.

@item @var{format}
The format of the pixel data in @var{data}.  The allowable values are
@code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_LUMINANCE}, @code{GL_LUMINANCE_ALPHA}, @code{GL_RGB},
@code{GL_BGR}, @code{GL_RGBA}, and @code{GL_BGRA}.

@item @var{type}
The type of the pixel data in @var{data}.  The allowable values are
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_UNSIGNED_SHORT},
@code{GL_SHORT}, @code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Pointer to a one-dimensional array of pixel data that is processed to
build the color table.

@end table

@code{glColorTable} may be used in two ways: to test the actual size and
color resolution of a lookup table given a particular set of parameters,
or to load the contents of a color lookup table.  Use the targets
@code{GL_PROXY_*} for the first case and the other targets for the
second case.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
color table is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

If @var{target} is @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}, @code{glColorTable} builds a
color lookup table from an array of pixels.  The pixel array specified
by @var{width}, @var{format}, @var{type}, and @var{data} is extracted
from memory and processed just as if @code{glDrawPixels} were called,
but processing stops after the final expansion to RGBA is completed.

The four scale parameters and the four bias parameters that are defined
for the table are then used to scale and bias the R, G, B, and A
components of each pixel.  (Use @code{glColorTableParameter} to set
these scale and bias parameters.)

Next, the R, G, B, and A values are clamped to the range @r{[0,1]}.  Each
pixel is then converted to the internal format specified by
@var{internalformat}.  This conversion simply maps the component values
of the pixel (R, G, B, and A) to the values included in the internal
format (red, green, blue, alpha, luminance, and intensity).  The mapping
is as follows:



@table @asis
@item @strong{Internal Format}
@strong{Red}, @strong{Green}, @strong{Blue}, @strong{Alpha},
@strong{Luminance}, @strong{Intensity}

@item @code{GL_ALPHA}
, , , A , ,

@item @code{GL_LUMINANCE}
, , , , R ,

@item @code{GL_LUMINANCE_ALPHA}
, , , A , R ,

@item @code{GL_INTENSITY}
, , , , , R

@item @code{GL_RGB}
R , G , B , , ,

@item @code{GL_RGBA}
R , G , B , A , ,

@end table

Finally, the red, green, blue, alpha, luminance, and/or intensity
components of the resulting pixels are stored in the color table.  They
form a one-dimensional table with indices in the range
@r{[0,@var{width}-1]}.

If @var{target} is @code{GL_PROXY_*}, @code{glColorTable} recomputes and
stores the values of the proxy color table's state variables
@code{GL_COLOR_TABLE_FORMAT}, @code{GL_COLOR_TABLE_WIDTH},
@code{GL_COLOR_TABLE_RED_SIZE}, @code{GL_COLOR_TABLE_GREEN_SIZE},
@code{GL_COLOR_TABLE_BLUE_SIZE}, @code{GL_COLOR_TABLE_ALPHA_SIZE},
@code{GL_COLOR_TABLE_LUMINANCE_SIZE}, and
@code{GL_COLOR_TABLE_INTENSITY_SIZE}.  There is no effect on the image
or state of any actual color table.  If the specified color table is too
large to be supported, then all the proxy state variables listed above
are set to zero.  Otherwise, the color table could be supported by
@code{glColorTable} using the corresponding non-proxy target, and the
proxy state variables are set as if that target were being defined.

The proxy state variables can be retrieved by calling
@code{glGetColorTableParameter} with a target of @code{GL_PROXY_*}.  This
allows the application to decide if a particular @code{glColorTable}
command would succeed, and to determine what the resulting color table
attributes would be.

If a color table is enabled, and its width is non-zero, then its
contents are used to replace a subset of the components of each RGBA
pixel group, based on the internal format of the table.

Each pixel group has color components (R, G, B, A) that are in the range
@r{[0.0,1.0]}.  The color components are rescaled to the size of the
color lookup table to form an index.  Then a subset of the components
based on the internal format of the table are replaced by the table
entry selected by that index.  If the color components and contents of
the table are represented as follows:



@table @asis
@item @strong{Representation}
@strong{Meaning}

@item @code{r}
Table index computed from @code{R}

@item @code{g}
Table index computed from @code{G}

@item @code{b}
Table index computed from @code{B}

@item @code{a}
Table index computed from @code{A}

@item @code{L[i]}
Luminance value at table index @code{i}

@item @code{I[i]}
Intensity value at table index @code{i}

@item @code{R[i]}
Red value at table index @code{i}

@item @code{G[i]}
Green value at table index @code{i}

@item @code{B[i]}
Blue value at table index @code{i}

@item @code{A[i]}
Alpha value at table index @code{i}

@end table

then the result of color table lookup is as follows:



@table @asis
@item @strong{}
@strong{Resulting Texture Components}

@item @strong{Table Internal Format}
@strong{R}, @strong{G}, @strong{B}, @strong{A}

@item @code{GL_ALPHA}
@code{R}, @code{G}, @code{B}, @code{A[a]}

@item @code{GL_LUMINANCE}
@code{L[r]}, @code{L[g]}, @code{L[b]}, @code{At}

@item @code{GL_LUMINANCE_ALPHA}
@code{L[r]}, @code{L[g]}, @code{L[b]}, @code{A[a]}

@item @code{GL_INTENSITY}
@code{I[r]}, @code{I[g]}, @code{I[b]}, @code{I[a]}

@item @code{GL_RGB}
@code{R[r]}, @code{G[g]}, @code{B[b]}, @code{A}

@item @code{GL_RGBA}
@code{R[r]}, @code{G[g]}, @code{B[b]}, @code{A[a]}

@end table

When @code{GL_COLOR_TABLE} is enabled, the colors resulting from the
pixel map operation (if it is enabled) are mapped by the color lookup
table before being passed to the convolution operation.  The colors
resulting from the convolution operation are modified by the post
convolution color lookup table when
@code{GL_POST_CONVOLUTION_COLOR_TABLE} is enabled.  These modified
colors are then sent to the color matrix operation.  Finally, if
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE} is enabled, the colors resulting
from the color matrix operation are mapped by the post color matrix
color lookup table before being used by the histogram operation.



@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero.

@code{GL_TABLE_TOO_LARGE} is generated if the requested color table is
too large to be supported by the implementation, and @var{target} is not
a @code{GL_PROXY_*} target.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glColorTable} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glColor3b red green blue
@deftypefunx void glColor3s red green blue
@deftypefunx void glColor3i red green blue
@deftypefunx void glColor3f red green blue
@deftypefunx void glColor3d red green blue
@deftypefunx void glColor3ub red green blue
@deftypefunx void glColor3us red green blue
@deftypefunx void glColor3ui red green blue
@deftypefunx void glColor4b red green blue alpha
@deftypefunx void glColor4s red green blue alpha
@deftypefunx void glColor4i red green blue alpha
@deftypefunx void glColor4f red green blue alpha
@deftypefunx void glColor4d red green blue alpha
@deftypefunx void glColor4ub red green blue alpha
@deftypefunx void glColor4us red green blue alpha
@deftypefunx void glColor4ui red green blue alpha
@deftypefunx void glColor3bv v
@deftypefunx void glColor3sv v
@deftypefunx void glColor3iv v
@deftypefunx void glColor3fv v
@deftypefunx void glColor3dv v
@deftypefunx void glColor3ubv v
@deftypefunx void glColor3usv v
@deftypefunx void glColor3uiv v
@deftypefunx void glColor4bv v
@deftypefunx void glColor4sv v
@deftypefunx void glColor4iv v
@deftypefunx void glColor4fv v
@deftypefunx void glColor4dv v
@deftypefunx void glColor4ubv v
@deftypefunx void glColor4usv v
@deftypefunx void glColor4uiv v
Set the current color.

@table @asis
@item @var{red}
@itemx @var{green}
@itemx @var{blue}
Specify new red, green, and blue values for the current color.

@item @var{alpha}
Specifies a new alpha value for the current color.  Included only in the
four-argument @code{glColor4} commands.

@end table

The GL stores both a current single-valued color index and a current
four-valued RGBA color.  @code{glColor} sets a new four-valued RGBA
color.  @code{glColor} has two major variants: @code{glColor3} and
@code{glColor4}.  @code{glColor3} variants specify new red, green, and
blue values explicitly and set the current alpha value to 1.0 (full
intensity) implicitly.  @code{glColor4} variants specify all four color
components explicitly.

@code{glColor3b}, @code{glColor4b}, @code{glColor3s}, @code{glColor4s},
@code{glColor3i}, and @code{glColor4i} take three or four signed byte,
short, or long integers as arguments.  When @strong{v} is appended to
the name, the color commands can take a pointer to an array of such
values.

Current color values are stored in floating-point format, with
unspecified mantissa and exponent sizes.  Unsigned integer color
components, when specified, are linearly mapped to floating-point values
such that the largest representable value maps to 1.0 (full intensity),
and 0 maps to 0.0 (zero intensity).  Signed integer color components,
when specified, are linearly mapped to floating-point values such that
the most positive representable value maps to 1.0, and the most negative
representable value maps to @r{-1.0}.  (Note that this mapping does not
convert 0 precisely to 0.0.) Floating-point values are mapped directly.

Neither floating-point nor signed integer values are clamped to the
range @r{[0,1]} before the current color is updated.  However, color
components are clamped to this range before they are interpolated or
written into a color buffer.

@end deftypefun

@deftypefun void glCompileShader shader
Compiles a shader object.

@table @asis
@item @var{shader}
Specifies the shader object to be compiled.

@end table

@code{glCompileShader} compiles the source code strings that have been
stored in the shader object specified by @var{shader}.

The compilation status will be stored as part of the shader object's
state.  This value will be set to @code{GL_TRUE} if the shader was
compiled without errors and is ready for use, and @code{GL_FALSE}
otherwise.  It can be queried by calling @code{glGetShader} with
arguments @var{shader} and @code{GL_COMPILE_STATUS}.

Compilation of a shader can fail for a number of reasons as specified by
the OpenGL Shading Language Specification.  Whether or not the
compilation was successful, information about the compilation can be
obtained from the shader object's information log by calling
@code{glGetShaderInfoLog}.

@code{GL_INVALID_VALUE} is generated if @var{shader} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is not a shader
object.

@code{GL_INVALID_OPERATION} is generated if @code{glCompileShader} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCompressedTexImage1D target level internalformat width border imageSize data
Specify a one-dimensional texture image in a compressed format.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_1D} or
@code{GL_PROXY_TEXTURE_1D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{internalformat}
Specifies the format of the compressed image data stored at address
@var{data}.

@item @var{width}
Specifies the width of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  All
implementations support texture images that are at least 64 texels wide.
The height of the 1D texture image is 1.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@item @var{imageSize}
Specifies the number of unsigned bytes of image data starting at the
address specified by @var{data}.

@item @var{data}
Specifies a pointer to the compressed image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable one-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_1D}.

@code{glCompressedTexImage1D} loads a previously defined, and retrieved,
compressed one-dimensional texture image if @var{target} is
@code{GL_TEXTURE_1D} (see @code{glTexImage1D}).

If @var{target} is @code{GL_PROXY_TEXTURE_1D}, no data is read from
@var{data}, but all of the texture image state is recalculated, checked
for consistency, and checked against the implementation's capabilities.
If the implementation cannot handle a texture of the requested texture
size, it sets all of the image state to 0, but does not generate an
error (see @code{glGetError}).  To query for an entire mipmap array, use
an image array level greater than or equal to 1.

@var{internalformat} must be extension-specified compressed-texture
format.  When a texture is loaded with @code{glTexImage1D} using a
generic compressed texture format (e.g., @code{GL_COMPRESSED_RGB}) the
GL selects from one of its extensions supporting compressed textures.  In
order to load the compressed texture image using
@code{glCompressedTexImage1D}, query the compressed texture image's size
and format using @code{glGetTexLevelParameter}.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is one of
the generic compressed internal formats: @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB}, or
@code{GL_COMPRESSED_RGBA}.

@code{GL_INVALID_VALUE} is generated if @var{imageSize} is not
consistent with the format, dimensions, and contents of the specified
compressed image data.

@code{GL_INVALID_OPERATION} is generated if parameter combinations are
not supported by the specific compressed internal format as specified in
the specific texture compression extension.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if
@code{glCompressedTexImage1D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

Undefined results, including abnormal program termination, are generated
if @var{data} is not encoded in a manner consistent with the extension
specification defining the internal compression format.

@end deftypefun

@deftypefun void glCompressedTexImage2D target level internalformat width height border imageSize data
Specify a two-dimensional texture image in a compressed format.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_2D},
@code{GL_PROXY_TEXTURE_2D}, @code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or
@code{GL_PROXY_TEXTURE_CUBE_MAP}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{internalformat}
Specifies the format of the compressed image data stored at address
@var{data}.

@item @var{width}
Specifies the width of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  All
implementations support 2D texture images that are at least 64 texels
wide and cube-mapped texture images that are at least 16 texels wide.

@item @var{height}
Specifies the height of the texture image including the border if any.
If the GL version does not support non-power-of-two sizes, this value
must be Must be @r{2^@var{n}+2⁡(@var{border},)} for some integer
@r{@var{n}}.  All implementations support 2D texture images that are at
least 64 texels high and cube-mapped texture images that are at least 16
texels high.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@item @var{imageSize}
Specifies the number of unsigned bytes of image data starting at the
address specified by @var{data}.

@item @var{data}
Specifies a pointer to the compressed image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable two-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_2D}.  To enable and
disable texturing using cube-mapped textures, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_CUBE_MAP}.

@code{glCompressedTexImage2D} loads a previously defined, and retrieved,
compressed two-dimensional texture image if @var{target} is
@code{GL_TEXTURE_2D} (see @code{glTexImage2D}).

If @var{target} is @code{GL_PROXY_TEXTURE_2D}, no data is read from
@var{data}, but all of the texture image state is recalculated, checked
for consistency, and checked against the implementation's capabilities.
If the implementation cannot handle a texture of the requested texture
size, it sets all of the image state to 0, but does not generate an
error (see @code{glGetError}).  To query for an entire mipmap array, use
an image array level greater than or equal to 1.

@var{internalformat} must be an extension-specified compressed-texture
format.  When a texture is loaded with @code{glTexImage2D} using a
generic compressed texture format (e.g., @code{GL_COMPRESSED_RGB}), the
GL selects from one of its extensions supporting compressed textures.  In
order to load the compressed texture image using
@code{glCompressedTexImage2D}, query the compressed texture image's size
and format using @code{glGetTexLevelParameter}.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is one of
the generic compressed internal formats: @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB}, or
@code{GL_COMPRESSED_RGBA}.

@code{GL_INVALID_VALUE} is generated if @var{imageSize} is not
consistent with the format, dimensions, and contents of the specified
compressed image data.

@code{GL_INVALID_OPERATION} is generated if parameter combinations are
not supported by the specific compressed internal format as specified in
the specific texture compression extension.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if
@code{glCompressedTexImage2D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

Undefined results, including abnormal program termination, are generated
if @var{data} is not encoded in a manner consistent with the extension
specification defining the internal compression format.

@end deftypefun

@deftypefun void glCompressedTexImage3D target level internalformat width height depth border imageSize data
Specify a three-dimensional texture image in a compressed format.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_3D} or
@code{GL_PROXY_TEXTURE_3D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{internalformat}
Specifies the format of the compressed image data stored at address
@var{data}.

@item @var{width}
Specifies the width of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  All
implementations support 3D texture images that are at least 16 texels
wide.

@item @var{height}
Specifies the height of the texture image including the border if any.
If the GL version does not support non-power-of-two sizes, this value
must be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.
All implementations support 3D texture images that are at least 16
texels high.

@item @var{depth}
Specifies the depth of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  All
implementations support 3D texture images that are at least 16 texels
deep.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@item @var{imageSize}
Specifies the number of unsigned bytes of image data starting at the
address specified by @var{data}.

@item @var{data}
Specifies a pointer to the compressed image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable three-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_3D}.

@code{glCompressedTexImage3D} loads a previously defined, and retrieved,
compressed three-dimensional texture image if @var{target} is
@code{GL_TEXTURE_3D} (see @code{glTexImage3D}).

If @var{target} is @code{GL_PROXY_TEXTURE_3D}, no data is read from
@var{data}, but all of the texture image state is recalculated, checked
for consistency, and checked against the implementation's capabilities.
If the implementation cannot handle a texture of the requested texture
size, it sets all of the image state to 0, but does not generate an
error (see @code{glGetError}).  To query for an entire mipmap array, use
an image array level greater than or equal to 1.

@var{internalformat} must be an extension-specified compressed-texture
format.  When a texture is loaded with @code{glTexImage2D} using a
generic compressed texture format (e.g., @code{GL_COMPRESSED_RGB}), the
GL selects from one of its extensions supporting compressed textures.  In
order to load the compressed texture image using
@code{glCompressedTexImage3D}, query the compressed texture image's size
and format using @code{glGetTexLevelParameter}.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is one of
the generic compressed internal formats: @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB}, or
@code{GL_COMPRESSED_RGBA}.

@code{GL_INVALID_VALUE} is generated if @var{imageSize} is not
consistent with the format, dimensions, and contents of the specified
compressed image data.

@code{GL_INVALID_OPERATION} is generated if parameter combinations are
not supported by the specific compressed internal format as specified in
the specific texture compression extension.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if
@code{glCompressedTexImage3D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

Undefined results, including abnormal program termination, are generated
if @var{data} is not encoded in a manner consistent with the extension
specification defining the internal compression format.

@end deftypefun

@deftypefun void glCompressedTexSubImage1D target level xoffset width format imageSize data
Specify a one-dimensional texture subimage in a compressed format.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_1D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{format}
Specifies the format of the compressed image data stored at address
@var{data}.

@item @var{imageSize}
Specifies the number of unsigned bytes of image data starting at the
address specified by @var{data}.

@item @var{data}
Specifies a pointer to the compressed image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable one-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_1D}.

@code{glCompressedTexSubImage1D} redefines a contiguous subregion of an
existing one-dimensional texture image.  The texels referenced by
@var{data} replace the portion of the existing texture array with x
indices @var{xoffset} and @r{@var{xoffset}+@var{width}-1}, inclusive.
This region may not include any texels outside the range of the texture
array as it was originally specified.  It is not an error to specify a
subtexture with width of 0, but such a specification has no effect.

@var{format} must be an extension-specified compressed-texture format.
The @var{format} of the compressed texture image is selected by the GL
implementation that compressed it (see @code{glTexImage1D}), and should
be queried at the time the texture was compressed with
@code{glGetTexLevelParameter}.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{format} is one of these
generic compressed internal formats: @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB},
@code{GL_COMPRESSED_RGBA}, @code{GL_COMPRESSED_SLUMINANCE},
@code{GL_COMPRESSED_SLUMINANCE_ALPHA}, @code{GL_COMPRESSED_SRGB},
@code{GL_COMPRESSED_SRGBA}, or @code{GL_COMPRESSED_SRGB_ALPHA}.

@code{GL_INVALID_VALUE} is generated if @var{imageSize} is not
consistent with the format, dimensions, and contents of the specified
compressed image data.

@code{GL_INVALID_OPERATION} is generated if parameter combinations are
not supported by the specific compressed internal format as specified in
the specific texture compression extension.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if
@code{glCompressedTexSubImage1D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

Undefined results, including abnormal program termination, are generated
if @var{data} is not encoded in a manner consistent with the extension
specification defining the internal compression format.

@end deftypefun

@deftypefun void glCompressedTexSubImage2D target level xoffset yoffset width height format imageSize data
Specify a two-dimensional texture subimage in a compressed format.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_2D},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{yoffset}
Specifies a texel offset in the y direction within the texture array.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{height}
Specifies the height of the texture subimage.

@item @var{format}
Specifies the format of the compressed image data stored at address
@var{data}.

@item @var{imageSize}
Specifies the number of unsigned bytes of image data starting at the
address specified by @var{data}.

@item @var{data}
Specifies a pointer to the compressed image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable two-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_2D}.  To enable and
disable texturing using cube-mapped texture, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_CUBE_MAP}.

@code{glCompressedTexSubImage2D} redefines a contiguous subregion of an
existing two-dimensional texture image.  The texels referenced by
@var{data} replace the portion of the existing texture array with x
indices @var{xoffset} and @r{@var{xoffset}+@var{width}-1}, and the y
indices @var{yoffset} and @r{@var{yoffset}+@var{height}-1}, inclusive.
This region may not include any texels outside the range of the texture
array as it was originally specified.  It is not an error to specify a
subtexture with width of 0, but such a specification has no effect.

@var{format} must be an extension-specified compressed-texture format.
The @var{format} of the compressed texture image is selected by the GL
implementation that compressed it (see @code{glTexImage2D}) and should
be queried at the time the texture was compressed with
@code{glGetTexLevelParameter}.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{format} is one of these
generic compressed internal formats: @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB},
@code{GL_COMPRESSED_RGBA}, @code{GL_COMPRESSED_SLUMINANCE},
@code{GL_COMPRESSED_SLUMINANCE_ALPHA}, @code{GL_COMPRESSED_SRGB},
@code{GL_COMPRESSED_SRGBA}, or @code{GL_COMPRESSED_SRGB_ALPHA}.

@code{GL_INVALID_VALUE} is generated if @var{imageSize} is not
consistent with the format, dimensions, and contents of the specified
compressed image data.

@code{GL_INVALID_OPERATION} is generated if parameter combinations are
not supported by the specific compressed internal format as specified in
the specific texture compression extension.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if
@code{glCompressedTexSubImage2D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

Undefined results, including abnormal program termination, are generated
if @var{data} is not encoded in a manner consistent with the extension
specification defining the internal compression format.

@end deftypefun

@deftypefun void glCompressedTexSubImage3D target level xoffset yoffset zoffset width height depth format imageSize data
Specify a three-dimensional texture subimage in a compressed format.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_3D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{yoffset}
Specifies a texel offset in the y direction within the texture array.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{height}
Specifies the height of the texture subimage.

@item @var{depth}
Specifies the depth of the texture subimage.

@item @var{format}
Specifies the format of the compressed image data stored at address
@var{data}.

@item @var{imageSize}
Specifies the number of unsigned bytes of image data starting at the
address specified by @var{data}.

@item @var{data}
Specifies a pointer to the compressed image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable three-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_3D}.

@code{glCompressedTexSubImage3D} redefines a contiguous subregion of an
existing three-dimensional texture image.  The texels referenced by
@var{data} replace the portion of the existing texture array with x
indices @var{xoffset} and @r{@var{xoffset}+@var{width}-1}, and the y
indices @var{yoffset} and @r{@var{yoffset}+@var{height}-1}, and the z
indices @var{zoffset} and @r{@var{zoffset}+@var{depth}-1}, inclusive.
This region may not include any texels outside the range of the texture
array as it was originally specified.  It is not an error to specify a
subtexture with width of 0, but such a specification has no effect.

@var{format} must be an extension-specified compressed-texture format.
The @var{format} of the compressed texture image is selected by the GL
implementation that compressed it (see @code{glTexImage3D}) and should
be queried at the time the texture was compressed with
@code{glGetTexLevelParameter}.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{format} is one of these
generic compressed internal formats: @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB},
@code{GL_COMPRESSED_RGBA}, @code{GL_COMPRESSED_SLUMINANCE},
@code{GL_COMPRESSED_SLUMINANCE_ALPHA}, @code{GL_COMPRESSED_SRGB},
@code{GL_COMPRESSED_SRGBA}, or @code{GL_COMPRESSED_SRGB_ALPHA}.

@code{GL_INVALID_VALUE} is generated if @var{imageSize} is not
consistent with the format, dimensions, and contents of the specified
compressed image data.

@code{GL_INVALID_OPERATION} is generated if parameter combinations are
not supported by the specific compressed internal format as specified in
the specific texture compression extension.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if
@code{glCompressedTexSubImage3D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

Undefined results, including abnormal program termination, are generated
if @var{data} is not encoded in a manner consistent with the extension
specification defining the internal compression format.

@end deftypefun

@deftypefun void glConvolutionFilter1D target internalformat width format type data
Define a one-dimensional convolution filter.

@table @asis
@item @var{target}
Must be @code{GL_CONVOLUTION_1D}.

@item @var{internalformat}
The internal format of the convolution filter kernel.  The allowable
values are @code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8},
@code{GL_ALPHA12}, @code{GL_ALPHA16}, @code{GL_LUMINANCE},
@code{GL_LUMINANCE4}, @code{GL_LUMINANCE8}, @code{GL_LUMINANCE12},
@code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_R3_G3_B2},
@code{GL_RGB}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{width}
The width of the pixel array referenced by @var{data}.

@item @var{format}
The format of the pixel data in @var{data}.  The allowable values are
@code{GL_ALPHA}, @code{GL_LUMINANCE}, @code{GL_LUMINANCE_ALPHA},
@code{GL_INTENSITY}, @code{GL_RGB}, and @code{GL_RGBA}.

@item @var{type}
The type of the pixel data in @var{data}.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{data}
Pointer to a one-dimensional array of pixel data that is processed to
build the convolution filter kernel.

@end table

@code{glConvolutionFilter1D} builds a one-dimensional convolution filter
kernel from an array of pixels.

The pixel array specified by @var{width}, @var{format}, @var{type}, and
@var{data} is extracted from memory and processed just as if
@code{glDrawPixels} were called, but processing stops after the final
expansion to RGBA is completed.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
convolution filter is specified, @var{data} is treated as a byte offset
into the buffer object's data store.

The R, G, B, and A components of each pixel are next scaled by the four
1D @code{GL_CONVOLUTION_FILTER_SCALE} parameters and biased by the four
1D @code{GL_CONVOLUTION_FILTER_BIAS} parameters.  (The scale and bias
parameters are set by @code{glConvolutionParameter} using the
@code{GL_CONVOLUTION_1D} target and the names
@code{GL_CONVOLUTION_FILTER_SCALE} and
@code{GL_CONVOLUTION_FILTER_BIAS}.  The parameters themselves are
vectors of four values that are applied to red, green, blue, and alpha,
in that order.) The R, G, B, and A values are not clamped to [0,1] at
any time during this process.

Each pixel is then converted to the internal format specified by
@var{internalformat}.  This conversion simply maps the component values
of the pixel (R, G, B, and A) to the values included in the internal
format (red, green, blue, alpha, luminance, and intensity).  The mapping
is as follows:



@table @asis
@item @strong{Internal Format}
@strong{Red}, @strong{Green}, @strong{Blue}, @strong{Alpha},
@strong{Luminance}, @strong{Intensity}

@item @code{GL_ALPHA}
, , , A , ,

@item @code{GL_LUMINANCE}
, , , , R ,

@item @code{GL_LUMINANCE_ALPHA}
, , , A , R ,

@item @code{GL_INTENSITY}
, , , , , R

@item @code{GL_RGB}
R , G , B , , ,

@item @code{GL_RGBA}
R , G , B , A , ,

@end table

The red, green, blue, alpha, luminance, and/or intensity components of
the resulting pixels are stored in floating-point rather than integer
format.  They form a one-dimensional filter kernel image indexed with
coordinate @var{i} such that @var{i} starts at 0 and increases from left
to right.  Kernel location @var{i} is derived from the @var{i}th pixel,
counting from 0.

Note that after a convolution is performed, the resulting color
components are also scaled by their corresponding
@code{GL_POST_CONVOLUTION_c_SCALE} parameters and biased by their
corresponding @code{GL_POST_CONVOLUTION_c_BIAS} parameters (where
@var{c} takes on the values @strong{RED}, @strong{GREEN}, @strong{BLUE},
and @strong{ALPHA}).  These parameters are set by
@code{glPixelTransfer}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_CONVOLUTION_1D}.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero or
greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_CONVOLUTION_1D} and name @code{GL_MAX_CONVOLUTION_WIDTH}.

@code{GL_INVALID_OPERATION} is generated if @var{format} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{type} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{format} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{type} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glConvolutionFilter1D}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glConvolutionFilter2D target internalformat width height format type data
Define a two-dimensional convolution filter.

@table @asis
@item @var{target}
Must be @code{GL_CONVOLUTION_2D}.

@item @var{internalformat}
The internal format of the convolution filter kernel.  The allowable
values are @code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8},
@code{GL_ALPHA12}, @code{GL_ALPHA16}, @code{GL_LUMINANCE},
@code{GL_LUMINANCE4}, @code{GL_LUMINANCE8}, @code{GL_LUMINANCE12},
@code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_R3_G3_B2},
@code{GL_RGB}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{width}
The width of the pixel array referenced by @var{data}.

@item @var{height}
The height of the pixel array referenced by @var{data}.

@item @var{format}
The format of the pixel data in @var{data}.  The allowable values are
@code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_RGB}, @code{GL_BGR}, @code{GL_RGBA}, @code{GL_BGRA},
@code{GL_LUMINANCE}, and @code{GL_LUMINANCE_ALPHA}.

@item @var{type}
The type of the pixel data in @var{data}.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{data}
Pointer to a two-dimensional array of pixel data that is processed to
build the convolution filter kernel.

@end table

@code{glConvolutionFilter2D} builds a two-dimensional convolution filter
kernel from an array of pixels.

The pixel array specified by @var{width}, @var{height}, @var{format},
@var{type}, and @var{data} is extracted from memory and processed just
as if @code{glDrawPixels} were called, but processing stops after the
final expansion to RGBA is completed.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
convolution filter is specified, @var{data} is treated as a byte offset
into the buffer object's data store.

The R, G, B, and A components of each pixel are next scaled by the four
2D @code{GL_CONVOLUTION_FILTER_SCALE} parameters and biased by the four
2D @code{GL_CONVOLUTION_FILTER_BIAS} parameters.  (The scale and bias
parameters are set by @code{glConvolutionParameter} using the
@code{GL_CONVOLUTION_2D} target and the names
@code{GL_CONVOLUTION_FILTER_SCALE} and
@code{GL_CONVOLUTION_FILTER_BIAS}.  The parameters themselves are
vectors of four values that are applied to red, green, blue, and alpha,
in that order.) The R, G, B, and A values are not clamped to [0,1] at
any time during this process.

Each pixel is then converted to the internal format specified by
@var{internalformat}.  This conversion simply maps the component values
of the pixel (R, G, B, and A) to the values included in the internal
format (red, green, blue, alpha, luminance, and intensity).  The mapping
is as follows:



@table @asis
@item @strong{Internal Format}
@strong{Red}, @strong{Green}, @strong{Blue}, @strong{Alpha},
@strong{Luminance}, @strong{Intensity}

@item @code{GL_ALPHA}
, , , A , ,

@item @code{GL_LUMINANCE}
, , , , R ,

@item @code{GL_LUMINANCE_ALPHA}
, , , A , R ,

@item @code{GL_INTENSITY}
, , , , , R

@item @code{GL_RGB}
R , G , B , , ,

@item @code{GL_RGBA}
R , G , B , A , ,

@end table

The red, green, blue, alpha, luminance, and/or intensity components of
the resulting pixels are stored in floating-point rather than integer
format.  They form a two-dimensional filter kernel image indexed with
coordinates @var{i} and @var{j} such that @var{i} starts at zero and
increases from left to right, and @var{j} starts at zero and increases
from bottom to top.  Kernel location @var{i,j} is derived from the
@var{N}th pixel, where @var{N} is @var{i}+@var{j}*@var{width}.

Note that after a convolution is performed, the resulting color
components are also scaled by their corresponding
@code{GL_POST_CONVOLUTION_c_SCALE} parameters and biased by their
corresponding @code{GL_POST_CONVOLUTION_c_BIAS} parameters (where
@var{c} takes on the values @strong{RED}, @strong{GREEN}, @strong{BLUE},
and @strong{ALPHA}).  These parameters are set by
@code{glPixelTransfer}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_CONVOLUTION_2D}.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero or
greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_CONVOLUTION_2D} and name @code{GL_MAX_CONVOLUTION_WIDTH}.

@code{GL_INVALID_VALUE} is generated if @var{height} is less than zero
or greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_CONVOLUTION_2D} and name @code{GL_MAX_CONVOLUTION_HEIGHT}.

@code{GL_INVALID_OPERATION} is generated if @var{height} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{height} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glConvolutionFilter2D}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glConvolutionParameterf target pname params
@deftypefunx void glConvolutionParameteri target pname params
@deftypefunx void glConvolutionParameterfv target pname params
@deftypefunx void glConvolutionParameteriv target pname params
Set convolution parameters.

@table @asis
@item @var{target}
The target for the convolution parameter.  Must be one of
@code{GL_CONVOLUTION_1D}, @code{GL_CONVOLUTION_2D}, or
@code{GL_SEPARABLE_2D}.

@item @var{pname}
The parameter to be set.  Must be @code{GL_CONVOLUTION_BORDER_MODE}.

@item @var{params}
The parameter value.  Must be one of @code{GL_REDUCE},
@code{GL_CONSTANT_BORDER}, @code{GL_REPLICATE_BORDER}.



@end table

@code{glConvolutionParameter} sets the value of a convolution parameter.

@var{target} selects the convolution filter to be affected:
@code{GL_CONVOLUTION_1D}, @code{GL_CONVOLUTION_2D}, or
@code{GL_SEPARABLE_2D} for the 1D, 2D, or separable 2D filter,
respectively.

@var{pname} selects the parameter to be changed.
@code{GL_CONVOLUTION_FILTER_SCALE} and @code{GL_CONVOLUTION_FILTER_BIAS}
affect the definition of the convolution filter kernel; see
@code{glConvolutionFilter1D}, @code{glConvolutionFilter2D}, and
@code{glSeparableFilter2D} for details.  In these cases, @var{params}v
is an array of four values to be applied to red, green, blue, and alpha
values, respectively.  The initial value for
@code{GL_CONVOLUTION_FILTER_SCALE} is (1, 1, 1, 1), and the initial
value for @code{GL_CONVOLUTION_FILTER_BIAS} is (0, 0, 0, 0).

A @var{pname} value of @code{GL_CONVOLUTION_BORDER_MODE} controls the
convolution border mode.  The accepted modes are:

@table @asis
@item @code{GL_REDUCE}
The image resulting from convolution is smaller than the source image.
If the filter width is @r{@var{Wf}} and height is @r{@var{Hf}}, and the
source image width is @r{@var{Ws}} and height is @r{@var{Hs}}, then the
convolved image width will be @r{@var{Ws}-@var{Wf}+1} and height will be
@r{@var{Hs}-@var{Hf}+1}.  (If this reduction would generate an image
with zero or negative width and/or height, the output is simply null,
with no error generated.) The coordinates of the image resulting from
convolution are zero through @r{@var{Ws}-@var{Wf}} in width and zero
through @r{@var{Hs}-@var{Hf}} in height.

@item @code{GL_CONSTANT_BORDER}
The image resulting from convolution is the same size as the source
image, and processed as if the source image were surrounded by pixels
with their color specified by the @code{GL_CONVOLUTION_BORDER_COLOR}.

@item @code{GL_REPLICATE_BORDER}
The image resulting from convolution is the same size as the source
image, and processed as if the outermost pixel on the border of the
source image were replicated.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{pname} is
@code{GL_CONVOLUTION_BORDER_MODE} and @var{params} is not one of
@code{GL_REDUCE}, @code{GL_CONSTANT_BORDER}, or
@code{GL_REPLICATE_BORDER}.

@code{GL_INVALID_OPERATION} is generated if
@code{glConvolutionParameter} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCopyColorSubTable target start x y width
Respecify a portion of a color table.

@table @asis
@item @var{target}
Must be one of @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}.

@item @var{start}
The starting index of the portion of the color table to be replaced.

@item @var{x}
@itemx @var{y}
The window coordinates of the left corner of the row of pixels to be
copied.

@item @var{width}
The number of table entries to replace.

@end table

@code{glCopyColorSubTable} is used to respecify a contiguous portion of
a color table previously defined using @code{glColorTable}.  The pixels
copied from the framebuffer replace the portion of the existing table
from indices @var{start} to @r{@var{start}+@var{x}-1}, inclusive.  This
region may not include any entries outside the range of the color table,
as was originally specified.  It is not an error to specify a subtexture
with width of 0, but such a specification has no effect.

@code{GL_INVALID_VALUE} is generated if @var{target} is not a previously
defined color table.

@code{GL_INVALID_VALUE} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if
@r{@var{start}+@var{x}>@var{width}}.

@code{GL_INVALID_OPERATION} is generated if @code{glCopyColorSubTable}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCopyColorTable target internalformat x y width
Copy pixels into a color table.

@table @asis
@item @var{target}
The color table target.  Must be @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}.

@item @var{internalformat}
The internal storage format of the texture image.  Must be one of the
following symbolic constants: @code{GL_ALPHA}, @code{GL_ALPHA4},
@code{GL_ALPHA8}, @code{GL_ALPHA12}, @code{GL_ALPHA16},
@code{GL_LUMINANCE}, @code{GL_LUMINANCE4}, @code{GL_LUMINANCE8},
@code{GL_LUMINANCE12}, @code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_R3_G3_B2},
@code{GL_RGB}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{x}
The x coordinate of the lower-left corner of the pixel rectangle to be
transferred to the color table.

@item @var{y}
The y coordinate of the lower-left corner of the pixel rectangle to be
transferred to the color table.

@item @var{width}
The width of the pixel rectangle.

@end table

@code{glCopyColorTable} loads a color table with pixels from the current
@code{GL_READ_BUFFER} (rather than from main memory, as is the case for
@code{glColorTable}).

The screen-aligned pixel rectangle with lower-left corner at (@var{x},\
@var{y}) having width @var{width} and height 1 is loaded into the color
table.  If any pixels within this region are outside the window that is
associated with the GL context, the values obtained for those pixels are
undefined.

The pixels in the rectangle are processed just as if @code{glReadPixels}
were called, with @var{internalformat} set to RGBA, but processing stops
after the final conversion to RGBA.

The four scale parameters and the four bias parameters that are defined
for the table are then used to scale and bias the R, G, B, and A
components of each pixel.  The scale and bias parameters are set by
calling @code{glColorTableParameter}.

Next, the R, G, B, and A values are clamped to the range @r{[0,1]}.  Each
pixel is then converted to the internal format specified by
@var{internalformat}.  This conversion simply maps the component values
of the pixel (R, G, B, and A) to the values included in the internal
format (red, green, blue, alpha, luminance, and intensity).  The mapping
is as follows:



@table @asis
@item @strong{Internal Format}
@strong{Red}, @strong{Green}, @strong{Blue}, @strong{Alpha},
@strong{Luminance}, @strong{Intensity}

@item @code{GL_ALPHA}
, , , A , ,

@item @code{GL_LUMINANCE}
, , , , R ,

@item @code{GL_LUMINANCE_ALPHA}
, , , A , R ,

@item @code{GL_INTENSITY}
, , , , , R

@item @code{GL_RGB}
R , G , B , , ,

@item @code{GL_RGBA}
R , G , B , A , ,

@end table

Finally, the red, green, blue, alpha, luminance, and/or intensity
components of the resulting pixels are stored in the color table.  They
form a one-dimensional table with indices in the range
@r{[0,@var{width}-1]}.



@code{GL_INVALID_ENUM} is generated when @var{target} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero.

@code{GL_INVALID_VALUE} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_TABLE_TOO_LARGE} is generated if the requested color table is
too large to be supported by the implementation.

@code{GL_INVALID_OPERATION} is generated if @code{glCopyColorTable} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCopyConvolutionFilter1D target internalformat x y width
Copy pixels into a one-dimensional convolution filter.

@table @asis
@item @var{target}
Must be @code{GL_CONVOLUTION_1D}.

@item @var{internalformat}
The internal format of the convolution filter kernel.  The allowable
values are @code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8},
@code{GL_ALPHA12}, @code{GL_ALPHA16}, @code{GL_LUMINANCE},
@code{GL_LUMINANCE4}, @code{GL_LUMINANCE8}, @code{GL_LUMINANCE12},
@code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_R3_G3_B2},
@code{GL_RGB}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{x}
@itemx @var{y}
The window space coordinates of the lower-left coordinate of the pixel
array to copy.

@item @var{width}
The width of the pixel array to copy.

@end table

@code{glCopyConvolutionFilter1D} defines a one-dimensional convolution
filter kernel with pixels from the current @code{GL_READ_BUFFER} (rather
than from main memory, as is the case for @code{glConvolutionFilter1D}).

The screen-aligned pixel rectangle with lower-left corner at (@var{x},\
@var{y}), width @var{width} and height 1 is used to define the
convolution filter.  If any pixels within this region are outside the
window that is associated with the GL context, the values obtained for
those pixels are undefined.

The pixels in the rectangle are processed exactly as if
@code{glReadPixels} had been called with @var{format} set to RGBA, but
the process stops just before final conversion.  The R, G, B, and A
components of each pixel are next scaled by the four 1D
@code{GL_CONVOLUTION_FILTER_SCALE} parameters and biased by the four 1D
@code{GL_CONVOLUTION_FILTER_BIAS} parameters.  (The scale and bias
parameters are set by @code{glConvolutionParameter} using the
@code{GL_CONVOLUTION_1D} target and the names
@code{GL_CONVOLUTION_FILTER_SCALE} and
@code{GL_CONVOLUTION_FILTER_BIAS}.  The parameters themselves are
vectors of four values that are applied to red, green, blue, and alpha,
in that order.) The R, G, B, and A values are not clamped to [0,1] at
any time during this process.

Each pixel is then converted to the internal format specified by
@var{internalformat}.  This conversion simply maps the component values
of the pixel (R, G, B, and A) to the values included in the internal
format (red, green, blue, alpha, luminance, and intensity).  The mapping
is as follows:



@table @asis
@item @strong{Internal Format}
@strong{Red}, @strong{Green}, @strong{Blue}, @strong{Alpha},
@strong{Luminance}, @strong{Intensity}

@item @code{GL_ALPHA}
, , , A , ,

@item @code{GL_LUMINANCE}
, , , , R ,

@item @code{GL_LUMINANCE_ALPHA}
, , , A , R ,

@item @code{GL_INTENSITY}
, , , , , R

@item @code{GL_RGB}
R , G , B , , ,

@item @code{GL_RGBA}
R , G , B , A , ,

@end table

The red, green, blue, alpha, luminance, and/or intensity components of
the resulting pixels are stored in floating-point rather than integer
format.

Pixel ordering is such that lower x screen coordinates correspond to
lower @var{i} filter image coordinates.

Note that after a convolution is performed, the resulting color
components are also scaled by their corresponding
@code{GL_POST_CONVOLUTION_c_SCALE} parameters and biased by their
corresponding @code{GL_POST_CONVOLUTION_c_BIAS} parameters (where
@var{c} takes on the values @strong{RED}, @strong{GREEN}, @strong{BLUE},
and @strong{ALPHA}).  These parameters are set by
@code{glPixelTransfer}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_CONVOLUTION_1D}.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero or
greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_CONVOLUTION_1D} and name @code{GL_MAX_CONVOLUTION_WIDTH}.

@code{GL_INVALID_OPERATION} is generated if
@code{glCopyConvolutionFilter1D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCopyConvolutionFilter2D target internalformat x y width height
Copy pixels into a two-dimensional convolution filter.

@table @asis
@item @var{target}
Must be @code{GL_CONVOLUTION_2D}.

@item @var{internalformat}
The internal format of the convolution filter kernel.  The allowable
values are @code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8},
@code{GL_ALPHA12}, @code{GL_ALPHA16}, @code{GL_LUMINANCE},
@code{GL_LUMINANCE4}, @code{GL_LUMINANCE8}, @code{GL_LUMINANCE12},
@code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_R3_G3_B2},
@code{GL_RGB}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{x}
@itemx @var{y}
The window space coordinates of the lower-left coordinate of the pixel
array to copy.

@item @var{width}
The width of the pixel array to copy.

@item @var{height}
The height of the pixel array to copy.

@end table

@code{glCopyConvolutionFilter2D} defines a two-dimensional convolution
filter kernel with pixels from the current @code{GL_READ_BUFFER} (rather
than from main memory, as is the case for @code{glConvolutionFilter2D}).

The screen-aligned pixel rectangle with lower-left corner at (@var{x},\
@var{y}), width @var{width} and height @var{height} is used to define
the convolution filter.  If any pixels within this region are outside
the window that is associated with the GL context, the values obtained
for those pixels are undefined.

The pixels in the rectangle are processed exactly as if
@code{glReadPixels} had been called with @var{format} set to RGBA, but
the process stops just before final conversion.  The R, G, B, and A
components of each pixel are next scaled by the four 2D
@code{GL_CONVOLUTION_FILTER_SCALE} parameters and biased by the four 2D
@code{GL_CONVOLUTION_FILTER_BIAS} parameters.  (The scale and bias
parameters are set by @code{glConvolutionParameter} using the
@code{GL_CONVOLUTION_2D} target and the names
@code{GL_CONVOLUTION_FILTER_SCALE} and
@code{GL_CONVOLUTION_FILTER_BIAS}.  The parameters themselves are
vectors of four values that are applied to red, green, blue, and alpha,
in that order.) The R, G, B, and A values are not clamped to [0,1] at
any time during this process.

Each pixel is then converted to the internal format specified by
@var{internalformat}.  This conversion simply maps the component values
of the pixel (R, G, B, and A) to the values included in the internal
format (red, green, blue, alpha, luminance, and intensity).  The mapping
is as follows:



@table @asis
@item @strong{Internal Format}
@strong{Red}, @strong{Green}, @strong{Blue}, @strong{Alpha},
@strong{Luminance}, @strong{Intensity}

@item @code{GL_ALPHA}
, , , A , ,

@item @code{GL_LUMINANCE}
, , , , R ,

@item @code{GL_LUMINANCE_ALPHA}
, , , A , R ,

@item @code{GL_INTENSITY}
, , , , , R

@item @code{GL_RGB}
R , G , B , , ,

@item @code{GL_RGBA}
R , G , B , A , ,

@end table

The red, green, blue, alpha, luminance, and/or intensity components of
the resulting pixels are stored in floating-point rather than integer
format.

Pixel ordering is such that lower x screen coordinates correspond to
lower @var{i} filter image coordinates, and lower y screen coordinates
correspond to lower @var{j} filter image coordinates.

Note that after a convolution is performed, the resulting color
components are also scaled by their corresponding
@code{GL_POST_CONVOLUTION_c_SCALE} parameters and biased by their
corresponding @code{GL_POST_CONVOLUTION_c_BIAS} parameters (where
@var{c} takes on the values @strong{RED}, @strong{GREEN}, @strong{BLUE},
and @strong{ALPHA}).  These parameters are set by
@code{glPixelTransfer}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_CONVOLUTION_2D}.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero or
greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_CONVOLUTION_2D} and name @code{GL_MAX_CONVOLUTION_WIDTH}.

@code{GL_INVALID_VALUE} is generated if @var{height} is less than zero
or greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_CONVOLUTION_2D} and name @code{GL_MAX_CONVOLUTION_HEIGHT}.

@code{GL_INVALID_OPERATION} is generated if
@code{glCopyConvolutionFilter2D} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCopyPixels x y width height type
Copy pixels in the frame buffer.

@table @asis
@item @var{x}
@itemx @var{y}
Specify the window coordinates of the lower left corner of the
rectangular region of pixels to be copied.

@item @var{width}
@itemx @var{height}
Specify the dimensions of the rectangular region of pixels to be copied.
Both must be nonnegative.

@item @var{type}
Specifies whether color values, depth values, or stencil values are to
be copied.  Symbolic constants @code{GL_COLOR}, @code{GL_DEPTH}, and
@code{GL_STENCIL} are accepted.

@end table

@code{glCopyPixels} copies a screen-aligned rectangle of pixels from the
specified frame buffer location to a region relative to the current
raster position.  Its operation is well defined only if the entire pixel
source region is within the exposed portion of the window.  Results of
copies from outside the window, or from regions of the window that are
not exposed, are hardware dependent and undefined.

@var{x} and @var{y} specify the window coordinates of the lower left
corner of the rectangular region to be copied.  @var{width} and
@var{height} specify the dimensions of the rectangular region to be
copied.  Both @var{width} and @var{height} must not be negative.

Several parameters control the processing of the pixel data while it is
being copied.  These parameters are set with three commands:
@code{glPixelTransfer}, @code{glPixelMap}, and @code{glPixelZoom}.  This
reference page describes the effects on @code{glCopyPixels} of most, but
not all, of the parameters specified by these three commands.

@code{glCopyPixels} copies values from each pixel with the lower
left-hand corner at @r{(@var{x}+@var{i},@var{y}+@var{j})} for
@r{0<=@var{i}<@var{width}} and @r{0<=@var{j}<@var{height}}.  This pixel
is said to be the @r{@var{i}}th pixel in the @r{@var{j}}th row.  Pixels
are copied in row order from the lowest to the highest row, left to
right in each row.

@var{type} specifies whether color, depth, or stencil data is to be
copied.  The details of the transfer for each data type are as follows:

@table @asis
@item @code{GL_COLOR}
Indices or RGBA colors are read from the buffer currently specified as
the read source buffer (see @code{glReadBuffer}).  If the GL is in color
index mode, each index that is read from this buffer is converted to a
fixed-point format with an unspecified number of bits to the right of
the binary point.  Each index is then shifted left by
@code{GL_INDEX_SHIFT} bits, and added to @code{GL_INDEX_OFFSET}.  If
@code{GL_INDEX_SHIFT} is negative, the shift is to the right.  In either
case, zero bits fill otherwise unspecified bit locations in the result.
If @code{GL_MAP_COLOR} is true, the index is replaced with the value
that it references in lookup table @code{GL_PIXEL_MAP_I_TO_I}.  Whether
the lookup replacement of the index is done or not, the integer part of
the index is then ANDed with @r{2^@var{b}-1}, where @r{@var{b}} is the
number of bits in a color index buffer.

If the GL is in RGBA mode, the red, green, blue, and alpha components of
each pixel that is read are converted to an internal floating-point
format with unspecified precision.  The conversion maps the largest
representable component value to 1.0, and component value 0 to 0.0.  The
resulting floating-point color values are then multiplied by
@code{GL_c_SCALE} and added to @code{GL_c_BIAS}, where @var{c} is RED,
GREEN, BLUE, and ALPHA for the respective color components.  The results
are clamped to the range [0,1].  If @code{GL_MAP_COLOR} is true, each
color component is scaled by the size of lookup table
@code{GL_PIXEL_MAP_c_TO_c}, then replaced by the value that it
references in that table.  @var{c} is R, G, B, or A.

If the @code{ARB_imaging} extension is supported, the color values may
be additionally processed by color-table lookups, color-matrix
transformations, and convolution filters.

The GL then converts the resulting indices or RGBA colors to fragments
by attaching the current raster position @var{z} coordinate and texture
coordinates to each pixel, then assigning window coordinates
@r{(@var{x}_@var{r}+@var{i},@var{y}_@var{r}+@var{j})}, where
@r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster position,
and the pixel was the @r{@var{i}}th pixel in the @r{@var{j}}th row.
These pixel fragments are then treated just like the fragments generated
by rasterizing points, lines, or polygons.  Texture mapping, fog, and
all the fragment operations are applied before the fragments are written
to the frame buffer.

@item @code{GL_DEPTH}
Depth values are read from the depth buffer and converted directly to an
internal floating-point format with unspecified precision.  The
resulting floating-point depth value is then multiplied by
@code{GL_DEPTH_SCALE} and added to @code{GL_DEPTH_BIAS}.  The result is
clamped to the range [0,1].

The GL then converts the resulting depth components to fragments by
attaching the current raster position color or color index and texture
coordinates to each pixel, then assigning window coordinates
@r{(@var{x}_@var{r}+@var{i},@var{y}_@var{r}+@var{j})}, where
@r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster position,
and the pixel was the @r{@var{i}}th pixel in the @r{@var{j}}th row.
These pixel fragments are then treated just like the fragments generated
by rasterizing points, lines, or polygons.  Texture mapping, fog, and
all the fragment operations are applied before the fragments are written
to the frame buffer.

@item @code{GL_STENCIL}
Stencil indices are read from the stencil buffer and converted to an
internal fixed-point format with an unspecified number of bits to the
right of the binary point.  Each fixed-point index is then shifted left
by @code{GL_INDEX_SHIFT} bits, and added to @code{GL_INDEX_OFFSET}.  If
@code{GL_INDEX_SHIFT} is negative, the shift is to the right.  In either
case, zero bits fill otherwise unspecified bit locations in the result.
If @code{GL_MAP_STENCIL} is true, the index is replaced with the value
that it references in lookup table @code{GL_PIXEL_MAP_S_TO_S}.  Whether
the lookup replacement of the index is done or not, the integer part of
the index is then ANDed with @r{2^@var{b}-1}, where @r{@var{b}} is the
number of bits in the stencil buffer.  The resulting stencil indices are
then written to the stencil buffer such that the index read from the
@r{@var{i}}th location of the @r{@var{j}}th row is written to location
@r{(@var{x}_@var{r}+@var{i},@var{y}_@var{r}+@var{j})}, where
@r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster position.
Only the pixel ownership test, the scissor test, and the stencil
writemask affect these write operations.

@end table

The rasterization described thus far assumes pixel zoom factors of 1.0.
If @code{glPixelZoom} is used to change the @r{@var{x}} and @r{@var{y}}
pixel zoom factors, pixels are converted to fragments as follows.  If
@r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster position,
and a given pixel is in the @r{@var{i}}th location in the @r{@var{j}}th
row of the source pixel rectangle, then fragments are generated for
pixels whose centers are in the rectangle with corners at

@r{(@var{x}_@var{r}+@var{zoom}_@var{x},⁢@var{i},@var{y}_@var{r}+@var{zoom}_@var{y},⁢@var{j})}

and

@r{(@var{x}_@var{r}+@var{zoom}_@var{x},⁡(@var{i}+1,),@var{y}_@var{r}+@var{zoom}_@var{y},⁡(@var{j}+1,))}

where @r{@var{zoom}_@var{x}} is the value of @code{GL_ZOOM_X} and
@r{@var{zoom}_@var{y}} is the value of @code{GL_ZOOM_Y}.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if either @var{width} or
@var{height} is negative.

@code{GL_INVALID_OPERATION} is generated if @var{type} is
@code{GL_DEPTH} and there is no depth buffer.

@code{GL_INVALID_OPERATION} is generated if @var{type} is
@code{GL_STENCIL} and there is no stencil buffer.

@code{GL_INVALID_OPERATION} is generated if @code{glCopyPixels} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCopyTexImage1D target level internalformat x y width border
Copy pixels into a 1D texture image.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_1D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{internalformat}
Specifies the internal format of the texture.  Must be one of the
following symbolic constants: @code{GL_ALPHA}, @code{GL_ALPHA4},
@code{GL_ALPHA8}, @code{GL_ALPHA12}, @code{GL_ALPHA16},
@code{GL_COMPRESSED_ALPHA}, @code{GL_COMPRESSED_LUMINANCE},
@code{GL_COMPRESSED_LUMINANCE_ALPHA}, @code{GL_COMPRESSED_INTENSITY},
@code{GL_COMPRESSED_RGB}, @code{GL_COMPRESSED_RGBA},
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, @code{GL_DEPTH_COMPONENT32},
@code{GL_LUMINANCE}, @code{GL_LUMINANCE4}, @code{GL_LUMINANCE8},
@code{GL_LUMINANCE12}, @code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_RGB},
@code{GL_R3_G3_B2}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, @code{GL_RGBA16},
@code{GL_SLUMINANCE}, @code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
@code{GL_SLUMINANCE8_ALPHA8}, @code{GL_SRGB}, @code{GL_SRGB8},
@code{GL_SRGB_ALPHA}, or @code{GL_SRGB8_ALPHA8}.

@item @var{x}
@itemx @var{y}
Specify the window coordinates of the left corner of the row of pixels
to be copied.

@item @var{width}
Specifies the width of the texture image.  Must be 0 or
@r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  The
height of the texture image is 1.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@end table

@code{glCopyTexImage1D} defines a one-dimensional texture image with
pixels from the current @code{GL_READ_BUFFER}.

The screen-aligned pixel row with left corner at @r{(@var{x},@var{y})}
and with a length of @r{@var{width}+2⁡(@var{border},)} defines the
texture array at the mipmap level specified by @var{level}.
@var{internalformat} specifies the internal format of the texture array.

The pixels in the row are processed exactly as if @code{glCopyPixels}
had been called, but the process stops just before final conversion.  At
this point all pixel component values are clamped to the range @r{[0,1]}
and then converted to the texture's internal format for storage in the
texel array.

Pixel ordering is such that lower @r{@var{x}} screen coordinates
correspond to lower texture coordinates.

If any of the pixels within the specified row of the current
@code{GL_READ_BUFFER} are outside the window associated with the current
rendering context, then the values obtained for those pixels are
undefined.

@code{glCopyTexImage1D} defines a one-dimensional texture image with
pixels from the current @code{GL_READ_BUFFER}.

When @var{internalformat} is one of the sRGB types, the GL does not
automatically convert the source pixels to the sRGB color space.  In
this case, the @code{glPixelMap} function can be used to accomplish the
conversion.

@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2⁢@var{max}}, where @r{@var{max}} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @var{internalformat} is not an
allowable value.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than 0 or
greater than 2 + @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if non-power-of-two textures are
not supported and the @var{width} cannot be represented as
@r{2^@var{n}+2⁡(@var{border},)} for some integer value of @var{n}.

@code{GL_INVALID_VALUE} is generated if @var{border} is not 0 or 1.

@code{GL_INVALID_OPERATION} is generated if @code{glCopyTexImage1D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@code{GL_INVALID_OPERATION} is generated if @var{internalformat} is
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, or @code{GL_DEPTH_COMPONENT32} and there is
no depth buffer.

@end deftypefun

@deftypefun void glCopyTexImage2D target level internalformat x y width height border
Copy pixels into a 2D texture image.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_2D},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{internalformat}
Specifies the internal format of the texture.  Must be one of the
following symbolic constants: @code{GL_ALPHA}, @code{GL_ALPHA4},
@code{GL_ALPHA8}, @code{GL_ALPHA12}, @code{GL_ALPHA16},
@code{GL_COMPRESSED_ALPHA}, @code{GL_COMPRESSED_LUMINANCE},
@code{GL_COMPRESSED_LUMINANCE_ALPHA}, @code{GL_COMPRESSED_INTENSITY},
@code{GL_COMPRESSED_RGB}, @code{GL_COMPRESSED_RGBA},
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, @code{GL_DEPTH_COMPONENT32},
@code{GL_LUMINANCE}, @code{GL_LUMINANCE4}, @code{GL_LUMINANCE8},
@code{GL_LUMINANCE12}, @code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_RGB},
@code{GL_R3_G3_B2}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, @code{GL_RGBA16},
@code{GL_SLUMINANCE}, @code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
@code{GL_SLUMINANCE8_ALPHA8}, @code{GL_SRGB}, @code{GL_SRGB8},
@code{GL_SRGB_ALPHA}, or @code{GL_SRGB8_ALPHA8}.

@item @var{x}
@itemx @var{y}
Specify the window coordinates of the lower left corner of the
rectangular region of pixels to be copied.

@item @var{width}
Specifies the width of the texture image.  Must be 0 or
@r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.

@item @var{height}
Specifies the height of the texture image.  Must be 0 or
@r{2^@var{m}+2⁡(@var{border},)} for some integer @r{@var{m}}.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@end table

@code{glCopyTexImage2D} defines a two-dimensional texture image, or
cube-map texture image with pixels from the current
@code{GL_READ_BUFFER}.

The screen-aligned pixel rectangle with lower left corner at (@var{x},
@var{y}) and with a width of @r{@var{width}+2⁡(@var{border},)} and a
height of @r{@var{height}+2⁡(@var{border},)} defines the texture array
at the mipmap level specified by @var{level}.  @var{internalformat}
specifies the internal format of the texture array.

The pixels in the rectangle are processed exactly as if
@code{glCopyPixels} had been called, but the process stops just before
final conversion.  At this point all pixel component values are clamped
to the range @r{[0,1]} and then converted to the texture's internal
format for storage in the texel array.

Pixel ordering is such that lower @r{@var{x}} and @r{@var{y}} screen
coordinates correspond to lower @r{@var{s}} and @r{@var{t}} texture
coordinates.

If any of the pixels within the specified rectangle of the current
@code{GL_READ_BUFFER} are outside the window associated with the current
rendering context, then the values obtained for those pixels are
undefined.

When @var{internalformat} is one of the sRGB types, the GL does not
automatically convert the source pixels to the sRGB color space.  In
this case, the @code{glPixelMap} function can be used to accomplish the
conversion.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2⁢@var{max}}, where @r{@var{max}} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than 0 or
greater than 2 + @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if non-power-of-two textures are
not supported and the @var{width} or @var{depth} cannot be represented
as @r{2^@var{k}+2⁡(@var{border},)} for some integer @r{@var{k}}.

@code{GL_INVALID_VALUE} is generated if @var{border} is not 0 or 1.

@code{GL_INVALID_VALUE} is generated if @var{internalformat} is not an
accepted format.

@code{GL_INVALID_OPERATION} is generated if @code{glCopyTexImage2D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@code{GL_INVALID_OPERATION} is generated if @var{internalformat} is
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, or @code{GL_DEPTH_COMPONENT32} and there is
no depth buffer.

@end deftypefun

@deftypefun void glCopyTexSubImage1D target level xoffset x y width
Copy a one-dimensional texture subimage.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_1D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies the texel offset within the texture array.

@item @var{x}
@itemx @var{y}
Specify the window coordinates of the left corner of the row of pixels
to be copied.

@item @var{width}
Specifies the width of the texture subimage.

@end table

@code{glCopyTexSubImage1D} replaces a portion of a one-dimensional
texture image with pixels from the current @code{GL_READ_BUFFER} (rather
than from main memory, as is the case for @code{glTexSubImage1D}).

The screen-aligned pixel row with left corner at (@var{x},\ @var{y}),
and with length @var{width} replaces the portion of the texture array
with x indices @var{xoffset} through @r{@var{xoffset}+@var{width}-1},
inclusive.  The destination in the texture array may not include any
texels outside the texture array as it was originally specified.

The pixels in the row are processed exactly as if @code{glCopyPixels}
had been called, but the process stops just before final conversion.  At
this point, all pixel component values are clamped to the range
@r{[0,1]} and then converted to the texture's internal format for
storage in the texel array.

It is not an error to specify a subtexture with zero width, but such a
specification has no effect.  If any of the pixels within the specified
row of the current @code{GL_READ_BUFFER} are outside the read window
associated with the current rendering context, then the values obtained
for those pixels are undefined.

No change is made to the @var{internalformat}, @var{width}, or
@var{border} parameters of the specified texture array or to texel
values outside the specified subregion.

@code{GL_INVALID_ENUM} is generated if /@var{target} is not
@code{GL_TEXTURE_1D}.

@code{GL_INVALID_OPERATION} is generated if the texture array has not
been defined by a previous @code{glTexImage1D} or
@code{glCopyTexImage1D} operation.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if
@r{@var{level}>@var{log}_2⁡(@var{max},)}, where @var{max} is the
returned value of @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @r{@var{xoffset}<-@var{b}}, or
@r{(@var{xoffset}+@var{width},)>(@var{w}-@var{b},)}, where @r{@var{w}}
is the @code{GL_TEXTURE_WIDTH} and @r{@var{b}} is the
@code{GL_TEXTURE_BORDER} of the texture image being modified.  Note that
@r{@var{w}} includes twice the border width.



@end deftypefun

@deftypefun void glCopyTexSubImage2D target level xoffset yoffset x y width height
Copy a two-dimensional texture subimage.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_2D},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{yoffset}
Specifies a texel offset in the y direction within the texture array.

@item @var{x}
@itemx @var{y}
Specify the window coordinates of the lower left corner of the
rectangular region of pixels to be copied.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{height}
Specifies the height of the texture subimage.

@end table

@code{glCopyTexSubImage2D} replaces a rectangular portion of a
two-dimensional texture image or cube-map texture image with pixels from
the current @code{GL_READ_BUFFER} (rather than from main memory, as is
the case for @code{glTexSubImage2D}).

The screen-aligned pixel rectangle with lower left corner at
@r{(@var{x},@var{y})} and with width @var{width} and height @var{height}
replaces the portion of the texture array with x indices @var{xoffset}
through @r{@var{xoffset}+@var{width}-1}, inclusive, and y indices
@var{yoffset} through @r{@var{yoffset}+@var{height}-1}, inclusive, at
the mipmap level specified by @var{level}.

The pixels in the rectangle are processed exactly as if
@code{glCopyPixels} had been called, but the process stops just before
final conversion.  At this point, all pixel component values are clamped
to the range @r{[0,1]} and then converted to the texture's internal
format for storage in the texel array.

The destination rectangle in the texture array may not include any
texels outside the texture array as it was originally specified.  It is
not an error to specify a subtexture with zero width or height, but such
a specification has no effect.

If any of the pixels within the specified rectangle of the current
@code{GL_READ_BUFFER} are outside the read window associated with the
current rendering context, then the values obtained for those pixels are
undefined.

No change is made to the @var{internalformat}, @var{width},
@var{height}, or @var{border} parameters of the specified texture array
or to texel values outside the specified subregion.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@code{GL_INVALID_OPERATION} is generated if the texture array has not
been defined by a previous @code{glTexImage2D} or
@code{glCopyTexImage2D} operation.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if
@r{@var{level}>@var{log}_2⁡(@var{max},)}, where @r{@var{max}} is the
returned value of @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @r{@var{xoffset}<-@var{b}},
@r{(@var{xoffset}+@var{width},)>(@var{w}-@var{b},)},
@r{@var{yoffset}<-@var{b}}, or
@r{(@var{yoffset}+@var{height},)>(@var{h}-@var{b},)}, where @r{@var{w}}
is the @code{GL_TEXTURE_WIDTH}, @r{@var{h}} is the
@code{GL_TEXTURE_HEIGHT}, and @r{@var{b}} is the
@code{GL_TEXTURE_BORDER} of the texture image being modified.  Note that
@r{@var{w}} and @r{@var{h}} include twice the border width.

@code{GL_INVALID_OPERATION} is generated if @code{glCopyTexSubImage2D}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCopyTexSubImage3D target level xoffset yoffset zoffset x y width height
Copy a three-dimensional texture subimage.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_3D}

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{yoffset}
Specifies a texel offset in the y direction within the texture array.

@item @var{zoffset}
Specifies a texel offset in the z direction within the texture array.

@item @var{x}
@itemx @var{y}
Specify the window coordinates of the lower left corner of the
rectangular region of pixels to be copied.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{height}
Specifies the height of the texture subimage.

@end table

@code{glCopyTexSubImage3D} replaces a rectangular portion of a
three-dimensional texture image with pixels from the current
@code{GL_READ_BUFFER} (rather than from main memory, as is the case for
@code{glTexSubImage3D}).

The screen-aligned pixel rectangle with lower left corner at (@var{x},\
@var{y}) and with width @var{width} and height @var{height} replaces the
portion of the texture array with x indices @var{xoffset} through
@r{@var{xoffset}+@var{width}-1}, inclusive, and y indices @var{yoffset}
through @r{@var{yoffset}+@var{height}-1}, inclusive, at z index
@var{zoffset} and at the mipmap level specified by @var{level}.

The pixels in the rectangle are processed exactly as if
@code{glCopyPixels} had been called, but the process stops just before
final conversion.  At this point, all pixel component values are clamped
to the range @r{[0,1]} and then converted to the texture's internal
format for storage in the texel array.

The destination rectangle in the texture array may not include any
texels outside the texture array as it was originally specified.  It is
not an error to specify a subtexture with zero width or height, but such
a specification has no effect.

If any of the pixels within the specified rectangle of the current
@code{GL_READ_BUFFER} are outside the read window associated with the
current rendering context, then the values obtained for those pixels are
undefined.

No change is made to the @var{internalformat}, @var{width},
@var{height}, @var{depth}, or @var{border} parameters of the specified
texture array or to texel values outside the specified subregion.

@code{GL_INVALID_ENUM} is generated if /@var{target} is not
@code{GL_TEXTURE_3D}.

@code{GL_INVALID_OPERATION} is generated if the texture array has not
been defined by a previous @code{glTexImage3D} operation.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if
@r{@var{level}>@var{log}_2⁡(@var{max},)}, where @r{@var{max}} is the
returned value of @code{GL_MAX_3D_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @r{@var{xoffset}<-@var{b}},
@r{(@var{xoffset}+@var{width},)>(@var{w}-@var{b},)},
@r{@var{yoffset}<-@var{b}},
@r{(@var{yoffset}+@var{height},)>(@var{h}-@var{b},)},
@r{@var{zoffset}<-@var{b}}, or
@r{(@var{zoffset}+1,)>(@var{d}-@var{b},)}, where @r{@var{w}} is the
@code{GL_TEXTURE_WIDTH}, @r{@var{h}} is the @code{GL_TEXTURE_HEIGHT},
@r{@var{d}} is the @code{GL_TEXTURE_DEPTH}, and @r{@var{b}} is the
@code{GL_TEXTURE_BORDER} of the texture image being modified.  Note that
@r{@var{w}}, @r{@var{h}}, and @r{@var{d}} include twice the border
width.

@code{GL_INVALID_OPERATION} is generated if @code{glCopyTexSubImage3D}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun GLuint glCreateProgram 
Creates a program object.

@code{glCreateProgram} creates an empty program object and returns a
non-zero value by which it can be referenced.  A program object is an
object to which shader objects can be attached.  This provides a
mechanism to specify the shader objects that will be linked to create a
program.  It also provides a means for checking the compatibility of the
shaders that will be used to create a program (for instance, checking
the compatibility between a vertex shader and a fragment shader).  When
no longer needed as part of a program object, shader objects can be
detached.

One or more executables are created in a program object by successfully
attaching shader objects to it with @code{glAttachShader}, successfully
compiling the shader objects with @code{glCompileShader}, and
successfully linking the program object with @code{glLinkProgram}.  These
executables are made part of current state when @code{glUseProgram} is
called.  Program objects can be deleted by calling
@code{glDeleteProgram}.  The memory associated with the program object
will be deleted when it is no longer part of current rendering state for
any context.

This function returns 0 if an error occurs creating the program object.

@code{GL_INVALID_OPERATION} is generated if @code{glCreateProgram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLuint glCreateShader shaderType
Creates a shader object.

@table @asis
@item @var{shaderType}
Specifies the type of shader to be created.  Must be either
@code{GL_VERTEX_SHADER} or @code{GL_FRAGMENT_SHADER}.

@end table

@code{glCreateShader} creates an empty shader object and returns a
non-zero value by which it can be referenced.  A shader object is used
to maintain the source code strings that define a shader.
@var{shaderType} indicates the type of shader to be created.  Two types
of shaders are supported.  A shader of type @code{GL_VERTEX_SHADER} is a
shader that is intended to run on the programmable vertex processor and
replace the fixed functionality vertex processing in OpenGL.  A shader
of type @code{GL_FRAGMENT_SHADER} is a shader that is intended to run on
the programmable fragment processor and replace the fixed functionality
fragment processing in OpenGL.

When created, a shader object's @code{GL_SHADER_TYPE} parameter is set
to either @code{GL_VERTEX_SHADER} or @code{GL_FRAGMENT_SHADER},
depending on the value of @var{shaderType}.

This function returns 0 if an error occurs creating the shader object.

@code{GL_INVALID_ENUM} is generated if @var{shaderType} is not an
accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glCreateShader} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glCullFace mode
Specify whether front- or back-facing facets can be culled.

@table @asis
@item @var{mode}
Specifies whether front- or back-facing facets are candidates for
culling.  Symbolic constants @code{GL_FRONT}, @code{GL_BACK}, and
@code{GL_FRONT_AND_BACK} are accepted.  The initial value is
@code{GL_BACK}.

@end table

@code{glCullFace} specifies whether front- or back-facing facets are
culled (as specified by @var{mode}) when facet culling is enabled.  Facet
culling is initially disabled.  To enable and disable facet culling,
call the @code{glEnable} and @code{glDisable} commands with the argument
@code{GL_CULL_FACE}.  Facets include triangles, quadrilaterals,
polygons, and rectangles.

@code{glFrontFace} specifies which of the clockwise and counterclockwise
facets are front-facing and back-facing.  See @code{glFrontFace}.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glCullFace} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDeleteBuffers n buffers
Delete named buffer objects.

@table @asis
@item @var{n}
Specifies the number of buffer objects to be deleted.

@item @var{buffers}
Specifies an array of buffer objects to be deleted.

@end table

@code{glDeleteBuffers} deletes @var{n} buffer objects named by the
elements of the array @var{buffers}.  After a buffer object is deleted,
it has no contents, and its name is free for reuse (for example by
@code{glGenBuffers}).  If a buffer object that is currently bound is
deleted, the binding reverts to 0 (the absence of any buffer object,
which reverts to client memory usage).

@code{glDeleteBuffers} silently ignores 0's and names that do not
correspond to existing buffer objects.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glDeleteBuffers} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDeleteLists list range
Delete a contiguous group of display lists.

@table @asis
@item @var{list}
Specifies the integer name of the first display list to delete.

@item @var{range}
Specifies the number of display lists to delete.

@end table

@code{glDeleteLists} causes a contiguous group of display lists to be
deleted.  @var{list} is the name of the first display list to be
deleted, and @var{range} is the number of display lists to delete.  All
display lists @r{@var{d}} with
@r{@var{list}<=@var{d}<=@var{list}+@var{range}-1} are deleted.

All storage locations allocated to the specified display lists are
freed, and the names are available for reuse at a later time.  Names
within the range that do not have an associated display list are
ignored.  If @var{range} is 0, nothing happens.

@code{GL_INVALID_VALUE} is generated if @var{range} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glDeleteLists} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDeleteProgram program
Deletes a program object.

@table @asis
@item @var{program}
Specifies the program object to be deleted.

@end table

@code{glDeleteProgram} frees the memory and invalidates the name
associated with the program object specified by @var{program.} This
command effectively undoes the effects of a call to
@code{glCreateProgram}.

If a program object is in use as part of current rendering state, it
will be flagged for deletion, but it will not be deleted until it is no
longer part of current state for any rendering context.  If a program
object to be deleted has shader objects attached to it, those shader
objects will be automatically detached but not deleted unless they have
already been flagged for deletion by a previous call to
@code{glDeleteShader}.  A value of 0 for @var{program} will be silently
ignored.

To determine whether a program object has been flagged for deletion,
call @code{glGetProgram} with arguments @var{program} and
@code{GL_DELETE_STATUS}.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @code{glDeleteProgram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDeleteQueries n ids
Delete named query objects.

@table @asis
@item @var{n}
Specifies the number of query objects to be deleted.

@item @var{ids}
Specifies an array of query objects to be deleted.

@end table

@code{glDeleteQueries} deletes @var{n} query objects named by the
elements of the array @var{ids}.  After a query object is deleted, it
has no contents, and its name is free for reuse (for example by
@code{glGenQueries}).

@code{glDeleteQueries} silently ignores 0's and names that do not
correspond to existing query objects.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glDeleteQueries} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDeleteShader shader
Deletes a shader object.

@table @asis
@item @var{shader}
Specifies the shader object to be deleted.

@end table

@code{glDeleteShader} frees the memory and invalidates the name
associated with the shader object specified by @var{shader}.  This
command effectively undoes the effects of a call to
@code{glCreateShader}.

If a shader object to be deleted is attached to a program object, it
will be flagged for deletion, but it will not be deleted until it is no
longer attached to any program object, for any rendering context (i.e.,
it must be detached from wherever it was attached before it will be
deleted).  A value of 0 for @var{shader} will be silently ignored.

To determine whether an object has been flagged for deletion, call
@code{glGetShader} with arguments @var{shader} and
@code{GL_DELETE_STATUS}.

@code{GL_INVALID_VALUE} is generated if @var{shader} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @code{glDeleteShader} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDeleteTextures n textures
Delete named textures.

@table @asis
@item @var{n}
Specifies the number of textures to be deleted.

@item @var{textures}
Specifies an array of textures to be deleted.

@end table

@code{glDeleteTextures} deletes @var{n} textures named by the elements
of the array @var{textures}.  After a texture is deleted, it has no
contents or dimensionality, and its name is free for reuse (for example
by @code{glGenTextures}).  If a texture that is currently bound is
deleted, the binding reverts to 0 (the default texture).

@code{glDeleteTextures} silently ignores 0's and names that do not
correspond to existing textures.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glDeleteTextures} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDepthFunc func
Specify the value used for depth buffer comparisons.

@table @asis
@item @var{func}
Specifies the depth comparison function.  Symbolic constants
@code{GL_NEVER}, @code{GL_LESS}, @code{GL_EQUAL}, @code{GL_LEQUAL},
@code{GL_GREATER}, @code{GL_NOTEQUAL}, @code{GL_GEQUAL}, and
@code{GL_ALWAYS} are accepted.  The initial value is @code{GL_LESS}.

@end table

@code{glDepthFunc} specifies the function used to compare each incoming
pixel depth value with the depth value present in the depth buffer.  The
comparison is performed only if depth testing is enabled.  (See
@code{glEnable} and @code{glDisable} of @code{GL_DEPTH_TEST}.)

@var{func} specifies the conditions under which the pixel will be drawn.
The comparison functions are as follows:

@table @asis
@item @code{GL_NEVER}
Never passes.

@item @code{GL_LESS}
Passes if the incoming depth value is less than the stored depth value.

@item @code{GL_EQUAL}
Passes if the incoming depth value is equal to the stored depth value.

@item @code{GL_LEQUAL}
Passes if the incoming depth value is less than or equal to the stored
depth value.

@item @code{GL_GREATER}
Passes if the incoming depth value is greater than the stored depth
value.

@item @code{GL_NOTEQUAL}
Passes if the incoming depth value is not equal to the stored depth
value.

@item @code{GL_GEQUAL}
Passes if the incoming depth value is greater than or equal to the
stored depth value.

@item @code{GL_ALWAYS}
Always passes.

@end table

The initial value of @var{func} is @code{GL_LESS}.  Initially, depth
testing is disabled.  If depth testing is disabled or if no depth buffer
exists, it is as if the depth test always passes.

@code{GL_INVALID_ENUM} is generated if @var{func} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glDepthFunc} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDepthMask flag
Enable or disable writing into the depth buffer.

@table @asis
@item @var{flag}
Specifies whether the depth buffer is enabled for writing.  If
@var{flag} is @code{GL_FALSE}, depth buffer writing is disabled.
Otherwise, it is enabled.  Initially, depth buffer writing is enabled.

@end table

@code{glDepthMask} specifies whether the depth buffer is enabled for
writing.  If @var{flag} is @code{GL_FALSE}, depth buffer writing is
disabled.  Otherwise, it is enabled.  Initially, depth buffer writing is
enabled.

@code{GL_INVALID_OPERATION} is generated if @code{glDepthMask} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDepthRange nearVal farVal
Specify mapping of depth values from normalized device coordinates to
window coordinates.

@table @asis
@item @var{nearVal}
Specifies the mapping of the near clipping plane to window coordinates.
The initial value is 0.

@item @var{farVal}
Specifies the mapping of the far clipping plane to window coordinates.
The initial value is 1.

@end table

After clipping and division by @var{w}, depth coordinates range from
@r{-1} to 1, corresponding to the near and far clipping planes.
@code{glDepthRange} specifies a linear mapping of the normalized depth
coordinates in this range to window depth coordinates.  Regardless of
the actual depth buffer implementation, window coordinate depth values
are treated as though they range from 0 through 1 (like color
components).  Thus, the values accepted by @code{glDepthRange} are both
clamped to this range before they are accepted.

The setting of (0,1) maps the near plane to 0 and the far plane to 1.
With this mapping, the depth buffer range is fully utilized.

@code{GL_INVALID_OPERATION} is generated if @code{glDepthRange} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDetachShader program shader
Detaches a shader object from a program object to which it is attached.

@table @asis
@item @var{program}
Specifies the program object from which to detach the shader object.

@item @var{shader}
Specifies the shader object to be detached.

@end table

@code{glDetachShader} detaches the shader object specified by
@var{shader} from the program object specified by @var{program}.  This
command can be used to undo the effect of the command
@code{glAttachShader}.

If @var{shader} has already been flagged for deletion by a call to
@code{glDeleteShader} and it is not attached to any other program
object, it will be deleted after it has been detached.

@code{GL_INVALID_VALUE} is generated if either @var{program} or
@var{shader} is a value that was not generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is not a shader
object.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is not attached
to @var{program}.

@code{GL_INVALID_OPERATION} is generated if @code{glDetachShader} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDrawArrays mode first count
Render primitives from array data.

@table @asis
@item @var{mode}
Specifies what kind of primitives to render.  Symbolic constants
@code{GL_POINTS}, @code{GL_LINE_STRIP}, @code{GL_LINE_LOOP},
@code{GL_LINES}, @code{GL_TRIANGLE_STRIP}, @code{GL_TRIANGLE_FAN},
@code{GL_TRIANGLES}, @code{GL_QUAD_STRIP}, @code{GL_QUADS}, and
@code{GL_POLYGON} are accepted.

@item @var{first}
Specifies the starting index in the enabled arrays.

@item @var{count}
Specifies the number of indices to be rendered.

@end table

@code{glDrawArrays} specifies multiple geometric primitives with very
few subroutine calls.  Instead of calling a GL procedure to pass each
individual vertex, normal, texture coordinate, edge flag, or color, you
can prespecify separate arrays of vertices, normals, and colors and use
them to construct a sequence of primitives with a single call to
@code{glDrawArrays}.

When @code{glDrawArrays} is called, it uses @var{count} sequential
elements from each enabled array to construct a sequence of geometric
primitives, beginning with element @var{first}.  @var{mode} specifies
what kind of primitives are constructed and how the array elements
construct those primitives.  If @code{GL_VERTEX_ARRAY} is not enabled,
no geometric primitives are generated.

Vertex attributes that are modified by @code{glDrawArrays} have an
unspecified value after @code{glDrawArrays} returns.  For example, if
@code{GL_COLOR_ARRAY} is enabled, the value of the current color is
undefined after @code{glDrawArrays} executes.  Attributes that aren't
modified remain well defined.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{count} is negative.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to an enabled array and the buffer object's data store is
currently mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glDrawArrays} is
executed between the execution of @code{glBegin} and the corresponding
@code{glEnd}.

@end deftypefun

@deftypefun void glDrawBuffers n bufs
Specifies a list of color buffers to be drawn into.

@table @asis
@item @var{n}
Specifies the number of buffers in @var{bufs}.

@item @var{bufs}
Points to an array of symbolic constants specifying the buffers into
which fragment colors or data values will be written.

@end table

@code{glDrawBuffers} defines an array of buffers into which fragment
color values or fragment data will be written.  If no fragment shader is
active, rendering operations will generate only one fragment color per
fragment and it will be written into each of the buffers specified by
@var{bufs}.  If a fragment shader is active and it writes a value to the
output variable @code{gl_FragColor}, then that value will be written
into each of the buffers specified by @var{bufs}.  If a fragment shader
is active and it writes a value to one or more elements of the output
array variable @code{gl_FragData[]}, then the value of
@code{gl_FragData[0] } will be written into the first buffer specified
by @var{bufs}, the value of @code{gl_FragData[1] } will be written into
the second buffer specified by @var{bufs}, and so on up to
@code{gl_FragData[n-1]}.  The draw buffer used for @code{gl_FragData[n]}
and beyond is implicitly set to be @code{GL_NONE}.

The symbolic constants contained in @var{bufs} may be any of the
following:

@table @asis
@item @code{GL_NONE}
The fragment color/data value is not written into any color buffer.

@item @code{GL_FRONT_LEFT}
The fragment color/data value is written into the front left color
buffer.

@item @code{GL_FRONT_RIGHT}
The fragment color/data value is written into the front right color
buffer.

@item @code{GL_BACK_LEFT}
The fragment color/data value is written into the back left color
buffer.

@item @code{GL_BACK_RIGHT}
The fragment color/data value is written into the back right color
buffer.

@item @code{GL_AUXi}
The fragment color/data value is written into auxiliary buffer @code{i}.

@end table

Except for @code{GL_NONE}, the preceding symbolic constants may not
appear more than once in @var{bufs}.  The maximum number of draw buffers
supported is implementation dependent and can be queried by calling
@code{glGet} with the argument @code{GL_MAX_DRAW_BUFFERS}.  The number
of auxiliary buffers can be queried by calling @code{glGet} with the
argument @code{GL_AUX_BUFFERS}.

@code{GL_INVALID_ENUM} is generated if one of the values in @var{bufs}
is not an accepted value.

@code{GL_INVALID_ENUM} is generated if @var{n} is less than 0.

@code{GL_INVALID_OPERATION} is generated if a symbolic constant other
than @code{GL_NONE} appears more than once in @var{bufs}.

@code{GL_INVALID_OPERATION} is generated if any of the entries in
@var{bufs} (other than @code{GL_NONE} ) indicates a color buffer that
does not exist in the current GL context.

@code{GL_INVALID_VALUE} is generated if @var{n} is greater than
@code{GL_MAX_DRAW_BUFFERS}.

@code{GL_INVALID_OPERATION} is generated if @code{glDrawBuffers} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDrawBuffer mode
Specify which color buffers are to be drawn into.

@table @asis
@item @var{mode}
Specifies up to four color buffers to be drawn into.  Symbolic constants
@code{GL_NONE}, @code{GL_FRONT_LEFT}, @code{GL_FRONT_RIGHT},
@code{GL_BACK_LEFT}, @code{GL_BACK_RIGHT}, @code{GL_FRONT},
@code{GL_BACK}, @code{GL_LEFT}, @code{GL_RIGHT},
@code{GL_FRONT_AND_BACK}, and @code{GL_AUX}@var{i}, where @var{i} is
between 0 and the value of @code{GL_AUX_BUFFERS} minus 1, are accepted.
(@code{GL_AUX_BUFFERS} is not the upper limit; use @code{glGet} to query
the number of available aux buffers.) The initial value is
@code{GL_FRONT} for single-buffered contexts, and @code{GL_BACK} for
double-buffered contexts.

@end table

When colors are written to the frame buffer, they are written into the
color buffers specified by @code{glDrawBuffer}.  The specifications are
as follows:

@table @asis
@item @code{GL_NONE}
No color buffers are written.

@item @code{GL_FRONT_LEFT}
Only the front left color buffer is written.

@item @code{GL_FRONT_RIGHT}
Only the front right color buffer is written.

@item @code{GL_BACK_LEFT}
Only the back left color buffer is written.

@item @code{GL_BACK_RIGHT}
Only the back right color buffer is written.

@item @code{GL_FRONT}
Only the front left and front right color buffers are written.  If there
is no front right color buffer, only the front left color buffer is
written.

@item @code{GL_BACK}
Only the back left and back right color buffers are written.  If there
is no back right color buffer, only the back left color buffer is
written.

@item @code{GL_LEFT}
Only the front left and back left color buffers are written.  If there
is no back left color buffer, only the front left color buffer is
written.

@item @code{GL_RIGHT}
Only the front right and back right color buffers are written.  If there
is no back right color buffer, only the front right color buffer is
written.

@item @code{GL_FRONT_AND_BACK}
All the front and back color buffers (front left, front right, back
left, back right) are written.  If there are no back color buffers, only
the front left and front right color buffers are written.  If there are
no right color buffers, only the front left and back left color buffers
are written.  If there are no right or back color buffers, only the
front left color buffer is written.

@item @code{GL_AUX}@var{i}
Only auxiliary color buffer @var{i} is written.

@end table

If more than one color buffer is selected for drawing, then blending or
logical operations are computed and applied independently for each color
buffer and can produce different results in each buffer.

Monoscopic contexts include only @var{left} buffers, and stereoscopic
contexts include both @var{left} and @var{right} buffers.  Likewise,
single-buffered contexts include only @var{front} buffers, and
double-buffered contexts include both @var{front} and @var{back}
buffers.  The context is selected at GL initialization.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if none of the buffers
indicated by @var{mode} exists.

@code{GL_INVALID_OPERATION} is generated if @code{glDrawBuffer} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDrawElements mode count type indices
Render primitives from array data.

@table @asis
@item @var{mode}
Specifies what kind of primitives to render.  Symbolic constants
@code{GL_POINTS}, @code{GL_LINE_STRIP}, @code{GL_LINE_LOOP},
@code{GL_LINES}, @code{GL_TRIANGLE_STRIP}, @code{GL_TRIANGLE_FAN},
@code{GL_TRIANGLES}, @code{GL_QUAD_STRIP}, @code{GL_QUADS}, and
@code{GL_POLYGON} are accepted.

@item @var{count}
Specifies the number of elements to be rendered.

@item @var{type}
Specifies the type of the values in @var{indices}.  Must be one of
@code{GL_UNSIGNED_BYTE}, @code{GL_UNSIGNED_SHORT}, or
@code{GL_UNSIGNED_INT}.

@item @var{indices}
Specifies a pointer to the location where the indices are stored.

@end table

@code{glDrawElements} specifies multiple geometric primitives with very
few subroutine calls.  Instead of calling a GL function to pass each
individual vertex, normal, texture coordinate, edge flag, or color, you
can prespecify separate arrays of vertices, normals, and so on, and use
them to construct a sequence of primitives with a single call to
@code{glDrawElements}.

When @code{glDrawElements} is called, it uses @var{count} sequential
elements from an enabled array, starting at @var{indices} to construct a
sequence of geometric primitives.  @var{mode} specifies what kind of
primitives are constructed and how the array elements construct these
primitives.  If more than one array is enabled, each is used.  If
@code{GL_VERTEX_ARRAY} is not enabled, no geometric primitives are
constructed.

Vertex attributes that are modified by @code{glDrawElements} have an
unspecified value after @code{glDrawElements} returns.  For example, if
@code{GL_COLOR_ARRAY} is enabled, the value of the current color is
undefined after @code{glDrawElements} executes.  Attributes that aren't
modified maintain their previous values.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{count} is negative.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to an enabled array or the element array and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glDrawElements} is
executed between the execution of @code{glBegin} and the corresponding
@code{glEnd}.

@end deftypefun

@deftypefun void glDrawPixels width height format type data
Write a block of pixels to the frame buffer.

@table @asis
@item @var{width}
@itemx @var{height}
Specify the dimensions of the pixel rectangle to be written into the
frame buffer.

@item @var{format}
Specifies the format of the pixel data.  Symbolic constants
@code{GL_COLOR_INDEX}, @code{GL_STENCIL_INDEX},
@code{GL_DEPTH_COMPONENT}, @code{GL_RGB}, @code{GL_BGR}, @code{GL_RGBA},
@code{GL_BGRA}, @code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE},
@code{GL_ALPHA}, @code{GL_LUMINANCE}, and @code{GL_LUMINANCE_ALPHA} are
accepted.

@item @var{type}
Specifies the data type for @var{data}.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{data}
Specifies a pointer to the pixel data.

@end table

@code{glDrawPixels} reads pixel data from memory and writes it into the
frame buffer relative to the current raster position, provided that the
raster position is valid.  Use @code{glRasterPos} or @code{glWindowPos}
to set the current raster position; use @code{glGet} with argument
@code{GL_CURRENT_RASTER_POSITION_VALID} to determine if the specified
raster position is valid, and @code{glGet} with argument
@code{GL_CURRENT_RASTER_POSITION} to query the raster position.

Several parameters define the encoding of pixel data in memory and
control the processing of the pixel data before it is placed in the
frame buffer.  These parameters are set with four commands:
@code{glPixelStore}, @code{glPixelTransfer}, @code{glPixelMap}, and
@code{glPixelZoom}.  This reference page describes the effects on
@code{glDrawPixels} of many, but not all, of the parameters specified by
these four commands.

Data is read from @var{data} as a sequence of signed or unsigned bytes,
signed or unsigned shorts, signed or unsigned integers, or
single-precision floating-point values, depending on @var{type}.  When
@var{type} is one of @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, or @code{GL_FLOAT} each of these bytes, shorts, integers,
or floating-point values is interpreted as one color or depth component,
or one index, depending on @var{format}.  When @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_INT_8_8_8_8}, or @code{GL_UNSIGNED_INT_10_10_10_2},
each unsigned value is interpreted as containing all the components for
a single pixel, with the color components arranged according to
@var{format}.  When @var{type} is one of
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV}, each unsigned value is
interpreted as containing all color components, specified by
@var{format}, for a single pixel in a reversed order.  Indices are
always treated individually.  Color components are treated as groups of
one, two, three, or four values, again based on @var{format}.  Both
individual indices and groups of components are referred to as pixels.
If @var{type} is @code{GL_BITMAP}, the data must be unsigned bytes, and
@var{format} must be either @code{GL_COLOR_INDEX} or
@code{GL_STENCIL_INDEX}.  Each unsigned byte is treated as eight 1-bit
pixels, with bit ordering determined by @code{GL_UNPACK_LSB_FIRST} (see
@code{glPixelStore}).

@r{@var{width}×@var{height}} pixels are read from memory, starting at
location @var{data}.  By default, these pixels are taken from adjacent
memory locations, except that after all @var{width} pixels are read, the
read pointer is advanced to the next four-byte boundary.  The four-byte
row alignment is specified by @code{glPixelStore} with argument
@code{GL_UNPACK_ALIGNMENT}, and it can be set to one, two, four, or
eight bytes.  Other pixel store parameters specify different read
pointer advancements, both before the first pixel is read and after all
@var{width} pixels are read.  See the @code{glPixelStore} reference page
for details on these options.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
block of pixels is specified, @var{data} is treated as a byte offset
into the buffer object's data store.

The @r{@var{width}×@var{height}} pixels that are read from memory are
each operated on in the same way, based on the values of several
parameters specified by @code{glPixelTransfer} and @code{glPixelMap}.
The details of these operations, as well as the target buffer into which
the pixels are drawn, are specific to the format of the pixels, as
specified by @var{format}.  @var{format} can assume one of 13 symbolic
values:

@table @asis
@item @code{GL_COLOR_INDEX}
Each pixel is a single value, a color index.  It is converted to
fixed-point format, with an unspecified number of bits to the right of
the binary point, regardless of the memory data type.  Floating-point
values convert to true fixed-point values.  Signed and unsigned integer
data is converted with all fraction bits set to 0.  Bitmap data convert
to either 0 or 1.

Each fixed-point index is then shifted left by @code{GL_INDEX_SHIFT}
bits and added to @code{GL_INDEX_OFFSET}.  If @code{GL_INDEX_SHIFT} is
negative, the shift is to the right.  In either case, zero bits fill
otherwise unspecified bit locations in the result.

If the GL is in RGBA mode, the resulting index is converted to an RGBA
pixel with the help of the @code{GL_PIXEL_MAP_I_TO_R},
@code{GL_PIXEL_MAP_I_TO_G}, @code{GL_PIXEL_MAP_I_TO_B}, and
@code{GL_PIXEL_MAP_I_TO_A} tables.  If the GL is in color index mode,
and if @code{GL_MAP_COLOR} is true, the index is replaced with the value
that it references in lookup table @code{GL_PIXEL_MAP_I_TO_I}.  Whether
the lookup replacement of the index is done or not, the integer part of
the index is then ANDed with @r{2^@var{b}-1}, where @r{@var{b}} is the
number of bits in a color index buffer.

The GL then converts the resulting indices or RGBA colors to fragments
by attaching the current raster position @var{z} coordinate and texture
coordinates to each pixel, then assigning @r{@var{x}} and @r{@var{y}}
window coordinates to the @r{@var{n}}th fragment such that
@r{@var{x}_@var{n}=@var{x}_@var{r}+@var{n}%@var{width}}@r{@var{y}_@var{n}=@var{y}_@var{r}+⌊@var{n}/@var{width},⌋}

where @r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster
position.  These pixel fragments are then treated just like the
fragments generated by rasterizing points, lines, or polygons.  Texture
mapping, fog, and all the fragment operations are applied before the
fragments are written to the frame buffer.

@item @code{GL_STENCIL_INDEX}
Each pixel is a single value, a stencil index.  It is converted to
fixed-point format, with an unspecified number of bits to the right of
the binary point, regardless of the memory data type.  Floating-point
values convert to true fixed-point values.  Signed and unsigned integer
data is converted with all fraction bits set to 0.  Bitmap data convert
to either 0 or 1.

Each fixed-point index is then shifted left by @code{GL_INDEX_SHIFT}
bits, and added to @code{GL_INDEX_OFFSET}.  If @code{GL_INDEX_SHIFT} is
negative, the shift is to the right.  In either case, zero bits fill
otherwise unspecified bit locations in the result.  If
@code{GL_MAP_STENCIL} is true, the index is replaced with the value that
it references in lookup table @code{GL_PIXEL_MAP_S_TO_S}.  Whether the
lookup replacement of the index is done or not, the integer part of the
index is then ANDed with @r{2^@var{b}-1}, where @r{@var{b}} is the
number of bits in the stencil buffer.  The resulting stencil indices are
then written to the stencil buffer such that the @r{@var{n}}th index is
written to location

@r{@var{x}_@var{n}=@var{x}_@var{r}+@var{n}%@var{width}}@r{@var{y}_@var{n}=@var{y}_@var{r}+⌊@var{n}/@var{width},⌋}

where @r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster
position.  Only the pixel ownership test, the scissor test, and the
stencil writemask affect these write operations.

@item @code{GL_DEPTH_COMPONENT}
Each pixel is a single-depth component.  Floating-point data is
converted directly to an internal floating-point format with unspecified
precision.  Signed integer data is mapped linearly to the internal
floating-point format such that the most positive representable integer
value maps to 1.0, and the most negative representable value maps to
@r{-1.0}.  Unsigned integer data is mapped similarly: the largest
integer value maps to 1.0, and 0 maps to 0.0.  The resulting
floating-point depth value is then multiplied by @code{GL_DEPTH_SCALE}
and added to @code{GL_DEPTH_BIAS}.  The result is clamped to the range
@r{[0,1]}.

The GL then converts the resulting depth components to fragments by
attaching the current raster position color or color index and texture
coordinates to each pixel, then assigning @r{@var{x}} and @r{@var{y}}
window coordinates to the @r{@var{n}}th fragment such that

@r{@var{x}_@var{n}=@var{x}_@var{r}+@var{n}%@var{width}}@r{@var{y}_@var{n}=@var{y}_@var{r}+⌊@var{n}/@var{width},⌋}

where @r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster
position.  These pixel fragments are then treated just like the
fragments generated by rasterizing points, lines, or polygons.  Texture
mapping, fog, and all the fragment operations are applied before the
fragments are written to the frame buffer.

@item @code{GL_RGBA}
@item @code{GL_BGRA}
Each pixel is a four-component group: For @code{GL_RGBA}, the red
component is first, followed by green, followed by blue, followed by
alpha; for @code{GL_BGRA} the order is blue, green, red and then alpha.
Floating-point values are converted directly to an internal
floating-point format with unspecified precision.  Signed integer values
are mapped linearly to the internal floating-point format such that the
most positive representable integer value maps to 1.0, and the most
negative representable value maps to @r{-1.0}.  (Note that this mapping
does not convert 0 precisely to 0.0.) Unsigned integer data is mapped
similarly: The largest integer value maps to 1.0, and 0 maps to 0.0.  The
resulting floating-point color values are then multiplied by
@code{GL_c_SCALE} and added to @code{GL_c_BIAS}, where @var{c} is RED,
GREEN, BLUE, and ALPHA for the respective color components.  The results
are clamped to the range @r{[0,1]}.

If @code{GL_MAP_COLOR} is true, each color component is scaled by the
size of lookup table @code{GL_PIXEL_MAP_c_TO_c}, then replaced by the
value that it references in that table.  @var{c} is R, G, B, or A
respectively.

The GL then converts the resulting RGBA colors to fragments by attaching
the current raster position @var{z} coordinate and texture coordinates
to each pixel, then assigning @r{@var{x}} and @r{@var{y}} window
coordinates to the @r{@var{n}}th fragment such that

@r{@var{x}_@var{n}=@var{x}_@var{r}+@var{n}%@var{width}}@r{@var{y}_@var{n}=@var{y}_@var{r}+⌊@var{n}/@var{width},⌋}

where @r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster
position.  These pixel fragments are then treated just like the
fragments generated by rasterizing points, lines, or polygons.  Texture
mapping, fog, and all the fragment operations are applied before the
fragments are written to the frame buffer.

@item @code{GL_RED}
Each pixel is a single red component.  This component is converted to
the internal floating-point format in the same way the red component of
an RGBA pixel is.  It is then converted to an RGBA pixel with green and
blue set to 0, and alpha set to 1.  After this conversion, the pixel is
treated as if it had been read as an RGBA pixel.

@item @code{GL_GREEN}
Each pixel is a single green component.  This component is converted to
the internal floating-point format in the same way the green component
of an RGBA pixel is.  It is then converted to an RGBA pixel with red and
blue set to 0, and alpha set to 1.  After this conversion, the pixel is
treated as if it had been read as an RGBA pixel.

@item @code{GL_BLUE}
Each pixel is a single blue component.  This component is converted to
the internal floating-point format in the same way the blue component of
an RGBA pixel is.  It is then converted to an RGBA pixel with red and
green set to 0, and alpha set to 1.  After this conversion, the pixel is
treated as if it had been read as an RGBA pixel.

@item @code{GL_ALPHA}
Each pixel is a single alpha component.  This component is converted to
the internal floating-point format in the same way the alpha component
of an RGBA pixel is.  It is then converted to an RGBA pixel with red,
green, and blue set to 0.  After this conversion, the pixel is treated
as if it had been read as an RGBA pixel.

@item @code{GL_RGB}
@item @code{GL_BGR}
Each pixel is a three-component group: red first, followed by green,
followed by blue; for @code{GL_BGR}, the first component is blue,
followed by green and then red.  Each component is converted to the
internal floating-point format in the same way the red, green, and blue
components of an RGBA pixel are.  The color triple is converted to an
RGBA pixel with alpha set to 1.  After this conversion, the pixel is
treated as if it had been read as an RGBA pixel.

@item @code{GL_LUMINANCE}
Each pixel is a single luminance component.  This component is converted
to the internal floating-point format in the same way the red component
of an RGBA pixel is.  It is then converted to an RGBA pixel with red,
green, and blue set to the converted luminance value, and alpha set to
1.  After this conversion, the pixel is treated as if it had been read
as an RGBA pixel.

@item @code{GL_LUMINANCE_ALPHA}
Each pixel is a two-component group: luminance first, followed by alpha.
The two components are converted to the internal floating-point format
in the same way the red component of an RGBA pixel is.  They are then
converted to an RGBA pixel with red, green, and blue set to the
converted luminance value, and alpha set to the converted alpha value.
After this conversion, the pixel is treated as if it had been read as an
RGBA pixel.

@end table

The following table summarizes the meaning of the valid constants for
the @var{type} parameter:



@table @asis
@item @strong{Type}
@strong{Corresponding Type}

@item @code{GL_UNSIGNED_BYTE}
unsigned 8-bit integer

@item @code{GL_BYTE}
signed 8-bit integer

@item @code{GL_BITMAP}
single bits in unsigned 8-bit integers

@item @code{GL_UNSIGNED_SHORT}
unsigned 16-bit integer

@item @code{GL_SHORT}
signed 16-bit integer

@item @code{GL_UNSIGNED_INT}
unsigned 32-bit integer

@item @code{GL_INT}
32-bit integer

@item @code{GL_FLOAT}
single-precision floating-point

@item @code{GL_UNSIGNED_BYTE_3_3_2}
unsigned 8-bit integer

@item @code{GL_UNSIGNED_BYTE_2_3_3_REV}
unsigned 8-bit integer with reversed component ordering

@item @code{GL_UNSIGNED_SHORT_5_6_5}
unsigned 16-bit integer

@item @code{GL_UNSIGNED_SHORT_5_6_5_REV}
unsigned 16-bit integer with reversed component ordering

@item @code{GL_UNSIGNED_SHORT_4_4_4_4}
unsigned 16-bit integer

@item @code{GL_UNSIGNED_SHORT_4_4_4_4_REV}
unsigned 16-bit integer with reversed component ordering

@item @code{GL_UNSIGNED_SHORT_5_5_5_1}
unsigned 16-bit integer

@item @code{GL_UNSIGNED_SHORT_1_5_5_5_REV}
unsigned 16-bit integer with reversed component ordering

@item @code{GL_UNSIGNED_INT_8_8_8_8}
unsigned 32-bit integer

@item @code{GL_UNSIGNED_INT_8_8_8_8_REV}
unsigned 32-bit integer with reversed component ordering

@item @code{GL_UNSIGNED_INT_10_10_10_2}
unsigned 32-bit integer

@item @code{GL_UNSIGNED_INT_2_10_10_10_REV}
unsigned 32-bit integer with reversed component ordering

@end table



The rasterization described so far assumes pixel zoom factors of 1.  If
@code{glPixelZoom} is used to change the @r{@var{x}} and @r{@var{y}}
pixel zoom factors, pixels are converted to fragments as follows.  If
@r{(@var{x}_@var{r},@var{y}_@var{r})} is the current raster position,
and a given pixel is in the @r{@var{n}}th column and @r{@var{m}}th row
of the pixel rectangle, then fragments are generated for pixels whose
centers are in the rectangle with corners at

@r{(@var{x}_@var{r}+@var{zoom}_@var{x},⁢@var{n},@var{y}_@var{r}+@var{zoom}_@var{y},⁢@var{m})}@r{(@var{x}_@var{r}+@var{zoom}_@var{x},⁡(@var{n}+1,),@var{y}_@var{r}+@var{zoom}_@var{y},⁡(@var{m}+1,))}

where @r{@var{zoom}_@var{x}} is the value of @code{GL_ZOOM_X} and
@r{@var{zoom}_@var{y}} is the value of @code{GL_ZOOM_Y}.

@code{GL_INVALID_ENUM} is generated if @var{format} or @var{type} is not
one of the accepted values.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not either @code{GL_COLOR_INDEX} or
@code{GL_STENCIL_INDEX}.

@code{GL_INVALID_VALUE} is generated if either @var{width} or
@var{height} is negative.

@code{GL_INVALID_OPERATION} is generated if @var{format} is
@code{GL_STENCIL_INDEX} and there is no stencil buffer.

@code{GL_INVALID_OPERATION} is generated if @var{format} is
@code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_RGB}, @code{GL_RGBA}, @code{GL_BGR}, @code{GL_BGRA},
@code{GL_LUMINANCE}, or @code{GL_LUMINANCE_ALPHA}, and the GL is in
color index mode.

@code{GL_INVALID_OPERATION} is generated if @var{format} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{format} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glDrawPixels} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glDrawRangeElements mode start end count type indices
Render primitives from array data.

@table @asis
@item @var{mode}
Specifies what kind of primitives to render.  Symbolic constants
@code{GL_POINTS}, @code{GL_LINE_STRIP}, @code{GL_LINE_LOOP},
@code{GL_LINES}, @code{GL_TRIANGLE_STRIP}, @code{GL_TRIANGLE_FAN},
@code{GL_TRIANGLES}, @code{GL_QUAD_STRIP}, @code{GL_QUADS}, and
@code{GL_POLYGON} are accepted.

@item @var{start}
Specifies the minimum array index contained in @var{indices}.

@item @var{end}
Specifies the maximum array index contained in @var{indices}.

@item @var{count}
Specifies the number of elements to be rendered.

@item @var{type}
Specifies the type of the values in @var{indices}.  Must be one of
@code{GL_UNSIGNED_BYTE}, @code{GL_UNSIGNED_SHORT}, or
@code{GL_UNSIGNED_INT}.

@item @var{indices}
Specifies a pointer to the location where the indices are stored.

@end table

@code{glDrawRangeElements} is a restricted form of
@code{glDrawElements}.  @var{mode}, @var{start}, @var{end}, and
@var{count} match the corresponding arguments to @code{glDrawElements},
with the additional constraint that all values in the arrays @var{count}
must lie between @var{start} and @var{end}, inclusive.

Implementations denote recommended maximum amounts of vertex and index
data, which may be queried by calling @code{glGet} with argument
@code{GL_MAX_ELEMENTS_VERTICES} and @code{GL_MAX_ELEMENTS_INDICES}.  If
@r{@var{end}-@var{start}+1} is greater than the value of
@code{GL_MAX_ELEMENTS_VERTICES}, or if @var{count} is greater than the
value of @code{GL_MAX_ELEMENTS_INDICES}, then the call may operate at
reduced performance.  There is no requirement that all vertices in the
range @r{[@var{start},@var{end}]} be referenced.  However, the
implementation may partially process unused vertices, reducing
performance from what could be achieved with an optimal index set.

When @code{glDrawRangeElements} is called, it uses @var{count}
sequential elements from an enabled array, starting at @var{start} to
construct a sequence of geometric primitives.  @var{mode} specifies what
kind of primitives are constructed, and how the array elements construct
these primitives.  If more than one array is enabled, each is used.  If
@code{GL_VERTEX_ARRAY} is not enabled, no geometric primitives are
constructed.

Vertex attributes that are modified by @code{glDrawRangeElements} have
an unspecified value after @code{glDrawRangeElements} returns.  For
example, if @code{GL_COLOR_ARRAY} is enabled, the value of the current
color is undefined after @code{glDrawRangeElements} executes.  Attributes
that aren't modified maintain their previous values.

It is an error for indices to lie outside the range
@r{[@var{start},@var{end}]}, but implementations may not check for this
situation.  Such indices cause implementation-dependent behavior.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{count} is negative.

@code{GL_INVALID_VALUE} is generated if @r{@var{end}<@var{start}}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to an enabled array or the element array and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glDrawRangeElements}
is executed between the execution of @code{glBegin} and the
corresponding @code{glEnd}.

@end deftypefun

@deftypefun void glEdgeFlagPointer stride pointer
Define an array of edge flags.

@table @asis
@item @var{stride}
Specifies the byte offset between consecutive edge flags.  If
@var{stride} is 0, the edge flags are understood to be tightly packed in
the array.  The initial value is 0.

@item @var{pointer}
Specifies a pointer to the first edge flag in the array.  The initial
value is 0.

@end table

@code{glEdgeFlagPointer} specifies the location and data format of an
array of boolean edge flags to use when rendering.  @var{stride}
specifies the byte stride from one edge flag to the next, allowing
vertices and attributes to be packed into a single array or stored in
separate arrays.

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while an edge flag array is specified,
@var{pointer} is treated as a byte offset into the buffer object's data
store.  Also, the buffer object binding (@code{GL_ARRAY_BUFFER_BINDING})
is saved as edge flag vertex array client-side state
(@code{GL_EDGE_FLAG_ARRAY_BUFFER_BINDING}).

When an edge flag array is specified, @var{stride} and @var{pointer} are
saved as client-side state, in addition to the current vertex array
buffer object binding.

To enable and disable the edge flag array, call
@code{glEnableClientState} and @code{glDisableClientState} with the
argument @code{GL_EDGE_FLAG_ARRAY}.  If enabled, the edge flag array is
used when @code{glDrawArrays}, @code{glMultiDrawArrays},
@code{glDrawElements}, @code{glMultiDrawElements},
@code{glDrawRangeElements}, or @code{glArrayElement} is called.

@code{GL_INVALID_ENUM} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glEdgeFlag flag
@deftypefunx void glEdgeFlagv flag
Flag edges as either boundary or nonboundary.

@table @asis
@item @var{flag}
Specifies the current edge flag value, either @code{GL_TRUE} or
@code{GL_FALSE}.  The initial value is @code{GL_TRUE}.

@end table

Each vertex of a polygon, separate triangle, or separate quadrilateral
specified between a @code{glBegin}/@code{glEnd} pair is marked as the
start of either a boundary or nonboundary edge.  If the current edge
flag is true when the vertex is specified, the vertex is marked as the
start of a boundary edge.  Otherwise, the vertex is marked as the start
of a nonboundary edge.  @code{glEdgeFlag} sets the edge flag bit to
@code{GL_TRUE} if @var{flag} is @code{GL_TRUE} and to @code{GL_FALSE}
otherwise.

The vertices of connected triangles and connected quadrilaterals are
always marked as boundary, regardless of the value of the edge flag.

Boundary and nonboundary edge flags on vertices are significant only if
@code{GL_POLYGON_MODE} is set to @code{GL_POINT} or @code{GL_LINE}.  See
@code{glPolygonMode}.

@end deftypefun

@deftypefun void glEnableClientState cap
@deftypefunx void glDisableClientState cap
Enable or disable client-side capability.

@table @asis
@item @var{cap}
Specifies the capability to enable.  Symbolic constants
@code{GL_COLOR_ARRAY}, @code{GL_EDGE_FLAG_ARRAY},
@code{GL_FOG_COORD_ARRAY}, @code{GL_INDEX_ARRAY},
@code{GL_NORMAL_ARRAY}, @code{GL_SECONDARY_COLOR_ARRAY},
@code{GL_TEXTURE_COORD_ARRAY}, and @code{GL_VERTEX_ARRAY} are accepted.

@end table

@code{glEnableClientState} and @code{glDisableClientState} enable or
disable individual client-side capabilities.  By default, all
client-side capabilities are disabled.  Both @code{glEnableClientState}
and @code{glDisableClientState} take a single argument, @var{cap}, which
can assume one of the following values:

@table @asis
@item @code{GL_COLOR_ARRAY}
If enabled, the color array is enabled for writing and used during
rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glColorPointer}.

@item @code{GL_EDGE_FLAG_ARRAY}
If enabled, the edge flag array is enabled for writing and used during
rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glEdgeFlagPointer}.

@item @code{GL_FOG_COORD_ARRAY}
If enabled, the fog coordinate array is enabled for writing and used
during rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glFogCoordPointer}.

@item @code{GL_INDEX_ARRAY}
If enabled, the index array is enabled for writing and used during
rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glIndexPointer}.

@item @code{GL_NORMAL_ARRAY}
If enabled, the normal array is enabled for writing and used during
rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glNormalPointer}.

@item @code{GL_SECONDARY_COLOR_ARRAY}
If enabled, the secondary color array is enabled for writing and used
during rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glColorPointer}.

@item @code{GL_TEXTURE_COORD_ARRAY}
If enabled, the texture coordinate array is enabled for writing and used
during rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glTexCoordPointer}.

@item @code{GL_VERTEX_ARRAY}
If enabled, the vertex array is enabled for writing and used during
rendering when @code{glArrayElement}, @code{glDrawArrays},
@code{glDrawElements},
@code{glDrawRangeElements}@code{glMultiDrawArrays}, or
@code{glMultiDrawElements} is called.  See @code{glVertexPointer}.

@end table

@code{GL_INVALID_ENUM} is generated if @var{cap} is not an accepted
value.

@code{glEnableClientState} is not allowed between the execution of
@code{glBegin} and the corresponding @code{glEnd}, but an error may or
may not be generated.  If no error is generated, the behavior is
undefined.

@end deftypefun

@deftypefun void glEnableVertexAttribArray index
@deftypefunx void glDisableVertexAttribArray index
Enable or disable a generic vertex attribute array.

@table @asis
@item @var{index}
Specifies the index of the generic vertex attribute to be enabled or
disabled.

@end table

@code{glEnableVertexAttribArray} enables the generic vertex attribute
array specified by @var{index}.  @code{glDisableVertexAttribArray}
disables the generic vertex attribute array specified by @var{index}.  By
default, all client-side capabilities are disabled, including all
generic vertex attribute arrays.  If enabled, the values in the generic
vertex attribute array will be accessed and used for rendering when
calls are made to vertex array commands such as @code{glDrawArrays},
@code{glDrawElements}, @code{glDrawRangeElements},
@code{glArrayElement}, @code{glMultiDrawElements}, or
@code{glMultiDrawArrays}.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to @code{GL_MAX_VERTEX_ATTRIBS}.

@code{GL_INVALID_OPERATION} is generated if either
@code{glEnableVertexAttribArray } or @code{glDisableVertexAttribArray }
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glEnable cap
@deftypefunx void glDisable cap
Enable or disable server-side GL capabilities.

@table @asis
@item @var{cap}
Specifies a symbolic constant indicating a GL capability.

@end table

@code{glEnable} and @code{glDisable} enable and disable various
capabilities.  Use @code{glIsEnabled} or @code{glGet} to determine the
current setting of any capability.  The initial value for each
capability with the exception of @code{GL_DITHER} and
@code{GL_MULTISAMPLE} is @code{GL_FALSE}.  The initial value for
@code{GL_DITHER} and @code{GL_MULTISAMPLE} is @code{GL_TRUE}.

Both @code{glEnable} and @code{glDisable} take a single argument,
@var{cap}, which can assume one of the following values:

@table @asis
@item @code{GL_ALPHA_TEST}


If enabled, do alpha testing.  See @code{glAlphaFunc}.

@item @code{GL_AUTO_NORMAL}


If enabled, generate normal vectors when either @code{GL_MAP2_VERTEX_3}
or @code{GL_MAP2_VERTEX_4} is used to generate vertices.  See
@code{glMap2}.

@item @code{GL_BLEND}


If enabled, blend the computed fragment color values with the values in
the color buffers.  See @code{glBlendFunc}.

@item @code{GL_CLIP_PLANE}@var{i}


If enabled, clip geometry against user-defined clipping plane @var{i}.
See @code{glClipPlane}.

@item @code{GL_COLOR_LOGIC_OP}


If enabled, apply the currently selected logical operation to the
computed fragment color and color buffer values.  See @code{glLogicOp}.

@item @code{GL_COLOR_MATERIAL}


If enabled, have one or more material parameters track the current
color.  See @code{glColorMaterial}.

@item @code{GL_COLOR_SUM}


If enabled and no fragment shader is active, add the secondary color
value to the computed fragment color.  See @code{glSecondaryColor}.

@item @code{GL_COLOR_TABLE}


If enabled, perform a color table lookup on the incoming RGBA color
values.  See @code{glColorTable}.

@item @code{GL_CONVOLUTION_1D}


If enabled, perform a 1D convolution operation on incoming RGBA color
values.  See @code{glConvolutionFilter1D}.

@item @code{GL_CONVOLUTION_2D}


If enabled, perform a 2D convolution operation on incoming RGBA color
values.  See @code{glConvolutionFilter2D}.

@item @code{GL_CULL_FACE}


If enabled, cull polygons based on their winding in window coordinates.
See @code{glCullFace}.

@item @code{GL_DEPTH_TEST}


If enabled, do depth comparisons and update the depth buffer.  Note that
even if the depth buffer exists and the depth mask is non-zero, the
depth buffer is not updated if the depth test is disabled.  See
@code{glDepthFunc} and @code{glDepthRange}.

@item @code{GL_DITHER}


If enabled, dither color components or indices before they are written
to the color buffer.

@item @code{GL_FOG}


If enabled and no fragment shader is active, blend a fog color into the
post-texturing color.  See @code{glFog}.

@item @code{GL_HISTOGRAM}


If enabled, histogram incoming RGBA color values.  See
@code{glHistogram}.

@item @code{GL_INDEX_LOGIC_OP}


If enabled, apply the currently selected logical operation to the
incoming index and color buffer indices.  See @code{glLogicOp}.

@item @code{GL_LIGHT}@var{i}


If enabled, include light @var{i} in the evaluation of the lighting
equation.  See @code{glLightModel} and @code{glLight}.

@item @code{GL_LIGHTING}


If enabled and no vertex shader is active, use the current lighting
parameters to compute the vertex color or index.  Otherwise, simply
associate the current color or index with each vertex.  See
@code{glMaterial}, @code{glLightModel}, and @code{glLight}.

@item @code{GL_LINE_SMOOTH}


If enabled, draw lines with correct filtering.  Otherwise, draw aliased
lines.  See @code{glLineWidth}.

@item @code{GL_LINE_STIPPLE}


If enabled, use the current line stipple pattern when drawing lines.  See
@code{glLineStipple}.

@item @code{GL_MAP1_COLOR_4}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate RGBA values.  See @code{glMap1}.

@item @code{GL_MAP1_INDEX}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate color indices.  See @code{glMap1}.

@item @code{GL_MAP1_NORMAL}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate normals.  See @code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_1}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate @var{s} texture coordinates.  See
@code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_2}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate @var{s} and @var{t} texture coordinates.
See @code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_3}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate @var{s}, @var{t}, and @var{r} texture
coordinates.  See @code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_4}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate @var{s}, @var{t}, @var{r}, and @var{q}
texture coordinates.  See @code{glMap1}.

@item @code{GL_MAP1_VERTEX_3}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate @var{x}, @var{y}, and @var{z} vertex
coordinates.  See @code{glMap1}.

@item @code{GL_MAP1_VERTEX_4}


If enabled, calls to @code{glEvalCoord1}, @code{glEvalMesh1}, and
@code{glEvalPoint1} generate homogeneous @var{x}, @var{y}, @var{z}, and
@var{w} vertex coordinates.  See @code{glMap1}.

@item @code{GL_MAP2_COLOR_4}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate RGBA values.  See @code{glMap2}.

@item @code{GL_MAP2_INDEX}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate color indices.  See @code{glMap2}.

@item @code{GL_MAP2_NORMAL}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate normals.  See @code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_1}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate @var{s} texture coordinates.  See
@code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_2}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate @var{s} and @var{t} texture coordinates.
See @code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_3}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate @var{s}, @var{t}, and @var{r} texture
coordinates.  See @code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_4}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate @var{s}, @var{t}, @var{r}, and @var{q}
texture coordinates.  See @code{glMap2}.

@item @code{GL_MAP2_VERTEX_3}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate @var{x}, @var{y}, and @var{z} vertex
coordinates.  See @code{glMap2}.

@item @code{GL_MAP2_VERTEX_4}


If enabled, calls to @code{glEvalCoord2}, @code{glEvalMesh2}, and
@code{glEvalPoint2} generate homogeneous @var{x}, @var{y}, @var{z}, and
@var{w} vertex coordinates.  See @code{glMap2}.

@item @code{GL_MINMAX}


If enabled, compute the minimum and maximum values of incoming RGBA
color values.  See @code{glMinmax}.

@item @code{GL_MULTISAMPLE}


If enabled, use multiple fragment samples in computing the final color
of a pixel.  See @code{glSampleCoverage}.

@item @code{GL_NORMALIZE}


If enabled and no vertex shader is active, normal vectors are normalized
to unit length after transformation and before lighting.  This method is
generally less efficient than @code{GL_RESCALE_NORMAL}.  See
@code{glNormal} and @code{glNormalPointer}.

@item @code{GL_POINT_SMOOTH}


If enabled, draw points with proper filtering.  Otherwise, draw aliased
points.  See @code{glPointSize}.

@item @code{GL_POINT_SPRITE}


If enabled, calculate texture coordinates for points based on texture
environment and point parameter settings.  Otherwise texture coordinates
are constant across points.

@item @code{GL_POLYGON_OFFSET_FILL}


If enabled, and if the polygon is rendered in @code{GL_FILL} mode, an
offset is added to depth values of a polygon's fragments before the
depth comparison is performed.  See @code{glPolygonOffset}.

@item @code{GL_POLYGON_OFFSET_LINE}


If enabled, and if the polygon is rendered in @code{GL_LINE} mode, an
offset is added to depth values of a polygon's fragments before the
depth comparison is performed.  See @code{glPolygonOffset}.

@item @code{GL_POLYGON_OFFSET_POINT}


If enabled, an offset is added to depth values of a polygon's fragments
before the depth comparison is performed, if the polygon is rendered in
@code{GL_POINT} mode.  See @code{glPolygonOffset}.

@item @code{GL_POLYGON_SMOOTH}


If enabled, draw polygons with proper filtering.  Otherwise, draw
aliased polygons.  For correct antialiased polygons, an alpha buffer is
needed and the polygons must be sorted front to back.

@item @code{GL_POLYGON_STIPPLE}


If enabled, use the current polygon stipple pattern when rendering
polygons.  See @code{glPolygonStipple}.

@item @code{GL_POST_COLOR_MATRIX_COLOR_TABLE}


If enabled, perform a color table lookup on RGBA color values after
color matrix transformation.  See @code{glColorTable}.

@item @code{GL_POST_CONVOLUTION_COLOR_TABLE}


If enabled, perform a color table lookup on RGBA color values after
convolution.  See @code{glColorTable}.

@item @code{GL_RESCALE_NORMAL}


If enabled and no vertex shader is active, normal vectors are scaled
after transformation and before lighting by a factor computed from the
modelview matrix.  If the modelview matrix scales space uniformly, this
has the effect of restoring the transformed normal to unit length.  This
method is generally more efficient than @code{GL_NORMALIZE}.  See
@code{glNormal} and @code{glNormalPointer}.

@item @code{GL_SAMPLE_ALPHA_TO_COVERAGE}


If enabled, compute a temporary coverage value where each bit is
determined by the alpha value at the corresponding sample location.  The
temporary coverage value is then ANDed with the fragment coverage value.

@item @code{GL_SAMPLE_ALPHA_TO_ONE}


If enabled, each sample alpha value is replaced by the maximum
representable alpha value.

@item @code{GL_SAMPLE_COVERAGE}


If enabled, the fragment's coverage is ANDed with the temporary coverage
value.  If @code{GL_SAMPLE_COVERAGE_INVERT} is set to @code{GL_TRUE},
invert the coverage value.  See @code{glSampleCoverage}.

@item @code{GL_SEPARABLE_2D}


If enabled, perform a two-dimensional convolution operation using a
separable convolution filter on incoming RGBA color values.  See
@code{glSeparableFilter2D}.

@item @code{GL_SCISSOR_TEST}


If enabled, discard fragments that are outside the scissor rectangle.
See @code{glScissor}.

@item @code{GL_STENCIL_TEST}


If enabled, do stencil testing and update the stencil buffer.  See
@code{glStencilFunc} and @code{glStencilOp}.

@item @code{GL_TEXTURE_1D}


If enabled and no fragment shader is active, one-dimensional texturing
is performed (unless two- or three-dimensional or cube-mapped texturing
is also enabled).  See @code{glTexImage1D}.

@item @code{GL_TEXTURE_2D}


If enabled and no fragment shader is active, two-dimensional texturing
is performed (unless three-dimensional or cube-mapped texturing is also
enabled).  See @code{glTexImage2D}.

@item @code{GL_TEXTURE_3D}


If enabled and no fragment shader is active, three-dimensional texturing
is performed (unless cube-mapped texturing is also enabled).  See
@code{glTexImage3D}.

@item @code{GL_TEXTURE_CUBE_MAP}


If enabled and no fragment shader is active, cube-mapped texturing is
performed.  See @code{glTexImage2D}.

@item @code{GL_TEXTURE_GEN_Q}


If enabled and no vertex shader is active, the @var{q} texture
coordinate is computed using the texture generation function defined
with @code{glTexGen}.  Otherwise, the current @var{q} texture coordinate
is used.  See @code{glTexGen}.

@item @code{GL_TEXTURE_GEN_R}


If enabled and no vertex shader is active, the @var{r} texture
coordinate is computed using the texture generation function defined
with @code{glTexGen}.  Otherwise, the current @var{r} texture coordinate
is used.  See @code{glTexGen}.

@item @code{GL_TEXTURE_GEN_S}


If enabled and no vertex shader is active, the @var{s} texture
coordinate is computed using the texture generation function defined
with @code{glTexGen}.  Otherwise, the current @var{s} texture coordinate
is used.  See @code{glTexGen}.

@item @code{GL_TEXTURE_GEN_T}


If enabled and no vertex shader is active, the @var{t} texture
coordinate is computed using the texture generation function defined
with @code{glTexGen}.  Otherwise, the current @var{t} texture coordinate
is used.  See @code{glTexGen}.

@item @code{GL_VERTEX_PROGRAM_POINT_SIZE}


If enabled and a vertex shader is active, then the derived point size is
taken from the (potentially clipped) shader builtin @code{gl_PointSize}
and clamped to the implementation-dependent point size range.

@item @code{GL_VERTEX_PROGRAM_TWO_SIDE}


If enabled and a vertex shader is active, it specifies that the GL will
choose between front and back colors based on the polygon's face
direction of which the vertex being shaded is a part.  It has no effect
on points or lines.

@end table

@code{GL_INVALID_ENUM} is generated if @var{cap} is not one of the
values listed previously.

@code{GL_INVALID_OPERATION} is generated if @code{glEnable} or
@code{glDisable} is executed between the execution of @code{glBegin} and
the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glEvalCoord1f u
@deftypefunx void glEvalCoord1d u
@deftypefunx void glEvalCoord2f u v
@deftypefunx void glEvalCoord2d u v
@deftypefunx void glEvalCoord1fv u
@deftypefunx void glEvalCoord1dv u
@deftypefunx void glEvalCoord2fv u
@deftypefunx void glEvalCoord2dv u
Evaluate enabled one- and two-dimensional maps.

@table @asis
@item @var{u}
Specifies a value that is the domain coordinate @r{@var{u}} to the basis
function defined in a previous @code{glMap1} or @code{glMap2} command.

@item @var{v}
Specifies a value that is the domain coordinate @r{@var{v}} to the basis
function defined in a previous @code{glMap2} command.  This argument is
not present in a @code{glEvalCoord1} command.

@end table

@code{glEvalCoord1} evaluates enabled one-dimensional maps at argument
@var{u}.  @code{glEvalCoord2} does the same for two-dimensional maps
using two domain values, @var{u} and @var{v}.  To define a map, call
@code{glMap1} and @code{glMap2}; to enable and disable it, call
@code{glEnable} and @code{glDisable}.

When one of the @code{glEvalCoord} commands is issued, all currently
enabled maps of the indicated dimension are evaluated.  Then, for each
enabled map, it is as if the corresponding GL command had been issued
with the computed value.  That is, if @code{GL_MAP1_INDEX} or
@code{GL_MAP2_INDEX} is enabled, a @code{glIndex} command is simulated.
If @code{GL_MAP1_COLOR_4} or @code{GL_MAP2_COLOR_4} is enabled, a
@code{glColor} command is simulated.  If @code{GL_MAP1_NORMAL} or
@code{GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if
any of @code{GL_MAP1_TEXTURE_COORD_1}, @code{GL_MAP1_TEXTURE_COORD_2},
@code{GL_MAP1_TEXTURE_COORD_3}, @code{GL_MAP1_TEXTURE_COORD_4},
@code{GL_MAP2_TEXTURE_COORD_1}, @code{GL_MAP2_TEXTURE_COORD_2},
@code{GL_MAP2_TEXTURE_COORD_3}, or @code{GL_MAP2_TEXTURE_COORD_4} is
enabled, then an appropriate @code{glTexCoord} command is simulated.

For color, color index, normal, and texture coordinates the GL uses
evaluated values instead of current values for those evaluations that
are enabled, and current values otherwise, However, the evaluated values
do not update the current values.  Thus, if @code{glVertex} commands are
interspersed with @code{glEvalCoord} commands, the color, normal, and
texture coordinates associated with the @code{glVertex} commands are not
affected by the values generated by the @code{glEvalCoord} commands, but
only by the most recent @code{glColor}, @code{glIndex}, @code{glNormal},
and @code{glTexCoord} commands.

No commands are issued for maps that are not enabled.  If more than one
texture evaluation is enabled for a particular dimension (for example,
@code{GL_MAP2_TEXTURE_COORD_1} and @code{GL_MAP2_TEXTURE_COORD_2}), then
only the evaluation of the map that produces the larger number of
coordinates (in this case, @code{GL_MAP2_TEXTURE_COORD_2}) is carried
out.  @code{GL_MAP1_VERTEX_4} overrides @code{GL_MAP1_VERTEX_3}, and
@code{GL_MAP2_VERTEX_4} overrides @code{GL_MAP2_VERTEX_3}, in the same
manner.  If neither a three- nor a four-component vertex map is enabled
for the specified dimension, the @code{glEvalCoord} command is ignored.

If you have enabled automatic normal generation, by calling
@code{glEnable} with argument @code{GL_AUTO_NORMAL}, @code{glEvalCoord2}
generates surface normals analytically, regardless of the contents or
enabling of the @code{GL_MAP2_NORMAL} map.  Let

@r{@code{m}=∂@code{p},/∂@var{u},,×∂@code{p},/∂@var{v},,}

Then the generated normal @r{@code{n}} is
@r{@code{n}=@code{m}/∥@code{m},∥,}

If automatic normal generation is disabled, the corresponding normal map
@code{GL_MAP2_NORMAL}, if enabled, is used to produce a normal.  If
neither automatic normal generation nor a normal map is enabled, no
normal is generated for @code{glEvalCoord2} commands.

@end deftypefun

@deftypefun void glEvalMesh1 mode i1 i2
@deftypefunx void glEvalMesh2 mode i1 i2 j1 j2
Compute a one- or two-dimensional grid of points or lines.

@table @asis
@item @var{mode}
In @code{glEvalMesh1}, specifies whether to compute a one-dimensional
mesh of points or lines.  Symbolic constants @code{GL_POINT} and
@code{GL_LINE} are accepted.

@item @var{i1}
@itemx @var{i2}
Specify the first and last integer values for grid domain variable
@r{@var{i}}.

@end table

@code{glMapGrid} and @code{glEvalMesh} are used in tandem to efficiently
generate and evaluate a series of evenly-spaced map domain values.
@code{glEvalMesh} steps through the integer domain of a one- or
two-dimensional grid, whose range is the domain of the evaluation maps
specified by @code{glMap1} and @code{glMap2}.  @var{mode} determines
whether the resulting vertices are connected as points, lines, or filled
polygons.

In the one-dimensional case, @code{glEvalMesh1}, the mesh is generated
as if the following code fragment were executed:

where

@example 

glBegin( @var{type} );
for ( i = @var{i1}; i <= @var{i2}; i += 1 )
   glEvalCoord1( @r{i·Δ@var{u}+@var{u}_1} );
glEnd(); 
@end example

@r{Δ@var{u}=(@var{u}_2-@var{u}_1,)/@var{n}}

and @r{@var{n}}, @r{@var{u}_1}, and @r{@var{u}_2} are the arguments to
the most recent @code{glMapGrid1} command.  @var{type} is
@code{GL_POINTS} if @var{mode} is @code{GL_POINT}, or @code{GL_LINES} if
@var{mode} is @code{GL_LINE}.

The one absolute numeric requirement is that if @r{@var{i}=@var{n}},
then the value computed from @r{@var{i}·Δ@var{u}+@var{u}_1} is exactly
@r{@var{u}_2}.

In the two-dimensional case, @code{glEvalMesh2}, let .cp
@r{Δ@var{u}=(@var{u}_2-@var{u}_1,)/@var{n}}

@r{Δ@var{v}=(@var{v}_2-@var{v}_1,)/@var{m}}

where @r{@var{n}}, @r{@var{u}_1}, @r{@var{u}_2}, @r{@var{m}},
@r{@var{v}_1}, and @r{@var{v}_2} are the arguments to the most recent
@code{glMapGrid2} command.  Then, if @var{mode} is @code{GL_FILL}, the
@code{glEvalMesh2} command is equivalent to:



@example 

for ( j = @var{j1}; j < @var{j2}; j += 1 ) @{
   glBegin( GL_QUAD_STRIP );
   for ( i = @var{i1}; i <= @var{i2}; i += 1 ) @{
      glEvalCoord2( @r{i·Δ@var{u}+@var{u}_1,j·Δ@var{v}+@var{v}_1} );
      glEvalCoord2( @r{i·Δ@var{u}+@var{u}_1,(j+1,)·Δ@var{v}+@var{v}_1} );
   @}
   glEnd();
@} 
@end example

If @var{mode} is @code{GL_LINE}, then a call to @code{glEvalMesh2} is
equivalent to:



@example 

for ( j = @var{j1}; j <= @var{j2}; j += 1 ) @{
   glBegin( GL_LINE_STRIP );
   for ( i = @var{i1}; i <= @var{i2}; i += 1 )
      glEvalCoord2( @r{i·Δ@var{u}+@var{u}_1,j·Δ@var{v}+@var{v}_1} );
   glEnd();
@}

for ( i = @var{i1};  i <= @var{i2}; i += 1 ) @{
   glBegin( GL_LINE_STRIP );
   for ( j = @var{j1}; j <= @var{j1}; j += 1 )
      glEvalCoord2( @r{i·Δ@var{u}+@var{u}_1,j·Δ@var{v}+@var{v}_1} );
   glEnd();
@} 
@end example

And finally, if @var{mode} is @code{GL_POINT}, then a call to
@code{glEvalMesh2} is equivalent to:



@example 

glBegin( GL_POINTS );
for ( j = @var{j1}; j <= @var{j2}; j += 1 )
   for ( i = @var{i1}; i <= @var{i2}; i += 1 )
      glEvalCoord2( @r{i·Δ@var{u}+@var{u}_1,j·Δ@var{v}+@var{v}_1} );
glEnd(); 
@end example

In all three cases, the only absolute numeric requirements are that if
@r{@var{i}=@var{n}}, then the value computed from
@r{@var{i}·Δ@var{u}+@var{u}_1} is exactly @r{@var{u}_2}, and if
@r{@var{j}=@var{m}}, then the value computed from
@r{@var{j}·Δ@var{v}+@var{v}_1} is exactly @r{@var{v}_2}.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glEvalMesh} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glEvalPoint1 i
@deftypefunx void glEvalPoint2 i j
Generate and evaluate a single point in a mesh.

@table @asis
@item @var{i}
Specifies the integer value for grid domain variable @r{@var{i}}.

@item @var{j}
Specifies the integer value for grid domain variable @r{@var{j}}
(@code{glEvalPoint2} only).

@end table

@code{glMapGrid} and @code{glEvalMesh} are used in tandem to efficiently
generate and evaluate a series of evenly spaced map domain values.
@code{glEvalPoint} can be used to evaluate a single grid point in the
same gridspace that is traversed by @code{glEvalMesh}.  Calling
@code{glEvalPoint1} is equivalent to calling where
@r{Δ@var{u}=(@var{u}_2-@var{u}_1,)/@var{n}}

@example 

glEvalCoord1( @r{i·Δ@var{u}+@var{u}_1} ); 
@end example

and @r{@var{n}}, @r{@var{u}_1}, and @r{@var{u}_2} are the arguments to
the most recent @code{glMapGrid1} command.  The one absolute numeric
requirement is that if @r{@var{i}=@var{n}}, then the value computed from
@r{@var{i}·Δ@var{u}+@var{u}_1} is exactly @r{@var{u}_2}.

In the two-dimensional case, @code{glEvalPoint2}, let

@r{Δ@var{u}=(@var{u}_2-@var{u}_1,)/@var{n}}@r{Δ@var{v}=(@var{v}_2-@var{v}_1,)/@var{m}}

where @r{@var{n}}, @r{@var{u}_1}, @r{@var{u}_2}, @r{@var{m}},
@r{@var{v}_1}, and @r{@var{v}_2} are the arguments to the most recent
@code{glMapGrid2} command.  Then the @code{glEvalPoint2} command is
equivalent to calling The only absolute numeric requirements are that if
@r{@var{i}=@var{n}}, then the value computed from
@r{@var{i}·Δ@var{u}+@var{u}_1} is exactly @r{@var{u}_2}, and if
@r{@var{j}=@var{m}}, then the value computed from
@r{@var{j}·Δ@var{v}+@var{v}_1} is exactly @r{@var{v}_2}.

@example 

glEvalCoord2( @r{i·Δ@var{u}+@var{u}_1,j·Δ@var{v}+@var{v}_1} ); 
@end example

@end deftypefun

@deftypefun void glFeedbackBuffer size type buffer
Controls feedback mode.

@table @asis
@item @var{size}
Specifies the maximum number of values that can be written into
@var{buffer}.

@item @var{type}
Specifies a symbolic constant that describes the information that will
be returned for each vertex.  @code{GL_2D}, @code{GL_3D},
@code{GL_3D_COLOR}, @code{GL_3D_COLOR_TEXTURE}, and
@code{GL_4D_COLOR_TEXTURE} are accepted.

@item @var{buffer}
Returns the feedback data.

@end table

The @code{glFeedbackBuffer} function controls feedback.  Feedback, like
selection, is a GL mode.  The mode is selected by calling
@code{glRenderMode} with @code{GL_FEEDBACK}.  When the GL is in feedback
mode, no pixels are produced by rasterization.  Instead, information
about primitives that would have been rasterized is fed back to the
application using the GL.

@code{glFeedbackBuffer} has three arguments: @var{buffer} is a pointer
to an array of floating-point values into which feedback information is
placed.  @var{size} indicates the size of the array.  @var{type} is a
symbolic constant describing the information that is fed back for each
vertex.  @code{glFeedbackBuffer} must be issued before feedback mode is
enabled (by calling @code{glRenderMode} with argument
@code{GL_FEEDBACK}).  Setting @code{GL_FEEDBACK} without establishing
the feedback buffer, or calling @code{glFeedbackBuffer} while the GL is
in feedback mode, is an error.

When @code{glRenderMode} is called while in feedback mode, it returns
the number of entries placed in the feedback array and resets the
feedback array pointer to the base of the feedback buffer.  The returned
value never exceeds @var{size}.  If the feedback data required more room
than was available in @var{buffer}, @code{glRenderMode} returns a
negative value.  To take the GL out of feedback mode, call
@code{glRenderMode} with a parameter value other than
@code{GL_FEEDBACK}.

While in feedback mode, each primitive, bitmap, or pixel rectangle that
would be rasterized generates a block of values that are copied into the
feedback array.  If doing so would cause the number of entries to exceed
the maximum, the block is partially written so as to fill the array (if
there is any room left at all), and an overflow flag is set.  Each block
begins with a code indicating the primitive type, followed by values
that describe the primitive's vertices and associated data.  Entries are
also written for bitmaps and pixel rectangles.  Feedback occurs after
polygon culling and @code{glPolygonMode} interpretation of polygons has
taken place, so polygons that are culled are not returned in the
feedback buffer.  It can also occur after polygons with more than three
edges are broken up into triangles, if the GL implementation renders
polygons by performing this decomposition.

The @code{glPassThrough} command can be used to insert a marker into the
feedback buffer.  See @code{glPassThrough}.

Following is the grammar for the blocks of values written into the
feedback buffer.  Each primitive is indicated with a unique identifying
value followed by some number of vertices.  Polygon entries include an
integer value indicating how many vertices follow.  A vertex is fed back
as some number of floating-point values, as determined by @var{type}.
Colors are fed back as four values in RGBA mode and one value in color
index mode.

feedbackList @r{←} feedbackItem feedbackList | feedbackItem feedbackItem
@r{←} point | lineSegment | polygon | bitmap | pixelRectangle | passThru
point @r{←}@code{GL_POINT_TOKEN} vertex lineSegment
@r{←}@code{GL_LINE_TOKEN} vertex vertex | @code{GL_LINE_RESET_TOKEN}
vertex vertex polygon @r{←}@code{GL_POLYGON_TOKEN} n polySpec polySpec
@r{←} polySpec vertex | vertex vertex vertex bitmap
@r{←}@code{GL_BITMAP_TOKEN} vertex pixelRectangle
@r{←}@code{GL_DRAW_PIXEL_TOKEN} vertex | @code{GL_COPY_PIXEL_TOKEN}
vertex passThru @r{←}@code{GL_PASS_THROUGH_TOKEN} value vertex @r{←} 2d
| 3d | 3dColor | 3dColorTexture | 4dColorTexture 2d @r{←} value value 3d
@r{←} value value value 3dColor @r{←} value value value color
3dColorTexture @r{←} value value value color tex 4dColorTexture @r{←}
value value value value color tex color @r{←} rgba | index rgba @r{←}
value value value value index @r{←} value tex @r{←} value value value
value

@var{value} is a floating-point number, and @var{n} is a floating-point
integer giving the number of vertices in the polygon.
@code{GL_POINT_TOKEN}, @code{GL_LINE_TOKEN}, @code{GL_LINE_RESET_TOKEN},
@code{GL_POLYGON_TOKEN}, @code{GL_BITMAP_TOKEN},
@code{GL_DRAW_PIXEL_TOKEN}, @code{GL_COPY_PIXEL_TOKEN} and
@code{GL_PASS_THROUGH_TOKEN} are symbolic floating-point constants.
@code{GL_LINE_RESET_TOKEN} is returned whenever the line stipple pattern
is reset.  The data returned as a vertex depends on the feedback
@var{type}.

The following table gives the correspondence between @var{type} and the
number of values per vertex.  @var{k} is 1 in color index mode and 4 in
RGBA mode.



@table @asis
@item @strong{Type}
@strong{Coordinates}, @strong{Color}, @strong{Texture}, @strong{Total
Number of Values}

@item @code{GL_2D}
@var{x}, @var{y}, , , 2

@item @code{GL_3D}
@var{x}, @var{y}, @var{z}, , , 3

@item @code{GL_3D_COLOR}
@var{x}, @var{y}, @var{z}, @r{@var{k}}, , @r{3+@var{k}}

@item @code{GL_3D_COLOR_TEXTURE}
@var{x}, @var{y}, @var{z}, @r{@var{k}}, 4 , @r{7+@var{k}}

@item @code{GL_4D_COLOR_TEXTURE}
@var{x}, @var{y}, @var{z}, @var{w}, @r{@var{k}}, 4 , @r{8+@var{k}}

@end table

Feedback vertex coordinates are in window coordinates, except @var{w},
which is in clip coordinates.  Feedback colors are lighted, if lighting
is enabled.  Feedback texture coordinates are generated, if texture
coordinate generation is enabled.  They are always transformed by the
texture matrix.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{size} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glFeedbackBuffer} is
called while the render mode is @code{GL_FEEDBACK}, or if
@code{glRenderMode} is called with argument @code{GL_FEEDBACK} before
@code{glFeedbackBuffer} is called at least once.

@code{GL_INVALID_OPERATION} is generated if @code{glFeedbackBuffer} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glFinish 
Block until all GL execution is complete.

@code{glFinish} does not return until the effects of all previously
called GL commands are complete.  Such effects include all changes to GL
state, all changes to connection state, and all changes to the frame
buffer contents.

@code{GL_INVALID_OPERATION} is generated if @code{glFinish} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glFlush 
Force execution of GL commands in finite time.

Different GL implementations buffer commands in several different
locations, including network buffers and the graphics accelerator
itself.  @code{glFlush} empties all of these buffers, causing all issued
commands to be executed as quickly as they are accepted by the actual
rendering engine.  Though this execution may not be completed in any
particular time period, it does complete in finite time.

Because any GL program might be executed over a network, or on an
accelerator that buffers commands, all programs should call
@code{glFlush} whenever they count on having all of their previously
issued commands completed.  For example, call @code{glFlush} before
waiting for user input that depends on the generated image.

@code{GL_INVALID_OPERATION} is generated if @code{glFlush} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glFogCoordPointer type stride pointer
Define an array of fog coordinates.

@table @asis
@item @var{type}
Specifies the data type of each fog coordinate.  Symbolic constants
@code{GL_FLOAT}, or @code{GL_DOUBLE} are accepted.  The initial value is
@code{GL_FLOAT}.

@item @var{stride}
Specifies the byte offset between consecutive fog coordinates.  If
@var{stride} is 0, the array elements are understood to be tightly
packed.  The initial value is 0.

@item @var{pointer}
Specifies a pointer to the first coordinate of the first fog coordinate
in the array.  The initial value is 0.

@end table

@code{glFogCoordPointer} specifies the location and data format of an
array of fog coordinates to use when rendering.  @var{type} specifies
the data type of each fog coordinate, and @var{stride} specifies the
byte stride from one fog coordinate to the next, allowing vertices and
attributes to be packed into a single array or stored in separate
arrays.

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a fog coordinate array is
specified, @var{pointer} is treated as a byte offset into the buffer
object's data store.  Also, the buffer object binding
(@code{GL_ARRAY_BUFFER_BINDING}) is saved as fog coordinate vertex array
client-side state (@code{GL_FOG_COORD_ARRAY_BUFFER_BINDING}).

When a fog coordinate array is specified, @var{type}, @var{stride}, and
@var{pointer} are saved as client-side state, in addition to the current
vertex array buffer object binding.

To enable and disable the fog coordinate array, call
@code{glEnableClientState} and @code{glDisableClientState} with the
argument @code{GL_FOG_COORD_ARRAY}.  If enabled, the fog coordinate
array is used when @code{glDrawArrays}, @code{glMultiDrawArrays},
@code{glDrawElements}, @code{glMultiDrawElements},
@code{glDrawRangeElements}, or @code{glArrayElement} is called.

@code{GL_INVALID_ENUM} is generated if @var{type} is not either
@code{GL_FLOAT} or @code{GL_DOUBLE}.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glFogCoordd coord
@deftypefunx void glFogCoordf coord
@deftypefunx void glFogCoorddv coord
@deftypefunx void glFogCoordfv coord
Set the current fog coordinates.

@table @asis
@item @var{coord}
Specify the fog distance.

@end table

@code{glFogCoord} specifies the fog coordinate that is associated with
each vertex and the current raster position.  The value specified is
interpolated and used in computing the fog color (see @code{glFog}).

@end deftypefun

@deftypefun void glFogf pname param
@deftypefunx void glFogi pname param
@deftypefunx void glFogfv pname params
@deftypefunx void glFogiv pname params
Specify fog parameters.

@table @asis
@item @var{pname}
Specifies a single-valued fog parameter.  @code{GL_FOG_MODE},
@code{GL_FOG_DENSITY}, @code{GL_FOG_START}, @code{GL_FOG_END},
@code{GL_FOG_INDEX}, and @code{GL_FOG_COORD_SRC} are accepted.

@item @var{param}
Specifies the value that @var{pname} will be set to.

@end table

Fog is initially disabled.  While enabled, fog affects rasterized
geometry, bitmaps, and pixel blocks, but not buffer clear operations.  To
enable and disable fog, call @code{glEnable} and @code{glDisable} with
argument @code{GL_FOG}.

@code{glFog} assigns the value or values in @var{params} to the fog
parameter specified by @var{pname}.  The following values are accepted
for @var{pname}:

@table @asis
@item @code{GL_FOG_MODE}
@var{params} is a single integer or floating-point value that specifies
the equation to be used to compute the fog blend factor, @r{@var{f}}.
Three symbolic constants are accepted: @code{GL_LINEAR}, @code{GL_EXP},
and @code{GL_EXP2}.  The equations corresponding to these symbolic
constants are defined below.  The initial fog mode is @code{GL_EXP}.

@item @code{GL_FOG_DENSITY}
@var{params} is a single integer or floating-point value that specifies
@r{@var{density}}, the fog density used in both exponential fog
equations.  Only nonnegative densities are accepted.  The initial fog
density is 1.

@item @code{GL_FOG_START}
@var{params} is a single integer or floating-point value that specifies
@r{@var{start}}, the near distance used in the linear fog equation.  The
initial near distance is 0.

@item @code{GL_FOG_END}
@var{params} is a single integer or floating-point value that specifies
@r{@var{end}}, the far distance used in the linear fog equation.  The
initial far distance is 1.

@item @code{GL_FOG_INDEX}
@var{params} is a single integer or floating-point value that specifies
@r{@var{i}_@var{f}}, the fog color index.  The initial fog index is 0.

@item @code{GL_FOG_COLOR}
@var{params} contains four integer or floating-point values that specify
@r{@var{C}_@var{f}}, the fog color.  Integer values are mapped linearly
such that the most positive representable value maps to 1.0, and the
most negative representable value maps to @r{-1.0}.  Floating-point
values are mapped directly.  After conversion, all color components are
clamped to the range @r{[0,1]}.  The initial fog color is (0, 0, 0, 0).

@item @code{GL_FOG_COORD_SRC}
@var{params} contains either of the following symbolic constants:
@code{GL_FOG_COORD} or @code{GL_FRAGMENT_DEPTH}.  @code{GL_FOG_COORD}
specifies that the current fog coordinate should be used as distance
value in the fog color computation.  @code{GL_FRAGMENT_DEPTH} specifies
that the current fragment depth should be used as distance value in the
fog computation.

@end table

Fog blends a fog color with each rasterized pixel fragment's
post-texturing color using a blending factor @r{@var{f}}.  Factor
@r{@var{f}} is computed in one of three ways, depending on the fog mode.
Let @r{@var{c}} be either the distance in eye coordinate from the origin
(in the case that the @code{GL_FOG_COORD_SRC} is
@code{GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case
that @code{GL_FOG_COORD_SRC} is @code{GL_FOG_COORD}).  The equation for
@code{GL_LINEAR} fog is
@r{@var{f}=@var{end}-@var{c},/@var{end}-@var{start},}

The equation for @code{GL_EXP} fog is
@r{@var{f}=@var{e}^-(@var{density}·@var{c},),}

The equation for @code{GL_EXP2} fog is
@r{@var{f}=@var{e}^-(@var{density}·@var{c},),^2}

Regardless of the fog mode, @r{@var{f}} is clamped to the range
@r{[0,1]} after it is computed.  Then, if the GL is in RGBA color mode,
the fragment's red, green, and blue colors, represented by
@r{@var{C}_@var{r}}, are replaced by

@r{@var{C}_@var{r},^″=@var{f}×@var{C}_@var{r}+(1-@var{f},)×@var{C}_@var{f}}

Fog does not affect a fragment's alpha component.

In color index mode, the fragment's color index @r{@var{i}_@var{r}} is
replaced by

@r{@var{i}_@var{r},^″=@var{i}_@var{r}+(1-@var{f},)×@var{i}_@var{f}}



@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value, or if @var{pname} is @code{GL_FOG_MODE} and @var{params} is not
an accepted value.

@code{GL_INVALID_VALUE} is generated if @var{pname} is
@code{GL_FOG_DENSITY} and @var{params} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glFog} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glFrontFace mode
Define front- and back-facing polygons.

@table @asis
@item @var{mode}
Specifies the orientation of front-facing polygons.  @code{GL_CW} and
@code{GL_CCW} are accepted.  The initial value is @code{GL_CCW}.

@end table

In a scene composed entirely of opaque closed surfaces, back-facing
polygons are never visible.  Eliminating these invisible polygons has
the obvious benefit of speeding up the rendering of the image.  To
enable and disable elimination of back-facing polygons, call
@code{glEnable} and @code{glDisable} with argument @code{GL_CULL_FACE}.

The projection of a polygon to window coordinates is said to have
clockwise winding if an imaginary object following the path from its
first vertex, its second vertex, and so on, to its last vertex, and
finally back to its first vertex, moves in a clockwise direction about
the interior of the polygon.  The polygon's winding is said to be
counterclockwise if the imaginary object following the same path moves
in a counterclockwise direction about the interior of the polygon.
@code{glFrontFace} specifies whether polygons with clockwise winding in
window coordinates, or counterclockwise winding in window coordinates,
are taken to be front-facing.  Passing @code{GL_CCW} to @var{mode}
selects counterclockwise polygons as front-facing; @code{GL_CW} selects
clockwise polygons as front-facing.  By default, counterclockwise
polygons are taken to be front-facing.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glFrontFace} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glFrustum left right bottom top nearVal farVal
Multiply the current matrix by a perspective matrix.

@table @asis
@item @var{left}
@itemx @var{right}
Specify the coordinates for the left and right vertical clipping planes.

@item @var{bottom}
@itemx @var{top}
Specify the coordinates for the bottom and top horizontal clipping
planes.

@item @var{nearVal}
@itemx @var{farVal}
Specify the distances to the near and far depth clipping planes.  Both
distances must be positive.

@end table

@code{glFrustum} describes a perspective matrix that produces a
perspective projection.  The current matrix (see @code{glMatrixMode}) is
multiplied by this matrix and the result replaces the current matrix, as
if @code{glMultMatrix} were called with the following matrix as its
argument:



@r{[(2⁢@var{nearVal},/@var{right}-@var{left},, 0 @var{A} 0), (0
2⁢@var{nearVal},/@var{top}-@var{bottom},, @var{B} 0), (0 0 @var{C}
@var{D}), (0 0 -1 0),]}

@r{@var{A}=@var{right}+@var{left},/@var{right}-@var{left},}

@r{@var{B}=@var{top}+@var{bottom},/@var{top}-@var{bottom},}

@r{@var{C}=-@var{farVal}+@var{nearVal},/@var{farVal}-@var{nearVal},,}

@r{@var{D}=-2⁢@var{farVal}⁢@var{nearVal},/@var{farVal}-@var{nearVal},,}



Typically, the matrix mode is @code{GL_PROJECTION}, and
@r{(@var{left},@var{bottom}-@var{nearVal})} and
@r{(@var{right},@var{top}-@var{nearVal})} specify the points on the near
clipping plane that are mapped to the lower left and upper right corners
of the window, assuming that the eye is located at (0, 0, 0).
@r{-@var{farVal}} specifies the location of the far clipping plane.  Both
@var{nearVal} and @var{farVal} must be positive.

Use @code{glPushMatrix} and @code{glPopMatrix} to save and restore the
current matrix stack.

@code{GL_INVALID_VALUE} is generated if @var{nearVal} or @var{farVal} is
not positive, or if @var{left} = @var{right}, or @var{bottom} =
@var{top}, or @var{near} = @var{far}.

@code{GL_INVALID_OPERATION} is generated if @code{glFrustum} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glGenBuffers n buffers
Generate buffer object names.

@table @asis
@item @var{n}
Specifies the number of buffer object names to be generated.

@item @var{buffers}
Specifies an array in which the generated buffer object names are
stored.

@end table

@code{glGenBuffers} returns @var{n} buffer object names in
@var{buffers}.  There is no guarantee that the names form a contiguous
set of integers; however, it is guaranteed that none of the returned
names was in use immediately before the call to @code{glGenBuffers}.

Buffer object names returned by a call to @code{glGenBuffers} are not
returned by subsequent calls, unless they are first deleted with
@code{glDeleteBuffers}.

No buffer objects are associated with the returned buffer object names
until they are first bound by calling @code{glBindBuffer}.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glGenBuffers} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLuint glGenLists range
Generate a contiguous set of empty display lists.

@table @asis
@item @var{range}
Specifies the number of contiguous empty display lists to be generated.

@end table

@code{glGenLists} has one argument, @var{range}.  It returns an integer
@var{n} such that @var{range} contiguous empty display lists, named
@r{@var{n}}, @r{@var{n}+1}, @r{@var{...}}, @r{@var{n}+@var{range}-1},
are created.  If @var{range} is 0, if there is no group of @var{range}
contiguous names available, or if any error is generated, no display
lists are generated, and 0 is returned.

@code{GL_INVALID_VALUE} is generated if @var{range} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glGenLists} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGenQueries n ids
Generate query object names.

@table @asis
@item @var{n}
Specifies the number of query object names to be generated.

@item @var{ids}
Specifies an array in which the generated query object names are stored.

@end table

@code{glGenQueries} returns @var{n} query object names in @var{ids}.
There is no guarantee that the names form a contiguous set of integers;
however, it is guaranteed that none of the returned names was in use
immediately before the call to @code{glGenQueries}.

Query object names returned by a call to @code{glGenQueries} are not
returned by subsequent calls, unless they are first deleted with
@code{glDeleteQueries}.

No query objects are associated with the returned query object names
until they are first used by calling @code{glBeginQuery}.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glGenQueries} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGenTextures n textures
Generate texture names.

@table @asis
@item @var{n}
Specifies the number of texture names to be generated.

@item @var{textures}
Specifies an array in which the generated texture names are stored.

@end table

@code{glGenTextures} returns @var{n} texture names in @var{textures}.
There is no guarantee that the names form a contiguous set of integers;
however, it is guaranteed that none of the returned names was in use
immediately before the call to @code{glGenTextures}.

The generated textures have no dimensionality; they assume the
dimensionality of the texture target to which they are first bound (see
@code{glBindTexture}).

Texture names returned by a call to @code{glGenTextures} are not
returned by subsequent calls, unless they are first deleted with
@code{glDeleteTextures}.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glGenTextures} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetActiveAttrib program index bufSize length size type name
Returns information about an active attribute variable for the specified
program object.

@table @asis
@item @var{program}
Specifies the program object to be queried.

@item @var{index}
Specifies the index of the attribute variable to be queried.

@item @var{bufSize}
Specifies the maximum number of characters OpenGL is allowed to write in
the character buffer indicated by @var{name}.

@item @var{length}
Returns the number of characters actually written by OpenGL in the
string indicated by @var{name} (excluding the null terminator) if a
value other than @code{NULL} is passed.

@item @var{size}
Returns the size of the attribute variable.

@item @var{type}
Returns the data type of the attribute variable.

@item @var{name}
Returns a null terminated string containing the name of the attribute
variable.

@end table

@code{glGetActiveAttrib} returns information about an active attribute
variable in the program object specified by @var{program}.  The number
of active attributes can be obtained by calling @code{glGetProgram} with
the value @code{GL_ACTIVE_ATTRIBUTES}.  A value of 0 for @var{index}
selects the first active attribute variable.  Permissible values for
@var{index} range from 0 to the number of active attribute variables
minus 1.

A vertex shader may use either built-in attribute variables,
user-defined attribute variables, or both.  Built-in attribute variables
have a prefix of "gl_" and reference conventional OpenGL vertex
attribtes (e.g., @var{gl_Vertex}, @var{gl_Normal}, etc., see the OpenGL
Shading Language specification for a complete list.) User-defined
attribute variables have arbitrary names and obtain their values through
numbered generic vertex attributes.  An attribute variable (either
built-in or user-defined) is considered active if it is determined
during the link operation that it may be accessed during program
execution.  Therefore, @var{program} should have previously been the
target of a call to @code{glLinkProgram}, but it is not necessary for it
to have been linked successfully.

The size of the character buffer required to store the longest attribute
variable name in @var{program} can be obtained by calling
@code{glGetProgram} with the value
@code{GL_ACTIVE_ATTRIBUTE_MAX_LENGTH}.  This value should be used to
allocate a buffer of sufficient size to store the returned attribute
name.  The size of this character buffer is passed in @var{bufSize}, and
a pointer to this character buffer is passed in @var{name}.

@code{glGetActiveAttrib} returns the name of the attribute variable
indicated by @var{index}, storing it in the character buffer specified
by @var{name}.  The string returned will be null terminated.  The actual
number of characters written into this buffer is returned in
@var{length}, and this count does not include the null termination
character.  If the length of the returned string is not required, a
value of @code{NULL} can be passed in the @var{length} argument.

The @var{type} argument will return a pointer to the attribute
variable's data type.  The symbolic constants @code{GL_FLOAT},
@code{GL_FLOAT_VEC2}, @code{GL_FLOAT_VEC3}, @code{GL_FLOAT_VEC4},
@code{GL_FLOAT_MAT2}, @code{GL_FLOAT_MAT3}, @code{GL_FLOAT_MAT4},
@code{GL_FLOAT_MAT2x3}, @code{GL_FLOAT_MAT2x4}, @code{GL_FLOAT_MAT3x2},
@code{GL_FLOAT_MAT3x4}, @code{GL_FLOAT_MAT4x2}, or
@code{GL_FLOAT_MAT4x3} may be returned.  The @var{size} argument will
return the size of the attribute, in units of the type returned in
@var{type}.

The list of active attribute variables may include both built-in
attribute variables (which begin with the prefix "gl_") as well as
user-defined attribute variable names.

This function will return as much information as it can about the
specified active attribute variable.  If no information is available,
@var{length} will be 0, and @var{name} will be an empty string.  This
situation could occur if this function is called after a link operation
that failed.  If an error occurs, the return values @var{length},
@var{size}, @var{type}, and @var{name} will be unmodified.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to the number of active attribute variables in @var{program}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetActiveAttrib} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@code{GL_INVALID_VALUE} is generated if @var{bufSize} is less than 0.

@end deftypefun

@deftypefun void glGetActiveUniform program index bufSize length size type name
Returns information about an active uniform variable for the specified
program object.

@table @asis
@item @var{program}
Specifies the program object to be queried.

@item @var{index}
Specifies the index of the uniform variable to be queried.

@item @var{bufSize}
Specifies the maximum number of characters OpenGL is allowed to write in
the character buffer indicated by @var{name}.

@item @var{length}
Returns the number of characters actually written by OpenGL in the
string indicated by @var{name} (excluding the null terminator) if a
value other than @code{NULL} is passed.

@item @var{size}
Returns the size of the uniform variable.

@item @var{type}
Returns the data type of the uniform variable.

@item @var{name}
Returns a null terminated string containing the name of the uniform
variable.

@end table

@code{glGetActiveUniform} returns information about an active uniform
variable in the program object specified by @var{program}.  The number
of active uniform variables can be obtained by calling
@code{glGetProgram} with the value @code{GL_ACTIVE_UNIFORMS}.  A value
of 0 for @var{index} selects the first active uniform variable.
Permissible values for @var{index} range from 0 to the number of active
uniform variables minus 1.

Shaders may use either built-in uniform variables, user-defined uniform
variables, or both.  Built-in uniform variables have a prefix of "gl_"
and reference existing OpenGL state or values derived from such state
(e.g., @var{gl_Fog}, @var{gl_ModelViewMatrix}, etc., see the OpenGL
Shading Language specification for a complete list.) User-defined
uniform variables have arbitrary names and obtain their values from the
application through calls to @code{glUniform}.  A uniform variable
(either built-in or user-defined) is considered active if it is
determined during the link operation that it may be accessed during
program execution.  Therefore, @var{program} should have previously been
the target of a call to @code{glLinkProgram}, but it is not necessary
for it to have been linked successfully.

The size of the character buffer required to store the longest uniform
variable name in @var{program} can be obtained by calling
@code{glGetProgram} with the value @code{GL_ACTIVE_UNIFORM_MAX_LENGTH}.
This value should be used to allocate a buffer of sufficient size to
store the returned uniform variable name.  The size of this character
buffer is passed in @var{bufSize}, and a pointer to this character
buffer is passed in @var{name.}

@code{glGetActiveUniform} returns the name of the uniform variable
indicated by @var{index}, storing it in the character buffer specified
by @var{name}.  The string returned will be null terminated.  The actual
number of characters written into this buffer is returned in
@var{length}, and this count does not include the null termination
character.  If the length of the returned string is not required, a
value of @code{NULL} can be passed in the @var{length} argument.

The @var{type} argument will return a pointer to the uniform variable's
data type.  The symbolic constants @code{GL_FLOAT},
@code{GL_FLOAT_VEC2}, @code{GL_FLOAT_VEC3}, @code{GL_FLOAT_VEC4},
@code{GL_INT}, @code{GL_INT_VEC2}, @code{GL_INT_VEC3},
@code{GL_INT_VEC4}, @code{GL_BOOL}, @code{GL_BOOL_VEC2},
@code{GL_BOOL_VEC3}, @code{GL_BOOL_VEC4}, @code{GL_FLOAT_MAT2},
@code{GL_FLOAT_MAT3}, @code{GL_FLOAT_MAT4}, @code{GL_FLOAT_MAT2x3},
@code{GL_FLOAT_MAT2x4}, @code{GL_FLOAT_MAT3x2}, @code{GL_FLOAT_MAT3x4},
@code{GL_FLOAT_MAT4x2}, @code{GL_FLOAT_MAT4x3}, @code{GL_SAMPLER_1D},
@code{GL_SAMPLER_2D}, @code{GL_SAMPLER_3D}, @code{GL_SAMPLER_CUBE},
@code{GL_SAMPLER_1D_SHADOW}, or @code{GL_SAMPLER_2D_SHADOW} may be
returned.

If one or more elements of an array are active, the name of the array is
returned in @var{name}, the type is returned in @var{type}, and the
@var{size} parameter returns the highest array element index used, plus
one, as determined by the compiler and/or linker.  Only one active
uniform variable will be reported for a uniform array.

Uniform variables that are declared as structures or arrays of
structures will not be returned directly by this function.  Instead,
each of these uniform variables will be reduced to its fundamental
components containing the "." and "[]" operators such that each of the
names is valid as an argument to @code{glGetUniformLocation}.  Each of
these reduced uniform variables is counted as one active uniform
variable and is assigned an index.  A valid name cannot be a structure,
an array of structures, or a subcomponent of a vector or matrix.

The size of the uniform variable will be returned in @var{size}.  Uniform
variables other than arrays will have a size of 1.  Structures and
arrays of structures will be reduced as described earlier, such that
each of the names returned will be a data type in the earlier list.  If
this reduction results in an array, the size returned will be as
described for uniform arrays; otherwise, the size returned will be 1.

The list of active uniform variables may include both built-in uniform
variables (which begin with the prefix "gl_") as well as user-defined
uniform variable names.

This function will return as much information as it can about the
specified active uniform variable.  If no information is available,
@var{length} will be 0, and @var{name} will be an empty string.  This
situation could occur if this function is called after a link operation
that failed.  If an error occurs, the return values @var{length},
@var{size}, @var{type}, and @var{name} will be unmodified.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to the number of active uniform variables in @var{program}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetActiveUniform} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@code{GL_INVALID_VALUE} is generated if @var{bufSize} is less than 0.

@end deftypefun

@deftypefun void glGetAttachedShaders program maxCount count shaders
Returns the handles of the shader objects attached to a program object.

@table @asis
@item @var{program}
Specifies the program object to be queried.

@item @var{maxCount}
Specifies the size of the array for storing the returned object names.

@item @var{count}
Returns the number of names actually returned in @var{objects}.

@item @var{shaders}
Specifies an array that is used to return the names of attached shader
objects.

@end table

@code{glGetAttachedShaders} returns the names of the shader objects
attached to @var{program}.  The names of shader objects that are
attached to @var{program} will be returned in @var{shaders.} The actual
number of shader names written into @var{shaders} is returned in
@var{count.} If no shader objects are attached to @var{program},
@var{count} is set to 0.  The maximum number of shader names that may be
returned in @var{shaders} is specified by @var{maxCount}.

If the number of names actually returned is not required (for instance,
if it has just been obtained by calling @code{glGetProgram}), a value of
@code{NULL} may be passed for count.  If no shader objects are attached
to @var{program}, a value of 0 will be returned in @var{count}.  The
actual number of attached shaders can be obtained by calling
@code{glGetProgram} with the value @code{GL_ATTACHED_SHADERS}.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_VALUE} is generated if @var{maxCount} is less than 0.

@code{GL_INVALID_OPERATION} is generated if @code{glGetAttachedShaders}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun GLint glGetAttribLocation program name
Returns the location of an attribute variable.

@table @asis
@item @var{program}
Specifies the program object to be queried.

@item @var{name}
Points to a null terminated string containing the name of the attribute
variable whose location is to be queried.

@end table

@code{glGetAttribLocation} queries the previously linked program object
specified by @var{program} for the attribute variable specified by
@var{name} and returns the index of the generic vertex attribute that is
bound to that attribute variable.  If @var{name} is a matrix attribute
variable, the index of the first column of the matrix is returned.  If
the named attribute variable is not an active attribute in the specified
program object or if @var{name} starts with the reserved prefix "gl_", a
value of -1 is returned.

The association between an attribute variable name and a generic
attribute index can be specified at any time by calling
@code{glBindAttribLocation}.  Attribute bindings do not go into effect
until @code{glLinkProgram} is called.  After a program object has been
linked successfully, the index values for attribute variables remain
fixed until the next link command occurs.  The attribute values can only
be queried after a link if the link was successful.
@code{glGetAttribLocation} returns the binding that actually went into
effect the last time @code{glLinkProgram} was called for the specified
program object.  Attribute bindings that have been specified since the
last link operation are not returned by @code{glGetAttribLocation}.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @var{program} has not been
successfully linked.

@code{GL_INVALID_OPERATION} is generated if @code{glGetAttribLocation}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetBufferParameteriv target value data
Return parameters of a buffer object.

@table @asis
@item @var{target}
Specifies the target buffer object.  The symbolic constant must be
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@item @var{value}
Specifies the symbolic name of a buffer object parameter.  Accepted
values are @code{GL_BUFFER_ACCESS}, @code{GL_BUFFER_MAPPED},
@code{GL_BUFFER_SIZE}, or @code{GL_BUFFER_USAGE}.

@item @var{data}
Returns the requested parameter.

@end table

@code{glGetBufferParameteriv} returns in @var{data} a selected parameter
of the buffer object specified by @var{target}.

@var{value} names a specific buffer object parameter, as follows:

@table @asis
@item @code{GL_BUFFER_ACCESS}
@var{params} returns the access policy set while mapping the buffer
object.  The initial value is @code{GL_READ_WRITE}.

@item @code{GL_BUFFER_MAPPED}
@var{params} returns a flag indicating whether the buffer object is
currently mapped.  The initial value is @code{GL_FALSE}.

@item @code{GL_BUFFER_SIZE}
@var{params} returns the size of the buffer object, measured in bytes.
The initial value is 0.

@item @code{GL_BUFFER_USAGE}
@var{params} returns the buffer object's usage pattern.  The initial
value is @code{GL_STATIC_DRAW}.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{value} is
not an accepted value.

@code{GL_INVALID_OPERATION} is generated if the reserved buffer object
name 0 is bound to @var{target}.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetBufferParameteriv} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetBufferPointerv target pname params
Return the pointer to a mapped buffer object's data store.

@table @asis
@item @var{target}
Specifies the target buffer object.  The symbolic constant must be
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@item @var{pname}
Specifies the pointer to be returned.  The symbolic constant must be
@code{GL_BUFFER_MAP_POINTER}.

@item @var{params}
Returns the pointer value specified by @var{pname}.

@end table

@code{glGetBufferPointerv} returns pointer information.  @var{pname} is
a symbolic constant indicating the pointer to be returned, which must be
@code{GL_BUFFER_MAP_POINTER}, the pointer to which the buffer object's
data store is mapped.  If the data store is not currently mapped,
@code{NULL} is returned.  @var{params} is a pointer to a location in
which to place the returned pointer value.

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not an accepted value.

@code{GL_INVALID_OPERATION} is generated if the reserved buffer object
name 0 is bound to @var{target}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetBufferPointerv}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetBufferSubData target offset size data
Returns a subset of a buffer object's data store.

@table @asis
@item @var{target}
Specifies the target buffer object.  The symbolic constant must be
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@item @var{offset}
Specifies the offset into the buffer object's data store from which data
will be returned, measured in bytes.

@item @var{size}
Specifies the size in bytes of the data store region being returned.

@item @var{data}
Specifies a pointer to the location where buffer object data is
returned.

@end table

@code{glGetBufferSubData} returns some or all of the data from the
buffer object currently bound to @var{target}.  Data starting at byte
offset @var{offset} and extending for @var{size} bytes is copied from
the data store to the memory pointed to by @var{data}.  An error is
thrown if the buffer object is currently mapped, or if @var{offset} and
@var{size} together define a range beyond the bounds of the buffer
object's data store.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@code{GL_INVALID_VALUE} is generated if @var{offset} or @var{size} is
negative, or if together they define a region of memory that extends
beyond the buffer object's allocated data store.

@code{GL_INVALID_OPERATION} is generated if the reserved buffer object
name 0 is bound to @var{target}.

@code{GL_INVALID_OPERATION} is generated if the buffer object being
queried is mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glGetBufferSubData} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetClipPlane plane equation
Return the coefficients of the specified clipping plane.

@table @asis
@item @var{plane}
Specifies a clipping plane.  The number of clipping planes depends on
the implementation, but at least six clipping planes are supported.  They
are identified by symbolic names of the form
@code{GL_CLIP_PLANE}@r{@var{i}} where i ranges from 0 to the value of
@code{GL_MAX_CLIP_PLANES} - 1.

@item @var{equation}
Returns four double-precision values that are the coefficients of the
plane equation of @var{plane} in eye coordinates.  The initial value is
(0, 0, 0, 0).

@end table

@code{glGetClipPlane} returns in @var{equation} the four coefficients of
the plane equation for @var{plane}.

@code{GL_INVALID_ENUM} is generated if @var{plane} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetClipPlane} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetColorTableParameterfv target pname params
@deftypefunx void glGetColorTableParameteriv target pname params
Get color lookup table parameters.

@table @asis
@item @var{target}
The target color table.  Must be @code{GL_COLOR_TABLE},
@code{GL_POST_CONVOLUTION_COLOR_TABLE},
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE}, @code{GL_PROXY_COLOR_TABLE},
@code{GL_PROXY_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE}.

@item @var{pname}
The symbolic name of a color lookup table parameter.  Must be one of
@code{GL_COLOR_TABLE_BIAS}, @code{GL_COLOR_TABLE_SCALE},
@code{GL_COLOR_TABLE_FORMAT}, @code{GL_COLOR_TABLE_WIDTH},
@code{GL_COLOR_TABLE_RED_SIZE}, @code{GL_COLOR_TABLE_GREEN_SIZE},
@code{GL_COLOR_TABLE_BLUE_SIZE}, @code{GL_COLOR_TABLE_ALPHA_SIZE},
@code{GL_COLOR_TABLE_LUMINANCE_SIZE}, or
@code{GL_COLOR_TABLE_INTENSITY_SIZE}.

@item @var{params}
A pointer to an array where the values of the parameter will be stored.

@end table

Returns parameters specific to color table @var{target}.

When @var{pname} is set to @code{GL_COLOR_TABLE_SCALE} or
@code{GL_COLOR_TABLE_BIAS}, @code{glGetColorTableParameter} returns the
color table scale or bias parameters for the table specified by
@var{target}.  For these queries, @var{target} must be set to
@code{GL_COLOR_TABLE}, @code{GL_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_POST_COLOR_MATRIX_COLOR_TABLE} and @var{params} points to an
array of four elements, which receive the scale or bias factors for red,
green, blue, and alpha, in that order.

@code{glGetColorTableParameter} can also be used to retrieve the format
and size parameters for a color table.  For these queries, set
@var{target} to either the color table target or the proxy color table
target.  The format and size parameters are set by @code{glColorTable}.

The following table lists the format and size parameters that may be
queried.  For each symbolic constant listed below for @var{pname},
@var{params} must point to an array of the given length and receive the
values indicated.



@table @asis
@item @strong{Parameter}
@strong{N}, @strong{Meaning}

@item @code{GL_COLOR_TABLE_FORMAT}
1 , Internal format (e.g., @code{GL_RGBA})

@item @code{GL_COLOR_TABLE_WIDTH}
1 , Number of elements in table

@item @code{GL_COLOR_TABLE_RED_SIZE}
1 , Size of red component, in bits

@item @code{GL_COLOR_TABLE_GREEN_SIZE}
1 , Size of green component

@item @code{GL_COLOR_TABLE_BLUE_SIZE}
1 , Size of blue component

@item @code{GL_COLOR_TABLE_ALPHA_SIZE}
1 , Size of alpha component

@item @code{GL_COLOR_TABLE_LUMINANCE_SIZE}
1 , Size of luminance component

@item @code{GL_COLOR_TABLE_INTENSITY_SIZE}
1 , Size of intensity component

@end table



@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not an acceptable value.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetColorTableParameter} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetColorTable target format type table
Retrieve contents of a color lookup table.

@table @asis
@item @var{target}
Must be @code{GL_COLOR_TABLE}, @code{GL_POST_CONVOLUTION_COLOR_TABLE},
or @code{GL_POST_COLOR_MATRIX_COLOR_TABLE}.

@item @var{format}
The format of the pixel data in @var{table}.  The possible values are
@code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_LUMINANCE}, @code{GL_LUMINANCE_ALPHA}, @code{GL_RGB},
@code{GL_BGR}, @code{GL_RGBA}, and @code{GL_BGRA}.

@item @var{type}
The type of the pixel data in @var{table}.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{table}
Pointer to a one-dimensional array of pixel data containing the contents
of the color table.

@end table

@code{glGetColorTable} returns in @var{table} the contents of the color
table specified by @var{target}.  No pixel transfer operations are
performed, but pixel storage modes that are applicable to
@code{glReadPixels} are performed.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
histogram table is requested, @var{table} is treated as a byte offset
into the buffer object's data store.

Color components that are requested in the specified @var{format}, but
which are not included in the internal format of the color lookup table,
are returned as zero.  The assignments of internal color components to
the components requested by @var{format} are

@table @asis
@item @strong{Internal Component}
@strong{Resulting Component}

@item  Red 
Red

@item  Green 
Green

@item  Blue 
Blue

@item  Alpha 
Alpha

@item  Luminance 
Red

@item  Intensity 
Red

@end table



@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and @var{table}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetColorTable} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetCompressedTexImage target lod img
Return a compressed texture image.

@table @asis
@item @var{target}
Specifies which texture is to be obtained.  @code{GL_TEXTURE_1D},
@code{GL_TEXTURE_2D}, and
@code{GL_TEXTURE_3D}@code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, and
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z} are accepted.

@item @var{lod}
Specifies the level-of-detail number of the desired image.  Level 0 is
the base image level.  Level @r{@var{n}} is the @r{@var{n}}th mipmap
reduction image.

@item @var{img}
Returns the compressed texture image.

@end table

@code{glGetCompressedTexImage} returns the compressed texture image
associated with @var{target} and @var{lod} into @var{img}.  @var{img}
should be an array of @code{GL_TEXTURE_COMPRESSED_IMAGE_SIZE} bytes.
@var{target} specifies whether the desired texture image was one
specified by @code{glTexImage1D} (@code{GL_TEXTURE_1D}),
@code{glTexImage2D} (@code{GL_TEXTURE_2D} or any of
@code{GL_TEXTURE_CUBE_MAP_*}), or @code{glTexImage3D}
(@code{GL_TEXTURE_3D}).  @var{lod} specifies the level-of-detail number
of the desired image.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is requested, @var{img} is treated as a byte offset into
the buffer object's data store.

To minimize errors, first verify that the texture is compressed by
calling @code{glGetTexLevelParameter} with argument
@code{GL_TEXTURE_COMPRESSED}.  If the texture is compressed, then
determine the amount of memory required to store the compressed texture
by calling @code{glGetTexLevelParameter} with argument
@code{GL_TEXTURE_COMPRESSED_IMAGE_SIZE}.  Finally, retrieve the internal
format of the texture by calling @code{glGetTexLevelParameter} with
argument @code{GL_TEXTURE_INTERNAL_FORMAT}.  To store the texture for
later use, associate the internal format and size with the retrieved
texture image.  These data can be used by the respective texture or
subtexture loading routine used for loading @var{target} textures.

@code{GL_INVALID_VALUE} is generated if @var{lod} is less than zero or
greater than the maximum number of LODs permitted by the implementation.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetCompressedTexImage} is used to retrieve a texture that is in
an uncompressed internal format.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetCompressedTexImage} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetConvolutionFilter target format type image
Get current 1D or 2D convolution filter kernel.

@table @asis
@item @var{target}
The filter to be retrieved.  Must be one of @code{GL_CONVOLUTION_1D} or
@code{GL_CONVOLUTION_2D}.

@item @var{format}
Format of the output image.  Must be one of @code{GL_RED},
@code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB},
@code{GL_BGR}, @code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, or
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Data type of components in the output image.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{image}
Pointer to storage for the output image.

@end table

@code{glGetConvolutionFilter} returns the current 1D or 2D convolution
filter kernel as an image.  The one- or two-dimensional image is placed
in @var{image} according to the specifications in @var{format} and
@var{type}.  No pixel transfer operations are performed on this image,
but the relevant pixel storage modes are applied.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
convolution filter is requested, @var{image} is treated as a byte offset
into the buffer object's data store.

Color components that are present in @var{format} but not included in
the internal format of the filter are returned as zero.  The assignments
of internal color components to the components of @var{format} are as
follows.

@table @asis
@item @strong{Internal Component}
@strong{Resulting Component}

@item  Red 
Red

@item  Green 
Green

@item  Blue 
Blue

@item  Alpha 
Alpha

@item  Luminance 
Red

@item  Intensity 
Red

@end table



@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and @var{image}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetConvolutionFilter} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetConvolutionParameterfv target pname params
@deftypefunx void glGetConvolutionParameteriv target pname params
Get convolution parameters.

@table @asis
@item @var{target}
The filter whose parameters are to be retrieved.  Must be one of
@code{GL_CONVOLUTION_1D}, @code{GL_CONVOLUTION_2D}, or
@code{GL_SEPARABLE_2D}.

@item @var{pname}
The parameter to be retrieved.  Must be one of
@code{GL_CONVOLUTION_BORDER_MODE}, @code{GL_CONVOLUTION_BORDER_COLOR},
@code{GL_CONVOLUTION_FILTER_SCALE}, @code{GL_CONVOLUTION_FILTER_BIAS},
@code{GL_CONVOLUTION_FORMAT}, @code{GL_CONVOLUTION_WIDTH},
@code{GL_CONVOLUTION_HEIGHT}, @code{GL_MAX_CONVOLUTION_WIDTH}, or
@code{GL_MAX_CONVOLUTION_HEIGHT}.

@item @var{params}
Pointer to storage for the parameters to be retrieved.

@end table

@code{glGetConvolutionParameter} retrieves convolution parameters.
@var{target} determines which convolution filter is queried.  @var{pname}
determines which parameter is returned:

@table @asis
@item @code{GL_CONVOLUTION_BORDER_MODE}


The convolution border mode.  See @code{glConvolutionParameter} for a
list of border modes.

@item @code{GL_CONVOLUTION_BORDER_COLOR}


The current convolution border color.  @var{params} must be a pointer to
an array of four elements, which will receive the red, green, blue, and
alpha border colors.

@item @code{GL_CONVOLUTION_FILTER_SCALE}


The current filter scale factors.  @var{params} must be a pointer to an
array of four elements, which will receive the red, green, blue, and
alpha filter scale factors in that order.

@item @code{GL_CONVOLUTION_FILTER_BIAS}


The current filter bias factors.  @var{params} must be a pointer to an
array of four elements, which will receive the red, green, blue, and
alpha filter bias terms in that order.

@item @code{GL_CONVOLUTION_FORMAT}


The current internal format.  See @code{glConvolutionFilter1D},
@code{glConvolutionFilter2D}, and @code{glSeparableFilter2D} for lists
of allowable formats.

@item @code{GL_CONVOLUTION_WIDTH}


The current filter image width.

@item @code{GL_CONVOLUTION_HEIGHT}


The current filter image height.

@item @code{GL_MAX_CONVOLUTION_WIDTH}


The maximum acceptable filter image width.

@item @code{GL_MAX_CONVOLUTION_HEIGHT}


The maximum acceptable filter image height.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{target} is
@code{GL_CONVOLUTION_1D} and @var{pname} is @code{GL_CONVOLUTION_HEIGHT}
or @code{GL_MAX_CONVOLUTION_HEIGHT}.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetConvolutionParameter} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun GLenum glGetError 
Return error information.

@code{glGetError} returns the value of the error flag.  Each detectable
error is assigned a numeric code and symbolic name.  When an error
occurs, the error flag is set to the appropriate error code value.  No
other errors are recorded until @code{glGetError} is called, the error
code is returned, and the flag is reset to @code{GL_NO_ERROR}.  If a
call to @code{glGetError} returns @code{GL_NO_ERROR}, there has been no
detectable error since the last call to @code{glGetError}, or since the
GL was initialized.

To allow for distributed implementations, there may be several error
flags.  If any single error flag has recorded an error, the value of
that flag is returned and that flag is reset to @code{GL_NO_ERROR} when
@code{glGetError} is called.  If more than one flag has recorded an
error, @code{glGetError} returns and clears an arbitrary error flag
value.  Thus, @code{glGetError} should always be called in a loop, until
it returns @code{GL_NO_ERROR}, if all error flags are to be reset.

Initially, all error flags are set to @code{GL_NO_ERROR}.

The following errors are currently defined:

@table @asis
@item @code{GL_NO_ERROR}
No error has been recorded.  The value of this symbolic constant is
guaranteed to be 0.

@item @code{GL_INVALID_ENUM}
An unacceptable value is specified for an enumerated argument.  The
offending command is ignored and has no other side effect than to set
the error flag.

@item @code{GL_INVALID_VALUE}
A numeric argument is out of range.  The offending command is ignored
and has no other side effect than to set the error flag.

@item @code{GL_INVALID_OPERATION}
The specified operation is not allowed in the current state.  The
offending command is ignored and has no other side effect than to set
the error flag.

@item @code{GL_STACK_OVERFLOW}
This command would cause a stack overflow.  The offending command is
ignored and has no other side effect than to set the error flag.

@item @code{GL_STACK_UNDERFLOW}
This command would cause a stack underflow.  The offending command is
ignored and has no other side effect than to set the error flag.

@item @code{GL_OUT_OF_MEMORY}
There is not enough memory left to execute the command.  The state of
the GL is undefined, except for the state of the error flags, after this
error is recorded.

@item @code{GL_TABLE_TOO_LARGE}
The specified table exceeds the implementation's maximum supported table
size.  The offending command is ignored and has no other side effect
than to set the error flag.

@end table

When an error flag is set, results of a GL operation are undefined only
if @code{GL_OUT_OF_MEMORY} has occurred.  In all other cases, the
command generating the error is ignored and has no effect on the GL
state or frame buffer contents.  If the generating command returns a
value, it returns 0.  If @code{glGetError} itself generates an error, it
returns 0.

@code{GL_INVALID_OPERATION} is generated if @code{glGetError} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.  In this case, @code{glGetError} returns 0.

@end deftypefun

@deftypefun void glGetHistogramParameterfv target pname params
@deftypefunx void glGetHistogramParameteriv target pname params
Get histogram parameters.

@table @asis
@item @var{target}
Must be one of @code{GL_HISTOGRAM} or @code{GL_PROXY_HISTOGRAM}.

@item @var{pname}
The name of the parameter to be retrieved.  Must be one of
@code{GL_HISTOGRAM_WIDTH}, @code{GL_HISTOGRAM_FORMAT},
@code{GL_HISTOGRAM_RED_SIZE}, @code{GL_HISTOGRAM_GREEN_SIZE},
@code{GL_HISTOGRAM_BLUE_SIZE}, @code{GL_HISTOGRAM_ALPHA_SIZE},
@code{GL_HISTOGRAM_LUMINANCE_SIZE}, or @code{GL_HISTOGRAM_SINK}.

@item @var{params}
Pointer to storage for the returned values.

@end table

@code{glGetHistogramParameter} is used to query parameter values for the
current histogram or for a proxy.  The histogram state information may
be queried by calling @code{glGetHistogramParameter} with a @var{target}
of @code{GL_HISTOGRAM} (to obtain information for the current histogram
table) or @code{GL_PROXY_HISTOGRAM} (to obtain information from the most
recent proxy request) and one of the following values for the
@var{pname} argument:



@table @asis
@item @strong{Parameter}
@strong{Description}

@item @code{GL_HISTOGRAM_WIDTH}
Histogram table width

@item @code{GL_HISTOGRAM_FORMAT}
Internal format

@item @code{GL_HISTOGRAM_RED_SIZE}
Red component counter size, in bits

@item @code{GL_HISTOGRAM_GREEN_SIZE}
Green component counter size, in bits

@item @code{GL_HISTOGRAM_BLUE_SIZE}
Blue component counter size, in bits

@item @code{GL_HISTOGRAM_ALPHA_SIZE}
Alpha component counter size, in bits

@item @code{GL_HISTOGRAM_LUMINANCE_SIZE}
Luminance component counter size, in bits

@item @code{GL_HISTOGRAM_SINK}
Value of the @var{sink} parameter

@end table



@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetHistogramParameter} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetHistogram target reset format type values
Get histogram table.

@table @asis
@item @var{target}
Must be @code{GL_HISTOGRAM}.

@item @var{reset}
If @code{GL_TRUE}, each component counter that is actually returned is
reset to zero.  (Other counters are unaffected.) If @code{GL_FALSE},
none of the counters in the histogram table is modified.

@item @var{format}
The format of values to be returned in @var{values}.  Must be one of
@code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_RGB}, @code{GL_BGR}, @code{GL_RGBA}, @code{GL_BGRA},
@code{GL_LUMINANCE}, or @code{GL_LUMINANCE_ALPHA}.

@item @var{type}
The type of values to be returned in @var{values}.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{values}
A pointer to storage for the returned histogram table.

@end table

@code{glGetHistogram} returns the current histogram table as a
one-dimensional image with the same width as the histogram.  No pixel
transfer operations are performed on this image, but pixel storage modes
that are applicable to 1D images are honored.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
histogram table is requested, @var{values} is treated as a byte offset
into the buffer object's data store.

Color components that are requested in the specified @var{format}, but
which are not included in the internal format of the histogram, are
returned as zero.  The assignments of internal color components to the
components requested by @var{format} are:

@table @asis
@item @strong{Internal Component}
@strong{Resulting Component}

@item  Red 
Red

@item  Green 
Green

@item  Blue 
Blue

@item  Alpha 
Alpha

@item  Luminance 
Red

@end table



@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_HISTOGRAM}.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and @var{values}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetHistogram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetLightfv light pname params
@deftypefunx void glGetLightiv light pname params
Return light source parameter values.

@table @asis
@item @var{light}
Specifies a light source.  The number of possible lights depends on the
implementation, but at least eight lights are supported.  They are
identified by symbolic names of the form @code{GL_LIGHT}@r{@var{i}}
where @r{@var{i}} ranges from 0 to the value of @code{GL_MAX_LIGHTS} -
1.

@item @var{pname}
Specifies a light source parameter for @var{light}.  Accepted symbolic
names are @code{GL_AMBIENT}, @code{GL_DIFFUSE}, @code{GL_SPECULAR},
@code{GL_POSITION}, @code{GL_SPOT_DIRECTION}, @code{GL_SPOT_EXPONENT},
@code{GL_SPOT_CUTOFF}, @code{GL_CONSTANT_ATTENUATION},
@code{GL_LINEAR_ATTENUATION}, and @code{GL_QUADRATIC_ATTENUATION}.

@item @var{params}
Returns the requested data.

@end table

@code{glGetLight} returns in @var{params} the value or values of a light
source parameter.  @var{light} names the light and is a symbolic name of
the form @code{GL_LIGHT}@r{@var{i}} where i ranges from 0 to the value
of @code{GL_MAX_LIGHTS} - 1.  @code{GL_MAX_LIGHTS} is an implementation
dependent constant that is greater than or equal to eight.  @var{pname}
specifies one of ten light source parameters, again by symbolic name.

The following parameters are defined:

@table @asis
@item @code{GL_AMBIENT}
@var{params} returns four integer or floating-point values representing
the ambient intensity of the light source.  Integer values, when
requested, are linearly mapped from the internal floating-point
representation such that 1.0 maps to the most positive representable
integer value, and @r{-1.0} maps to the most negative representable
integer value.  If the internal value is outside the range @r{[-1,1]},
the corresponding integer return value is undefined.  The initial value
is (0, 0, 0, 1).

@item @code{GL_DIFFUSE}
@var{params} returns four integer or floating-point values representing
the diffuse intensity of the light source.  Integer values, when
requested, are linearly mapped from the internal floating-point
representation such that 1.0 maps to the most positive representable
integer value, and @r{-1.0} maps to the most negative representable
integer value.  If the internal value is outside the range @r{[-1,1]},
the corresponding integer return value is undefined.  The initial value
for @code{GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial
value is (0, 0, 0, 0).

@item @code{GL_SPECULAR}
@var{params} returns four integer or floating-point values representing
the specular intensity of the light source.  Integer values, when
requested, are linearly mapped from the internal floating-point
representation such that 1.0 maps to the most positive representable
integer value, and @r{-1.0} maps to the most negative representable
integer value.  If the internal value is outside the range @r{[-1,1]},
the corresponding integer return value is undefined.  The initial value
for @code{GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial
value is (0, 0, 0, 0).

@item @code{GL_POSITION}
@var{params} returns four integer or floating-point values representing
the position of the light source.  Integer values, when requested, are
computed by rounding the internal floating-point values to the nearest
integer value.  The returned values are those maintained in eye
coordinates.  They will not be equal to the values specified using
@code{glLight}, unless the modelview matrix was identity at the time
@code{glLight} was called.  The initial value is (0, 0, 1, 0).

@item @code{GL_SPOT_DIRECTION}
@var{params} returns three integer or floating-point values representing
the direction of the light source.  Integer values, when requested, are
computed by rounding the internal floating-point values to the nearest
integer value.  The returned values are those maintained in eye
coordinates.  They will not be equal to the values specified using
@code{glLight}, unless the modelview matrix was identity at the time
@code{glLight} was called.  Although spot direction is normalized before
being used in the lighting equation, the returned values are the
transformed versions of the specified values prior to normalization.  The
initial value is @r{(0,0-1)}.

@item @code{GL_SPOT_EXPONENT}
@var{params} returns a single integer or floating-point value
representing the spot exponent of the light.  An integer value, when
requested, is computed by rounding the internal floating-point
representation to the nearest integer.  The initial value is 0.

@item @code{GL_SPOT_CUTOFF}
@var{params} returns a single integer or floating-point value
representing the spot cutoff angle of the light.  An integer value, when
requested, is computed by rounding the internal floating-point
representation to the nearest integer.  The initial value is 180.

@item @code{GL_CONSTANT_ATTENUATION}
@var{params} returns a single integer or floating-point value
representing the constant (not distance-related) attenuation of the
light.  An integer value, when requested, is computed by rounding the
internal floating-point representation to the nearest integer.  The
initial value is 1.

@item @code{GL_LINEAR_ATTENUATION}
@var{params} returns a single integer or floating-point value
representing the linear attenuation of the light.  An integer value,
when requested, is computed by rounding the internal floating-point
representation to the nearest integer.  The initial value is 0.

@item @code{GL_QUADRATIC_ATTENUATION}
@var{params} returns a single integer or floating-point value
representing the quadratic attenuation of the light.  An integer value,
when requested, is computed by rounding the internal floating-point
representation to the nearest integer.  The initial value is 0.

@end table

@code{GL_INVALID_ENUM} is generated if @var{light} or @var{pname} is not
an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetLight} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetMapdv target query v
@deftypefunx void glGetMapfv target query v
@deftypefunx void glGetMapiv target query v
Return evaluator parameters.

@table @asis
@item @var{target}
Specifies the symbolic name of a map.  Accepted values are
@code{GL_MAP1_COLOR_4}, @code{GL_MAP1_INDEX}, @code{GL_MAP1_NORMAL},
@code{GL_MAP1_TEXTURE_COORD_1}, @code{GL_MAP1_TEXTURE_COORD_2},
@code{GL_MAP1_TEXTURE_COORD_3}, @code{GL_MAP1_TEXTURE_COORD_4},
@code{GL_MAP1_VERTEX_3}, @code{GL_MAP1_VERTEX_4},
@code{GL_MAP2_COLOR_4}, @code{GL_MAP2_INDEX}, @code{GL_MAP2_NORMAL},
@code{GL_MAP2_TEXTURE_COORD_1}, @code{GL_MAP2_TEXTURE_COORD_2},
@code{GL_MAP2_TEXTURE_COORD_3}, @code{GL_MAP2_TEXTURE_COORD_4},
@code{GL_MAP2_VERTEX_3}, and @code{GL_MAP2_VERTEX_4}.

@item @var{query}
Specifies which parameter to return.  Symbolic names @code{GL_COEFF},
@code{GL_ORDER}, and @code{GL_DOMAIN} are accepted.

@item @var{v}
Returns the requested data.

@end table

@code{glMap1} and @code{glMap2} define evaluators.  @code{glGetMap}
returns evaluator parameters.  @var{target} chooses a map, @var{query}
selects a specific parameter, and @var{v} points to storage where the
values will be returned.

The acceptable values for the @var{target} parameter are described in
the @code{glMap1} and @code{glMap2} reference pages.

@var{query} can assume the following values:

@table @asis
@item @code{GL_COEFF}
@var{v} returns the control points for the evaluator function.
One-dimensional evaluators return @r{@var{order}} control points, and
two-dimensional evaluators return @r{@var{uorder}×@var{vorder}} control
points.  Each control point consists of one, two, three, or four
integer, single-precision floating-point, or double-precision
floating-point values, depending on the type of the evaluator.  The GL
returns two-dimensional control points in row-major order, incrementing
the @r{@var{uorder}} index quickly and the @r{@var{vorder}} index after
each row.  Integer values, when requested, are computed by rounding the
internal floating-point values to the nearest integer values.

@item @code{GL_ORDER}
@var{v} returns the order of the evaluator function.  One-dimensional
evaluators return a single value, @r{@var{order}}.  The initial value is
1.  Two-dimensional evaluators return two values, @r{@var{uorder}} and
@r{@var{vorder}}.  The initial value is 1,1.

@item @code{GL_DOMAIN}
@var{v} returns the linear @r{@var{u}} and @r{@var{v}} mapping
parameters.  One-dimensional evaluators return two values, @r{@var{u1}}
and @r{@var{u2}}, as specified by @code{glMap1}.  Two-dimensional
evaluators return four values (@r{@var{u1}}, @r{@var{u2}}, @r{@var{v1}},
and @r{@var{v2}}) as specified by @code{glMap2}.  Integer values, when
requested, are computed by rounding the internal floating-point values
to the nearest integer values.

@end table

@code{GL_INVALID_ENUM} is generated if either @var{target} or
@var{query} is not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetMap} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glGetMaterialfv face pname params
@deftypefunx void glGetMaterialiv face pname params
Return material parameters.

@table @asis
@item @var{face}
Specifies which of the two materials is being queried.  @code{GL_FRONT}
or @code{GL_BACK} are accepted, representing the front and back
materials, respectively.

@item @var{pname}
Specifies the material parameter to return.  @code{GL_AMBIENT},
@code{GL_DIFFUSE}, @code{GL_SPECULAR}, @code{GL_EMISSION},
@code{GL_SHININESS}, and @code{GL_COLOR_INDEXES} are accepted.

@item @var{params}
Returns the requested data.

@end table

@code{glGetMaterial} returns in @var{params} the value or values of
parameter @var{pname} of material @var{face}.  Six parameters are
defined:

@table @asis
@item @code{GL_AMBIENT}
@var{params} returns four integer or floating-point values representing
the ambient reflectance of the material.  Integer values, when
requested, are linearly mapped from the internal floating-point
representation such that 1.0 maps to the most positive representable
integer value, and @r{-1.0} maps to the most negative representable
integer value.  If the internal value is outside the range @r{[-1,1]},
the corresponding integer return value is undefined.  The initial value
is (0.2, 0.2, 0.2, 1.0)

@item @code{GL_DIFFUSE}
@var{params} returns four integer or floating-point values representing
the diffuse reflectance of the material.  Integer values, when
requested, are linearly mapped from the internal floating-point
representation such that 1.0 maps to the most positive representable
integer value, and @r{-1.0} maps to the most negative representable
integer value.  If the internal value is outside the range @r{[-1,1]},
the corresponding integer return value is undefined.  The initial value
is (0.8, 0.8, 0.8, 1.0).

@item @code{GL_SPECULAR}
@var{params} returns four integer or floating-point values representing
the specular reflectance of the material.  Integer values, when
requested, are linearly mapped from the internal floating-point
representation such that 1.0 maps to the most positive representable
integer value, and @r{-1.0} maps to the most negative representable
integer value.  If the internal value is outside the range @r{[-1,1]},
the corresponding integer return value is undefined.  The initial value
is (0, 0, 0, 1).

@item @code{GL_EMISSION}
@var{params} returns four integer or floating-point values representing
the emitted light intensity of the material.  Integer values, when
requested, are linearly mapped from the internal floating-point
representation such that 1.0 maps to the most positive representable
integer value, and @r{-1.0} maps to the most negative representable
integer value.  If the internal value is outside the range @r{[-1,1]},
the corresponding integer return value is undefined.  The initial value
is (0, 0, 0, 1).

@item @code{GL_SHININESS}
@var{params} returns one integer or floating-point value representing
the specular exponent of the material.  Integer values, when requested,
are computed by rounding the internal floating-point value to the
nearest integer value.  The initial value is 0.

@item @code{GL_COLOR_INDEXES}
@var{params} returns three integer or floating-point values representing
the ambient, diffuse, and specular indices of the material.  These
indices are used only for color index lighting.  (All the other
parameters are used only for RGBA lighting.) Integer values, when
requested, are computed by rounding the internal floating-point values
to the nearest integer values.

@end table

@code{GL_INVALID_ENUM} is generated if @var{face} or @var{pname} is not
an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetMaterial} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetMinmaxParameterfv target pname params
@deftypefunx void glGetMinmaxParameteriv target pname params
Get minmax parameters.

@table @asis
@item @var{target}
Must be @code{GL_MINMAX}.

@item @var{pname}
The parameter to be retrieved.  Must be one of @code{GL_MINMAX_FORMAT}
or @code{GL_MINMAX_SINK}.

@item @var{params}
A pointer to storage for the retrieved parameters.

@end table

@code{glGetMinmaxParameter} retrieves parameters for the current minmax
table by setting @var{pname} to one of the following values:



@table @asis
@item @strong{Parameter}
@strong{Description}

@item @code{GL_MINMAX_FORMAT}
Internal format of minmax table

@item @code{GL_MINMAX_SINK}
Value of the @var{sink} parameter

@end table



@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_MINMAX}.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @code{glGetMinmaxParameter}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetMinmax target reset format types values
Get minimum and maximum pixel values.

@table @asis
@item @var{target}
Must be @code{GL_MINMAX}.

@item @var{reset}
If @code{GL_TRUE}, all entries in the minmax table that are actually
returned are reset to their initial values.  (Other entries are
unaltered.) If @code{GL_FALSE}, the minmax table is unaltered.

@item @var{format}
The format of the data to be returned in @var{values}.  Must be one of
@code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_RGB}, @code{GL_BGR}, @code{GL_RGBA}, @code{GL_BGRA},
@code{GL_LUMINANCE}, or @code{GL_LUMINANCE_ALPHA}.

@item @var{types}
The type of the data to be returned in @var{values}.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{values}
A pointer to storage for the returned values.

@end table

@code{glGetMinmax} returns the accumulated minimum and maximum pixel
values (computed on a per-component basis) in a one-dimensional image of
width 2.  The first set of return values are the minima, and the second
set of return values are the maxima.  The format of the return values is
determined by @var{format}, and their type is determined by @var{types}.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while
minimum and maximum pixel values are requested, @var{values} is treated
as a byte offset into the buffer object's data store.

No pixel transfer operations are performed on the return values, but
pixel storage modes that are applicable to one-dimensional images are
performed.  Color components that are requested in the specified
@var{format}, but that are not included in the internal format of the
minmax table, are returned as zero.  The assignment of internal color
components to the components requested by @var{format} are as follows:



@table @asis
@item @strong{Internal Component}
@strong{Resulting Component}

@item  Red 
Red

@item  Green 
Green

@item  Blue 
Blue

@item  Alpha 
Alpha

@item  Luminance 
Red

@end table

If @var{reset} is @code{GL_TRUE}, the minmax table entries corresponding
to the return values are reset to their initial values.  Minimum and
maximum values that are not returned are not modified, even if
@var{reset} is @code{GL_TRUE}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_MINMAX}.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{types} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @var{types} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{types} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and @var{values}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetMinmax} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetPixelMapfv map data
@deftypefunx void glGetPixelMapuiv map data
@deftypefunx void glGetPixelMapusv map data
Return the specified pixel map.

@table @asis
@item @var{map}
Specifies the name of the pixel map to return.  Accepted values are
@code{GL_PIXEL_MAP_I_TO_I}, @code{GL_PIXEL_MAP_S_TO_S},
@code{GL_PIXEL_MAP_I_TO_R}, @code{GL_PIXEL_MAP_I_TO_G},
@code{GL_PIXEL_MAP_I_TO_B}, @code{GL_PIXEL_MAP_I_TO_A},
@code{GL_PIXEL_MAP_R_TO_R}, @code{GL_PIXEL_MAP_G_TO_G},
@code{GL_PIXEL_MAP_B_TO_B}, and @code{GL_PIXEL_MAP_A_TO_A}.

@item @var{data}
Returns the pixel map contents.

@end table

See the @code{glPixelMap} reference page for a description of the
acceptable values for the @var{map} parameter.  @code{glGetPixelMap}
returns in @var{data} the contents of the pixel map specified in
@var{map}.  Pixel maps are used during the execution of
@code{glReadPixels}, @code{glDrawPixels}, @code{glCopyPixels},
@code{glTexImage1D}, @code{glTexImage2D}, @code{glTexImage3D},
@code{glTexSubImage1D}, @code{glTexSubImage2D}, @code{glTexSubImage3D},
@code{glCopyTexImage1D}, @code{glCopyTexImage2D},
@code{glCopyTexSubImage1D}, @code{glCopyTexSubImage2D}, and
@code{glCopyTexSubImage3D}.  to map color indices, stencil indices,
color components, and depth components to other values.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
pixel map is requested, @var{data} is treated as a byte offset into the
buffer object's data store.

Unsigned integer values, if requested, are linearly mapped from the
internal fixed or floating-point representation such that 1.0 maps to
the largest representable integer value, and 0.0 maps to 0.  Return
unsigned integer values are undefined if the map value was not in the
range [0,1].

To determine the required size of @var{map}, call @code{glGet} with the
appropriate symbolic constant.

@code{GL_INVALID_ENUM} is generated if @var{map} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated by @code{glGetPixelMapfv} if a
non-zero buffer object name is bound to the @code{GL_PIXEL_PACK_BUFFER}
target and @var{data} is not evenly divisible into the number of bytes
needed to store in memory a GLfloat datum.

@code{GL_INVALID_OPERATION} is generated by @code{glGetPixelMapuiv} if a
non-zero buffer object name is bound to the @code{GL_PIXEL_PACK_BUFFER}
target and @var{data} is not evenly divisible into the number of bytes
needed to store in memory a GLuint datum.

@code{GL_INVALID_OPERATION} is generated by @code{glGetPixelMapusv} if a
non-zero buffer object name is bound to the @code{GL_PIXEL_PACK_BUFFER}
target and @var{data} is not evenly divisible into the number of bytes
needed to store in memory a GLushort datum.

@code{GL_INVALID_OPERATION} is generated if @code{glGetPixelMap} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetPointerv pname params
Return the address of the specified pointer.

@table @asis
@item @var{pname}
Specifies the array or buffer pointer to be returned.  Symbolic
constants @code{GL_COLOR_ARRAY_POINTER},
@code{GL_EDGE_FLAG_ARRAY_POINTER}, @code{GL_FOG_COORD_ARRAY_POINTER},
@code{GL_FEEDBACK_BUFFER_POINTER}, @code{GL_INDEX_ARRAY_POINTER},
@code{GL_NORMAL_ARRAY_POINTER}, @code{GL_SECONDARY_COLOR_ARRAY_POINTER},
@code{GL_SELECTION_BUFFER_POINTER},
@code{GL_TEXTURE_COORD_ARRAY_POINTER}, or @code{GL_VERTEX_ARRAY_POINTER}
are accepted.

@item @var{params}
Returns the pointer value specified by @var{pname}.

@end table

@code{glGetPointerv} returns pointer information.  @var{pname} is a
symbolic constant indicating the pointer to be returned, and
@var{params} is a pointer to a location in which to place the returned
data.

For all @var{pname} arguments except @code{GL_FEEDBACK_BUFFER_POINTER}
and @code{GL_SELECTION_BUFFER_POINTER}, if a non-zero named buffer
object was bound to the @code{GL_ARRAY_BUFFER} target (see
@code{glBindBuffer}) when the desired pointer was previously specified,
the pointer returned is a byte offset into the buffer object's data
store.  Buffer objects are only available in OpenGL versions 1.5 and
greater.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@end deftypefun

@deftypefun void glGetPolygonStipple pattern
Return the polygon stipple pattern.

@table @asis
@item @var{pattern}
Returns the stipple pattern.  The initial value is all 1's.

@end table

@code{glGetPolygonStipple} returns to @var{pattern} a @r{32×32} polygon
stipple pattern.  The pattern is packed into memory as if
@code{glReadPixels} with both @var{height} and @var{width} of 32,
@var{type} of @code{GL_BITMAP}, and @var{format} of
@code{GL_COLOR_INDEX} were called, and the stipple pattern were stored
in an internal @r{32×32} color index buffer.  Unlike
@code{glReadPixels}, however, pixel transfer operations (shift, offset,
pixel map) are not applied to the returned stipple image.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
polygon stipple pattern is requested, @var{pattern} is treated as a byte
offset into the buffer object's data store.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if @code{glGetPolygonStipple}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetProgramInfoLog program maxLength length infoLog
Returns the information log for a program object.

@table @asis
@item @var{program}
Specifies the program object whose information log is to be queried.

@item @var{maxLength}
Specifies the size of the character buffer for storing the returned
information log.

@item @var{length}
Returns the length of the string returned in @var{infoLog} (excluding
the null terminator).

@item @var{infoLog}
Specifies an array of characters that is used to return the information
log.

@end table

@code{glGetProgramInfoLog} returns the information log for the specified
program object.  The information log for a program object is modified
when the program object is linked or validated.  The string that is
returned will be null terminated.

@code{glGetProgramInfoLog} returns in @var{infoLog} as much of the
information log as it can, up to a maximum of @var{maxLength}
characters.  The number of characters actually returned, excluding the
null termination character, is specified by @var{length}.  If the length
of the returned string is not required, a value of @code{NULL} can be
passed in the @var{length} argument.  The size of the buffer required to
store the returned information log can be obtained by calling
@code{glGetProgram} with the value @code{GL_INFO_LOG_LENGTH}.

The information log for a program object is either an empty string, or a
string containing information about the last link operation, or a string
containing information about the last validation operation.  It may
contain diagnostic messages, warning messages, and other information.
When a program object is created, its information log will be a string
of length 0.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_VALUE} is generated if @var{maxLength} is less than 0.

@code{GL_INVALID_OPERATION} is generated if @code{glGetProgramInfoLog}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetProgramiv program pname params
Returns a parameter from a program object.

@table @asis
@item @var{program}
Specifies the program object to be queried.

@item @var{pname}
Specifies the object parameter.  Accepted symbolic names are
@code{GL_DELETE_STATUS}, @code{GL_LINK_STATUS},
@code{GL_VALIDATE_STATUS}, @code{GL_INFO_LOG_LENGTH},
@code{GL_ATTACHED_SHADERS}, @code{GL_ACTIVE_ATTRIBUTES},
@code{GL_ACTIVE_ATTRIBUTE_MAX_LENGTH}, @code{GL_ACTIVE_UNIFORMS},
@code{GL_ACTIVE_UNIFORM_MAX_LENGTH}.

@item @var{params}
Returns the requested object parameter.

@end table

@code{glGetProgram} returns in @var{params} the value of a parameter for
a specific program object.  The following parameters are defined:

@table @asis
@item @code{GL_DELETE_STATUS}


@var{params} returns @code{GL_TRUE} if @var{program} is currently
flagged for deletion, and @code{GL_FALSE} otherwise.

@item @code{GL_LINK_STATUS}


@var{params} returns @code{GL_TRUE} if the last link operation on
@var{program} was successful, and @code{GL_FALSE} otherwise.

@item @code{GL_VALIDATE_STATUS}


@var{params} returns @code{GL_TRUE} or if the last validation operation
on @var{program} was successful, and @code{GL_FALSE} otherwise.

@item @code{GL_INFO_LOG_LENGTH}


@var{params} returns the number of characters in the information log for
@var{program} including the null termination character (i.e., the size
of the character buffer required to store the information log).  If
@var{program} has no information log, a value of 0 is returned.

@item @code{GL_ATTACHED_SHADERS}


@var{params} returns the number of shader objects attached to
@var{program}.

@item @code{GL_ACTIVE_ATTRIBUTES}


@var{params} returns the number of active attribute variables for
@var{program}.

@item @code{GL_ACTIVE_ATTRIBUTE_MAX_LENGTH}


@var{params} returns the length of the longest active attribute name for
@var{program}, including the null termination character (i.e., the size
of the character buffer required to store the longest attribute name).
If no active attributes exist, 0 is returned.

@item @code{GL_ACTIVE_UNIFORMS}


@var{params} returns the number of active uniform variables for
@var{program}.

@item @code{GL_ACTIVE_UNIFORM_MAX_LENGTH}


@var{params} returns the length of the longest active uniform variable
name for @var{program}, including the null termination character (i.e.,
the size of the character buffer required to store the longest uniform
variable name).  If no active uniform variables exist, 0 is returned.

@end table

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} does not refer
to a program object.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetProgram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetQueryiv target pname params
Return parameters of a query object target.

@table @asis
@item @var{target}
Specifies a query object target.  Must be @code{GL_SAMPLES_PASSED}.

@item @var{pname}
Specifies the symbolic name of a query object target parameter.  Accepted
values are @code{GL_CURRENT_QUERY} or @code{GL_QUERY_COUNTER_BITS}.

@item @var{params}
Returns the requested data.

@end table

@code{glGetQueryiv} returns in @var{params} a selected parameter of the
query object target specified by @var{target}.

@var{pname} names a specific query object target parameter.  When
@var{target} is @code{GL_SAMPLES_PASSED}, @var{pname} can be as follows:

@table @asis
@item @code{GL_CURRENT_QUERY}
@var{params} returns the name of the currently active occlusion query
object.  If no occlusion query is active, 0 is returned.  The initial
value is 0.

@item @code{GL_QUERY_COUNTER_BITS}
@var{params} returns the number of bits in the query counter used to
accumulate passing samples.  If the number of bits returned is 0, the
implementation does not support a query counter, and the results
obtained from @code{glGetQueryObject} are useless.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetQueryiv} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetQueryObjectiv id pname params
@deftypefunx void glGetQueryObjectuiv id pname params
Return parameters of a query object.

@table @asis
@item @var{id}
Specifies the name of a query object.

@item @var{pname}
Specifies the symbolic name of a query object parameter.  Accepted
values are @code{GL_QUERY_RESULT} or @code{GL_QUERY_RESULT_AVAILABLE}.

@item @var{params}
Returns the requested data.

@end table

@code{glGetQueryObject} returns in @var{params} a selected parameter of
the query object specified by @var{id}.

@var{pname} names a specific query object parameter.  @var{pname} can be
as follows:

@table @asis
@item @code{GL_QUERY_RESULT}
@var{params} returns the value of the query object's passed samples
counter.  The initial value is 0.

@item @code{GL_QUERY_RESULT_AVAILABLE}
@var{params} returns whether the passed samples counter is immediately
available.  If a delay would occur waiting for the query result,
@code{GL_FALSE} is returned.  Otherwise, @code{GL_TRUE} is returned,
which also indicates that the results of all previous queries are
available as well.

@end table

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @var{id} is not the name of
a query object.

@code{GL_INVALID_OPERATION} is generated if @var{id} is the name of a
currently active query object.

@code{GL_INVALID_OPERATION} is generated if @code{glGetQueryObject} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetSeparableFilter target format type row column span
Get separable convolution filter kernel images.

@table @asis
@item @var{target}
The separable filter to be retrieved.  Must be @code{GL_SEPARABLE_2D}.

@item @var{format}
Format of the output images.  Must be one of @code{GL_RED},
@code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB},
@code{GL_BGR}@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, or
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Data type of components in the output images.  Symbolic constants
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{row}
Pointer to storage for the row filter image.

@item @var{column}
Pointer to storage for the column filter image.

@item @var{span}
Pointer to storage for the span filter image (currently unused).

@end table

@code{glGetSeparableFilter} returns the two one-dimensional filter
kernel images for the current separable 2D convolution filter.  The row
image is placed in @var{row} and the column image is placed in
@var{column} according to the specifications in @var{format} and
@var{type}.  (In the current implementation, @var{span} is not affected
in any way.) No pixel transfer operations are performed on the images,
but the relevant pixel storage modes are applied.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
separable convolution filter is requested, @var{row}, @var{column}, and
@var{span} are treated as a byte offset into the buffer object's data
store.

Color components that are present in @var{format} but not included in
the internal format of the filters are returned as zero.  The
assignments of internal color components to the components of
@var{format} are as follows:



@table @asis
@item @strong{Internal Component}
@strong{Resulting Component}

@item  Red 
Red

@item  Green 
Green

@item  Blue 
Blue

@item  Alpha 
Alpha

@item  Luminance 
Red

@item  Intensity 
Red

@end table



@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_SEPARABLE_2D}.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and @var{row} or
@var{column} is not evenly divisible into the number of bytes needed to
store in memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetSeparableFilter}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetShaderInfoLog shader maxLength length infoLog
Returns the information log for a shader object.

@table @asis
@item @var{shader}
Specifies the shader object whose information log is to be queried.

@item @var{maxLength}
Specifies the size of the character buffer for storing the returned
information log.

@item @var{length}
Returns the length of the string returned in @var{infoLog} (excluding
the null terminator).

@item @var{infoLog}
Specifies an array of characters that is used to return the information
log.

@end table

@code{glGetShaderInfoLog} returns the information log for the specified
shader object.  The information log for a shader object is modified when
the shader is compiled.  The string that is returned will be null
terminated.

@code{glGetShaderInfoLog} returns in @var{infoLog} as much of the
information log as it can, up to a maximum of @var{maxLength}
characters.  The number of characters actually returned, excluding the
null termination character, is specified by @var{length}.  If the length
of the returned string is not required, a value of @code{NULL} can be
passed in the @var{length} argument.  The size of the buffer required to
store the returned information log can be obtained by calling
@code{glGetShader} with the value @code{GL_INFO_LOG_LENGTH}.

The information log for a shader object is a string that may contain
diagnostic messages, warning messages, and other information about the
last compile operation.  When a shader object is created, its
information log will be a string of length 0.

@code{GL_INVALID_VALUE} is generated if @var{shader} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is not a shader
object.

@code{GL_INVALID_VALUE} is generated if @var{maxLength} is less than 0.

@code{GL_INVALID_OPERATION} is generated if @code{glGetShaderInfoLog} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetShaderSource shader bufSize length source
Returns the source code string from a shader object.

@table @asis
@item @var{shader}
Specifies the shader object to be queried.

@item @var{bufSize}
Specifies the size of the character buffer for storing the returned
source code string.

@item @var{length}
Returns the length of the string returned in @var{source} (excluding the
null terminator).

@item @var{source}
Specifies an array of characters that is used to return the source code
string.

@end table

@code{glGetShaderSource} returns the concatenation of the source code
strings from the shader object specified by @var{shader}.  The source
code strings for a shader object are the result of a previous call to
@code{glShaderSource}.  The string returned by the function will be null
terminated.

@code{glGetShaderSource} returns in @var{source} as much of the source
code string as it can, up to a maximum of @var{bufSize} characters.  The
number of characters actually returned, excluding the null termination
character, is specified by @var{length}.  If the length of the returned
string is not required, a value of @code{NULL} can be passed in the
@var{length} argument.  The size of the buffer required to store the
returned source code string can be obtained by calling
@code{glGetShader} with the value @code{GL_SHADER_SOURCE_LENGTH}.

@code{GL_INVALID_VALUE} is generated if @var{shader} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is not a shader
object.

@code{GL_INVALID_VALUE} is generated if @var{bufSize} is less than 0.

@code{GL_INVALID_OPERATION} is generated if @code{glGetShaderSource} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetShaderiv shader pname params
Returns a parameter from a shader object.

@table @asis
@item @var{shader}
Specifies the shader object to be queried.

@item @var{pname}
Specifies the object parameter.  Accepted symbolic names are
@code{GL_SHADER_TYPE}, @code{GL_DELETE_STATUS},
@code{GL_COMPILE_STATUS}, @code{GL_INFO_LOG_LENGTH},
@code{GL_SHADER_SOURCE_LENGTH}.

@item @var{params}
Returns the requested object parameter.

@end table

@code{glGetShader} returns in @var{params} the value of a parameter for
a specific shader object.  The following parameters are defined:

@table @asis
@item @code{GL_SHADER_TYPE}
@var{params} returns @code{GL_VERTEX_SHADER} if @var{shader} is a vertex
shader object, and @code{GL_FRAGMENT_SHADER} if @var{shader} is a
fragment shader object.

@item @code{GL_DELETE_STATUS}
@var{params} returns @code{GL_TRUE} if @var{shader} is currently flagged
for deletion, and @code{GL_FALSE} otherwise.

@item @code{GL_COMPILE_STATUS}
@var{params} returns @code{GL_TRUE} if the last compile operation on
@var{shader} was successful, and @code{GL_FALSE} otherwise.

@item @code{GL_INFO_LOG_LENGTH}
@var{params} returns the number of characters in the information log for
@var{shader} including the null termination character (i.e., the size of
the character buffer required to store the information log).  If
@var{shader} has no information log, a value of 0 is returned.

@item @code{GL_SHADER_SOURCE_LENGTH}
@var{params} returns the length of the concatenation of the source
strings that make up the shader source for the @var{shader}, including
the null termination character.  (i.e., the size of the character buffer
required to store the shader source).  If no source code exists, 0 is
returned.

@end table

@code{GL_INVALID_VALUE} is generated if @var{shader} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{shader} does not refer
to a shader object.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetShader} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun const-GLubyte* glGetString name
Return a string describing the current GL connection.

@table @asis
@item @var{name}
Specifies a symbolic constant, one of @code{GL_VENDOR},
@code{GL_RENDERER}, @code{GL_VERSION},
@code{GL_SHADING_LANGUAGE_VERSION}, or @code{GL_EXTENSIONS}.

@end table

@code{glGetString} returns a pointer to a static string describing some
aspect of the current GL connection.  @var{name} can be one of the
following:

@table @asis
@item @code{GL_VENDOR}


Returns the company responsible for this GL implementation.  This name
does not change from release to release.

@item @code{GL_RENDERER}


Returns the name of the renderer.  This name is typically specific to a
particular configuration of a hardware platform.  It does not change
from release to release.

@item @code{GL_VERSION}


Returns a version or release number.

@item @code{GL_SHADING_LANGUAGE_VERSION}


Returns a version or release number for the shading language.

@item @code{GL_EXTENSIONS}


Returns a space-separated list of supported extensions to GL.

@end table

Because the GL does not include queries for the performance
characteristics of an implementation, some applications are written to
recognize known platforms and modify their GL usage based on known
performance characteristics of these platforms.  Strings
@code{GL_VENDOR} and @code{GL_RENDERER} together uniquely specify a
platform.  They do not change from release to release and should be used
by platform-recognition algorithms.

Some applications want to make use of features that are not part of the
standard GL.  These features may be implemented as extensions to the
standard GL.  The @code{GL_EXTENSIONS} string is a space-separated list
of supported GL extensions.  (Extension names never contain a space
character.)

The @code{GL_VERSION} and @code{GL_SHADING_LANGUAGE_VERSION} strings
begin with a version number.  The version number uses one of these
forms:

@var{major_number.minor_number}@var{major_number.minor_number.release_number}

Vendor-specific information may follow the version number.  Its format
depends on the implementation, but a space always separates the version
number and the vendor-specific information.

All strings are null-terminated.

@code{GL_INVALID_ENUM} is generated if @var{name} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetString} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetTexEnvfv target pname params
@deftypefunx void glGetTexEnviv target pname params
Return texture environment parameters.

@table @asis
@item @var{target}
Specifies a texture environment.  May be @code{GL_TEXTURE_ENV},
@code{GL_TEXTURE_FILTER_CONTROL}, or @code{GL_POINT_SPRITE}.

@item @var{pname}
Specifies the symbolic name of a texture environment parameter.  Accepted
values are @code{GL_TEXTURE_ENV_MODE}, @code{GL_TEXTURE_ENV_COLOR},
@code{GL_TEXTURE_LOD_BIAS}, @code{GL_COMBINE_RGB},
@code{GL_COMBINE_ALPHA}, @code{GL_SRC0_RGB}, @code{GL_SRC1_RGB},
@code{GL_SRC2_RGB}, @code{GL_SRC0_ALPHA}, @code{GL_SRC1_ALPHA},
@code{GL_SRC2_ALPHA}, @code{GL_OPERAND0_RGB}, @code{GL_OPERAND1_RGB},
@code{GL_OPERAND2_RGB}, @code{GL_OPERAND0_ALPHA},
@code{GL_OPERAND1_ALPHA}, @code{GL_OPERAND2_ALPHA}, @code{GL_RGB_SCALE},
@code{GL_ALPHA_SCALE}, or @code{GL_COORD_REPLACE}.

@item @var{params}
Returns the requested data.

@end table

@code{glGetTexEnv} returns in @var{params} selected values of a texture
environment that was specified with @code{glTexEnv}.  @var{target}
specifies a texture environment.

When @var{target} is @code{GL_TEXTURE_FILTER_CONTROL}, @var{pname} must
be @code{GL_TEXTURE_LOD_BIAS}.  When @var{target} is
@code{GL_POINT_SPRITE}, @var{pname} must be @code{GL_COORD_REPLACE}.
When @var{target} is @code{GL_TEXTURE_ENV}, @var{pname} can be
@code{GL_TEXTURE_ENV_MODE}, @code{GL_TEXTURE_ENV_COLOR},
@code{GL_COMBINE_RGB}, @code{GL_COMBINE_ALPHA}, @code{GL_RGB_SCALE},
@code{GL_ALPHA_SCALE}, @code{GL_SRC0_RGB}, @code{GL_SRC1_RGB},
@code{GL_SRC2_RGB}, @code{GL_SRC0_ALPHA}, @code{GL_SRC1_ALPHA}, or
@code{GL_SRC2_ALPHA}.

@var{pname} names a specific texture environment parameter, as follows:

@table @asis
@item @code{GL_TEXTURE_ENV_MODE}
@var{params} returns the single-valued texture environment mode, a
symbolic constant.  The initial value is @code{GL_MODULATE}.

@item @code{GL_TEXTURE_ENV_COLOR}
@var{params} returns four integer or floating-point values that are the
texture environment color.  Integer values, when requested, are linearly
mapped from the internal floating-point representation such that 1.0
maps to the most positive representable integer, and @r{-1.0} maps to
the most negative representable integer.  The initial value is (0, 0, 0,
0).

@item @code{GL_TEXTURE_LOD_BIAS}
@var{params} returns a single floating-point value that is the texture
level-of-detail bias.  The initial value is 0.

@item @code{GL_COMBINE_RGB}
@var{params} returns a single symbolic constant value representing the
current RGB combine mode.  The initial value is @code{GL_MODULATE}.

@item @code{GL_COMBINE_ALPHA}
@var{params} returns a single symbolic constant value representing the
current alpha combine mode.  The initial value is @code{GL_MODULATE}.

@item @code{GL_SRC0_RGB}
@var{params} returns a single symbolic constant value representing the
texture combiner zero's RGB source.  The initial value is
@code{GL_TEXTURE}.

@item @code{GL_SRC1_RGB}
@var{params} returns a single symbolic constant value representing the
texture combiner one's RGB source.  The initial value is
@code{GL_PREVIOUS}.

@item @code{GL_SRC2_RGB}
@var{params} returns a single symbolic constant value representing the
texture combiner two's RGB source.  The initial value is
@code{GL_CONSTANT}.

@item @code{GL_SRC0_ALPHA}
@var{params} returns a single symbolic constant value representing the
texture combiner zero's alpha source.  The initial value is
@code{GL_TEXTURE}.

@item @code{GL_SRC1_ALPHA}
@var{params} returns a single symbolic constant value representing the
texture combiner one's alpha source.  The initial value is
@code{GL_PREVIOUS}.

@item @code{GL_SRC2_ALPHA}
@var{params} returns a single symbolic constant value representing the
texture combiner two's alpha source.  The initial value is
@code{GL_CONSTANT}.

@item @code{GL_OPERAND0_RGB}
@var{params} returns a single symbolic constant value representing the
texture combiner zero's RGB operand.  The initial value is
@code{GL_SRC_COLOR}.

@item @code{GL_OPERAND1_RGB}
@var{params} returns a single symbolic constant value representing the
texture combiner one's RGB operand.  The initial value is
@code{GL_SRC_COLOR}.

@item @code{GL_OPERAND2_RGB}
@var{params} returns a single symbolic constant value representing the
texture combiner two's RGB operand.  The initial value is
@code{GL_SRC_ALPHA}.

@item @code{GL_OPERAND0_ALPHA}
@var{params} returns a single symbolic constant value representing the
texture combiner zero's alpha operand.  The initial value is
@code{GL_SRC_ALPHA}.

@item @code{GL_OPERAND1_ALPHA}
@var{params} returns a single symbolic constant value representing the
texture combiner one's alpha operand.  The initial value is
@code{GL_SRC_ALPHA}.

@item @code{GL_OPERAND2_ALPHA}
@var{params} returns a single symbolic constant value representing the
texture combiner two's alpha operand.  The initial value is
@code{GL_SRC_ALPHA}.

@item @code{GL_RGB_SCALE}
@var{params} returns a single floating-point value representing the
current RGB texture combiner scaling factor.  The initial value is 1.0.

@item @code{GL_ALPHA_SCALE}
@var{params} returns a single floating-point value representing the
current alpha texture combiner scaling factor.  The initial value is
1.0.

@item @code{GL_COORD_REPLACE}
@var{params} returns a single boolean value representing the current
point sprite texture coordinate replacement enable state.  The initial
value is @code{GL_FALSE}.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetTexEnv} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetTexGendv coord pname params
@deftypefunx void glGetTexGenfv coord pname params
@deftypefunx void glGetTexGeniv coord pname params
Return texture coordinate generation parameters.

@table @asis
@item @var{coord}
Specifies a texture coordinate.  Must be @code{GL_S}, @code{GL_T},
@code{GL_R}, or @code{GL_Q}.

@item @var{pname}
Specifies the symbolic name of the value(s) to be returned.  Must be
either @code{GL_TEXTURE_GEN_MODE} or the name of one of the texture
generation plane equations: @code{GL_OBJECT_PLANE} or
@code{GL_EYE_PLANE}.

@item @var{params}
Returns the requested data.

@end table

@code{glGetTexGen} returns in @var{params} selected parameters of a
texture coordinate generation function that was specified using
@code{glTexGen}.  @var{coord} names one of the (@var{s}, @var{t},
@var{r}, @var{q}) texture coordinates, using the symbolic constant
@code{GL_S}, @code{GL_T}, @code{GL_R}, or @code{GL_Q}.

@var{pname} specifies one of three symbolic names:

@table @asis
@item @code{GL_TEXTURE_GEN_MODE}
@var{params} returns the single-valued texture generation function, a
symbolic constant.  The initial value is @code{GL_EYE_LINEAR}.

@item @code{GL_OBJECT_PLANE}
@var{params} returns the four plane equation coefficients that specify
object linear-coordinate generation.  Integer values, when requested,
are mapped directly from the internal floating-point representation.

@item @code{GL_EYE_PLANE}
@var{params} returns the four plane equation coefficients that specify
eye linear-coordinate generation.  Integer values, when requested, are
mapped directly from the internal floating-point representation.  The
returned values are those maintained in eye coordinates.  They are not
equal to the values specified using @code{glTexGen}, unless the
modelview matrix was identity when @code{glTexGen} was called.

@end table

@code{GL_INVALID_ENUM} is generated if @var{coord} or @var{pname} is not
an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetTexGen} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetTexImage target level format type img
Return a texture image.

@table @asis
@item @var{target}
Specifies which texture is to be obtained.  @code{GL_TEXTURE_1D},
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_3D},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, and
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z} are accepted.

@item @var{level}
Specifies the level-of-detail number of the desired image.  Level 0 is
the base image level.  Level @r{@var{n}} is the @r{@var{n}}th mipmap
reduction image.

@item @var{format}
Specifies a pixel format for the returned data.  The supported formats
are @code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE}, @code{GL_ALPHA},
@code{GL_RGB}, @code{GL_BGR}, @code{GL_RGBA}, @code{GL_BGRA},
@code{GL_LUMINANCE}, and @code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies a pixel type for the returned data.  The supported types are
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_UNSIGNED_SHORT},
@code{GL_SHORT}, @code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{img}
Returns the texture image.  Should be a pointer to an array of the type
specified by @var{type}.

@end table

@code{glGetTexImage} returns a texture image into @var{img}.
@var{target} specifies whether the desired texture image is one
specified by @code{glTexImage1D} (@code{GL_TEXTURE_1D}),
@code{glTexImage2D} (@code{GL_TEXTURE_2D} or any of
@code{GL_TEXTURE_CUBE_MAP_*}), or @code{glTexImage3D}
(@code{GL_TEXTURE_3D}).  @var{level} specifies the level-of-detail
number of the desired image.  @var{format} and @var{type} specify the
format and type of the desired image array.  See the reference pages
@code{glTexImage1D} and @code{glDrawPixels} for a description of the
acceptable values for the @var{format} and @var{type} parameters,
respectively.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is requested, @var{img} is treated as a byte offset into
the buffer object's data store.

To understand the operation of @code{glGetTexImage}, consider the
selected internal four-component texture image to be an RGBA color
buffer the size of the image.  The semantics of @code{glGetTexImage} are
then identical to those of @code{glReadPixels}, with the exception that
no pixel transfer operations are performed, when called with the same
@var{format} and @var{type}, with @var{x} and @var{y} set to 0,
@var{width} set to the width of the texture image (including border if
one was specified), and @var{height} set to 1 for 1D images, or to the
height of the texture image (including border if one was specified) for
2D images.  Because the internal texture image is an RGBA image, pixel
formats @code{GL_COLOR_INDEX}, @code{GL_STENCIL_INDEX}, and
@code{GL_DEPTH_COMPONENT} are not accepted, and pixel type
@code{GL_BITMAP} is not accepted.

If the selected texture image does not contain four components, the
following mappings are applied.  Single-component textures are treated
as RGBA buffers with red set to the single-component value, green set to
0, blue set to 0, and alpha set to 1.  Two-component textures are
treated as RGBA buffers with red set to the value of component zero,
alpha set to the value of component one, and green and blue set to 0.
Finally, three-component textures are treated as RGBA buffers with red
set to component zero, green set to component one, blue set to component
two, and alpha set to 1.

To determine the required size of @var{img}, use
@code{glGetTexLevelParameter} to determine the dimensions of the
internal texture image, then scale the required number of pixels by the
storage required for each pixel, based on @var{format} and @var{type}.
Be sure to take the pixel storage parameters into account, especially
@code{GL_PACK_ALIGNMENT}.

@code{GL_INVALID_ENUM} is generated if @var{target}, @var{format}, or
@var{type} is not an accepted value.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2⁡(@var{max},)}, where @r{@var{max}} is the returned value
of @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_OPERATION} is returned if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is returned if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV}, and @var{format} is neither
@code{GL_RGBA} or @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and @var{img} is
not evenly divisible into the number of bytes needed to store in memory
a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glGetTexImage} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetTexLevelParameterfv target level pname params
@deftypefunx void glGetTexLevelParameteriv target level pname params
Return texture parameter values for a specific level of detail.

@table @asis
@item @var{target}
Specifies the symbolic name of the target texture, either
@code{GL_TEXTURE_1D}, @code{GL_TEXTURE_2D}, @code{GL_TEXTURE_3D},
@code{GL_PROXY_TEXTURE_1D}, @code{GL_PROXY_TEXTURE_2D},
@code{GL_PROXY_TEXTURE_3D}, @code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or
@code{GL_PROXY_TEXTURE_CUBE_MAP}.

@item @var{level}
Specifies the level-of-detail number of the desired image.  Level 0 is
the base image level.  Level @r{@var{n}} is the @r{@var{n}}th mipmap
reduction image.

@item @var{pname}
Specifies the symbolic name of a texture parameter.
@code{GL_TEXTURE_WIDTH}, @code{GL_TEXTURE_HEIGHT},
@code{GL_TEXTURE_DEPTH}, @code{GL_TEXTURE_INTERNAL_FORMAT},
@code{GL_TEXTURE_BORDER}, @code{GL_TEXTURE_RED_SIZE},
@code{GL_TEXTURE_GREEN_SIZE}, @code{GL_TEXTURE_BLUE_SIZE},
@code{GL_TEXTURE_ALPHA_SIZE}, @code{GL_TEXTURE_LUMINANCE_SIZE},
@code{GL_TEXTURE_INTENSITY_SIZE}, @code{GL_TEXTURE_DEPTH_SIZE},
@code{GL_TEXTURE_COMPRESSED}, and
@code{GL_TEXTURE_COMPRESSED_IMAGE_SIZE} are accepted.

@item @var{params}
Returns the requested data.

@end table

@code{glGetTexLevelParameter} returns in @var{params} texture parameter
values for a specific level-of-detail value, specified as @var{level}.
@var{target} defines the target texture, either @code{GL_TEXTURE_1D},
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_3D}, @code{GL_PROXY_TEXTURE_1D},
@code{GL_PROXY_TEXTURE_2D}, @code{GL_PROXY_TEXTURE_3D},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or
@code{GL_PROXY_TEXTURE_CUBE_MAP}.

@code{GL_MAX_TEXTURE_SIZE}, and @code{GL_MAX_3D_TEXTURE_SIZE} are not
really descriptive enough.  It has to report the largest square texture
image that can be accommodated with mipmaps and borders, but a long
skinny texture, or a texture without mipmaps and borders, may easily fit
in texture memory.  The proxy targets allow the user to more accurately
query whether the GL can accommodate a texture of a given configuration.
If the texture cannot be accommodated, the texture state variables,
which may be queried with @code{glGetTexLevelParameter}, are set to 0.
If the texture can be accommodated, the texture state values will be set
as they would be set for a non-proxy target.

@var{pname} specifies the texture parameter whose value or values will
be returned.

The accepted parameter names are as follows:

@table @asis
@item @code{GL_TEXTURE_WIDTH}


@var{params} returns a single value, the width of the texture image.
This value includes the border of the texture image.  The initial value
is 0.

@item @code{GL_TEXTURE_HEIGHT}


@var{params} returns a single value, the height of the texture image.
This value includes the border of the texture image.  The initial value
is 0.

@item @code{GL_TEXTURE_DEPTH}


@var{params} returns a single value, the depth of the texture image.
This value includes the border of the texture image.  The initial value
is 0.

@item @code{GL_TEXTURE_INTERNAL_FORMAT}


@var{params} returns a single value, the internal format of the texture
image.

@item @code{GL_TEXTURE_BORDER}


@var{params} returns a single value, the width in pixels of the border
of the texture image.  The initial value is 0.

@item @code{GL_TEXTURE_RED_SIZE},
@item @code{GL_TEXTURE_GREEN_SIZE},
@item @code{GL_TEXTURE_BLUE_SIZE},
@item @code{GL_TEXTURE_ALPHA_SIZE},
@item @code{GL_TEXTURE_LUMINANCE_SIZE},
@item @code{GL_TEXTURE_INTENSITY_SIZE},
@item @code{GL_TEXTURE_DEPTH_SIZE}


The internal storage resolution of an individual component.  The
resolution chosen by the GL will be a close match for the resolution
requested by the user with the component argument of
@code{glTexImage1D}, @code{glTexImage2D}, @code{glTexImage3D},
@code{glCopyTexImage1D}, and @code{glCopyTexImage2D}.  The initial value
is 0.

@item @code{GL_TEXTURE_COMPRESSED}


@var{params} returns a single boolean value indicating if the texture
image is stored in a compressed internal format.  The initiali value is
@code{GL_FALSE}.

@item @code{GL_TEXTURE_COMPRESSED_IMAGE_SIZE}


@var{params} returns a single integer value, the number of unsigned
bytes of the compressed texture image that would be returned from
@code{glGetCompressedTexImage}.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not an accepted value.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2}@var{max}, where @var{max} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_OPERATION} is generated if
@code{glGetTexLevelParameter} is executed between the execution of
@code{glBegin} and the corresponding execution of @code{glEnd}.

@code{GL_INVALID_OPERATION} is generated if
@code{GL_TEXTURE_COMPRESSED_IMAGE_SIZE} is queried on texture images
with an uncompressed internal format or on proxy targets.

@end deftypefun

@deftypefun void glGetTexParameterfv target pname params
@deftypefunx void glGetTexParameteriv target pname params
Return texture parameter values.

@table @asis
@item @var{target}
Specifies the symbolic name of the target texture.  @code{GL_TEXTURE_1D},
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_3D}, and
@code{GL_TEXTURE_CUBE_MAP} are accepted.

@item @var{pname}
Specifies the symbolic name of a texture parameter.
@code{GL_TEXTURE_MAG_FILTER}, @code{GL_TEXTURE_MIN_FILTER},
@code{GL_TEXTURE_MIN_LOD}, @code{GL_TEXTURE_MAX_LOD},
@code{GL_TEXTURE_BASE_LEVEL}, @code{GL_TEXTURE_MAX_LEVEL},
@code{GL_TEXTURE_WRAP_S}, @code{GL_TEXTURE_WRAP_T},
@code{GL_TEXTURE_WRAP_R}, @code{GL_TEXTURE_BORDER_COLOR},
@code{GL_TEXTURE_PRIORITY}, @code{GL_TEXTURE_RESIDENT},
@code{GL_TEXTURE_COMPARE_MODE}, @code{GL_TEXTURE_COMPARE_FUNC},
@code{GL_DEPTH_TEXTURE_MODE}, and @code{GL_GENERATE_MIPMAP} are
accepted.

@item @var{params}
Returns the texture parameters.

@end table

@code{glGetTexParameter} returns in @var{params} the value or values of
the texture parameter specified as @var{pname}.  @var{target} defines
the target texture, either @code{GL_TEXTURE_1D}, @code{GL_TEXTURE_2D},
@code{GL_TEXTURE_3D}, or @code{GL_TEXTURE_CUBE_MAP}, to specify one-,
two-, or three-dimensional or cube-mapped texturing.  @var{pname}
accepts the same symbols as @code{glTexParameter}, with the same
interpretations:

@table @asis
@item @code{GL_TEXTURE_MAG_FILTER}
Returns the single-valued texture magnification filter, a symbolic
constant.  The initial value is @code{GL_LINEAR}.

@item @code{GL_TEXTURE_MIN_FILTER}
Returns the single-valued texture minification filter, a symbolic
constant.  The initial value is @code{GL_NEAREST_MIPMAP_LINEAR}.

@item @code{GL_TEXTURE_MIN_LOD}
Returns the single-valued texture minimum level-of-detail value.  The
initial value is @r{-1000}.

@item @code{GL_TEXTURE_MAX_LOD}
Returns the single-valued texture maximum level-of-detail value.  The
initial value is 1000.

@item @code{GL_TEXTURE_BASE_LEVEL}
Returns the single-valued base texture mipmap level.  The initial value
is 0.

@item @code{GL_TEXTURE_MAX_LEVEL}
Returns the single-valued maximum texture mipmap array level.  The
initial value is 1000.

@item @code{GL_TEXTURE_WRAP_S}
Returns the single-valued wrapping function for texture coordinate
@r{@var{s}}, a symbolic constant.  The initial value is
@code{GL_REPEAT}.

@item @code{GL_TEXTURE_WRAP_T}
Returns the single-valued wrapping function for texture coordinate
@r{@var{t}}, a symbolic constant.  The initial value is
@code{GL_REPEAT}.

@item @code{GL_TEXTURE_WRAP_R}
Returns the single-valued wrapping function for texture coordinate
@r{@var{r}}, a symbolic constant.  The initial value is
@code{GL_REPEAT}.

@item @code{GL_TEXTURE_BORDER_COLOR}
Returns four integer or floating-point numbers that comprise the RGBA
color of the texture border.  Floating-point values are returned in the
range @r{[0,1]}.  Integer values are returned as a linear mapping of the
internal floating-point representation such that 1.0 maps to the most
positive representable integer and @r{-1.0} maps to the most negative
representable integer.  The initial value is (0, 0, 0, 0).

@item @code{GL_TEXTURE_PRIORITY}
Returns the residence priority of the target texture (or the named
texture bound to it).  The initial value is 1.  See
@code{glPrioritizeTextures}.

@item @code{GL_TEXTURE_RESIDENT}
Returns the residence status of the target texture.  If the value
returned in @var{params} is @code{GL_TRUE}, the texture is resident in
texture memory.  See @code{glAreTexturesResident}.

@item @code{GL_TEXTURE_COMPARE_MODE}
Returns a single-valued texture comparison mode, a symbolic constant.
The initial value is @code{GL_NONE}.  See @code{glTexParameter}.

@item @code{GL_TEXTURE_COMPARE_FUNC}
Returns a single-valued texture comparison function, a symbolic
constant.  The initial value is @code{GL_LEQUAL}.  See
@code{glTexParameter}.

@item @code{GL_DEPTH_TEXTURE_MODE}
Returns a single-valued texture format indicating how the depth values
should be converted into color components.  The initial value is
@code{GL_LUMINANCE}.  See @code{glTexParameter}.

@item @code{GL_GENERATE_MIPMAP}
Returns a single boolean value indicating if automatic mipmap level
updates are enabled.  See @code{glTexParameter}.

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glGetTexParameter} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLint glGetUniformLocation program name
Returns the location of a uniform variable.

@table @asis
@item @var{program}
Specifies the program object to be queried.

@item @var{name}
Points to a null terminated string containing the name of the uniform
variable whose location is to be queried.

@end table

@code{glGetUniformLocation } returns an integer that represents the
location of a specific uniform variable within a program object.
@var{name} must be a null terminated string that contains no white
space.  @var{name} must be an active uniform variable name in
@var{program} that is not a structure, an array of structures, or a
subcomponent of a vector or a matrix.  This function returns -1 if
@var{name} does not correspond to an active uniform variable in
@var{program} or if @var{name} starts with the reserved prefix "gl_".

Uniform variables that are structures or arrays of structures may be
queried by calling @code{glGetUniformLocation} for each field within the
structure.  The array element operator "[]" and the structure field
operator "." may be used in @var{name} in order to select elements
within an array or fields within a structure.  The result of using these
operators is not allowed to be another structure, an array of
structures, or a subcomponent of a vector or a matrix.  Except if the
last part of @var{name} indicates a uniform variable array, the location
of the first element of an array can be retrieved by using the name of
the array, or by using the name appended by "[0]".

The actual locations assigned to uniform variables are not known until
the program object is linked successfully.  After linking has occurred,
the command @code{glGetUniformLocation} can be used to obtain the
location of a uniform variable.  This location value can then be passed
to @code{glUniform} to set the value of the uniform variable or to
@code{glGetUniform} in order to query the current value of the uniform
variable.  After a program object has been linked successfully, the
index values for uniform variables remain fixed until the next link
command occurs.  Uniform variable locations and values can only be
queried after a link if the link was successful.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @var{program} has not been
successfully linked.

@code{GL_INVALID_OPERATION} is generated if @code{glGetUniformLocation}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetUniformfv program location params
@deftypefunx void glGetUniformiv program location params
Returns the value of a uniform variable.

@table @asis
@item @var{program}
Specifies the program object to be queried.

@item @var{location}
Specifies the location of the uniform variable to be queried.

@item @var{params}
Returns the value of the specified uniform variable.

@end table

@code{glGetUniform} returns in @var{params} the value(s) of the
specified uniform variable.  The type of the uniform variable specified
by @var{location} determines the number of values returned.  If the
uniform variable is defined in the shader as a boolean, int, or float, a
single value will be returned.  If it is defined as a vec2, ivec2, or
bvec2, two values will be returned.  If it is defined as a vec3, ivec3,
or bvec3, three values will be returned, and so on.  To query values
stored in uniform variables declared as arrays, call @code{glGetUniform}
for each element of the array.  To query values stored in uniform
variables declared as structures, call @code{glGetUniform} for each
field in the structure.  The values for uniform variables declared as a
matrix will be returned in column major order.

The locations assigned to uniform variables are not known until the
program object is linked.  After linking has occurred, the command
@code{glGetUniformLocation} can be used to obtain the location of a
uniform variable.  This location value can then be passed to
@code{glGetUniform} in order to query the current value of the uniform
variable.  After a program object has been linked successfully, the
index values for uniform variables remain fixed until the next link
command occurs.  The uniform variable values can only be queried after a
link if the link was successful.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @var{program} has not been
successfully linked.

@code{GL_INVALID_OPERATION} is generated if @var{location} does not
correspond to a valid uniform variable location for the specified
program object.

@code{GL_INVALID_OPERATION} is generated if @code{glGetUniform} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glGetVertexAttribPointerv index pname pointer
Return the address of the specified generic vertex attribute pointer.

@table @asis
@item @var{index}
Specifies the generic vertex attribute parameter to be returned.

@item @var{pname}
Specifies the symbolic name of the generic vertex attribute parameter to
be returned.  Must be @code{GL_VERTEX_ATTRIB_ARRAY_POINTER}.

@item @var{pointer}
Returns the pointer value.

@end table

@code{glGetVertexAttribPointerv} returns pointer information.
@var{index} is the generic vertex attribute to be queried, @var{pname}
is a symbolic constant indicating the pointer to be returned, and
@var{params} is a pointer to a location in which to place the returned
data.

If a non-zero named buffer object was bound to the
@code{GL_ARRAY_BUFFER} target (see @code{glBindBuffer}) when the desired
pointer was previously specified, the @var{pointer} returned is a byte
offset into the buffer object's data store.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to @code{GL_MAX_VERTEX_ATTRIBS}.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@end deftypefun

@deftypefun void glGetVertexAttribdv index pname params
@deftypefunx void glGetVertexAttribfv index pname params
@deftypefunx void glGetVertexAttribiv index pname params
Return a generic vertex attribute parameter.

@table @asis
@item @var{index}
Specifies the generic vertex attribute parameter to be queried.

@item @var{pname}
Specifies the symbolic name of the vertex attribute parameter to be
queried.  Accepted values are
@code{GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING},
@code{GL_VERTEX_ATTRIB_ARRAY_ENABLED},
@code{GL_VERTEX_ATTRIB_ARRAY_SIZE},
@code{GL_VERTEX_ATTRIB_ARRAY_STRIDE},
@code{GL_VERTEX_ATTRIB_ARRAY_TYPE},
@code{GL_VERTEX_ATTRIB_ARRAY_NORMALIZED}, or
@code{GL_CURRENT_VERTEX_ATTRIB}.

@item @var{params}
Returns the requested data.

@end table

@code{glGetVertexAttrib} returns in @var{params} the value of a generic
vertex attribute parameter.  The generic vertex attribute to be queried
is specified by @var{index}, and the parameter to be queried is
specified by @var{pname}.

The accepted parameter names are as follows:

@table @asis
@item @code{GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
currently bound to the binding point corresponding to generic vertex
attribute array @var{index}.  If no buffer object is bound, 0 is
returned.  The initial value is 0.

@item @code{GL_VERTEX_ATTRIB_ARRAY_ENABLED}


@var{params} returns a single value that is non-zero (true) if the
vertex attribute array for @var{index} is enabled and 0 (false) if it is
disabled.  The initial value is @code{GL_FALSE}.

@item @code{GL_VERTEX_ATTRIB_ARRAY_SIZE}


@var{params} returns a single value, the size of the vertex attribute
array for @var{index}.  The size is the number of values for each
element of the vertex attribute array, and it will be 1, 2, 3, or 4.  The
initial value is 4.

@item @code{GL_VERTEX_ATTRIB_ARRAY_STRIDE}


@var{params} returns a single value, the array stride for (number of
bytes between successive elements in) the vertex attribute array for
@var{index}.  A value of 0 indicates that the array elements are stored
sequentially in memory.  The initial value is 0.

@item @code{GL_VERTEX_ATTRIB_ARRAY_TYPE}


@var{params} returns a single value, a symbolic constant indicating the
array type for the vertex attribute array for @var{index}.  Possible
values are @code{GL_BYTE}, @code{GL_UNSIGNED_BYTE}, @code{GL_SHORT},
@code{GL_UNSIGNED_SHORT}, @code{GL_INT}, @code{GL_UNSIGNED_INT},
@code{GL_FLOAT}, and @code{GL_DOUBLE}.  The initial value is
@code{GL_FLOAT}.

@item @code{GL_VERTEX_ATTRIB_ARRAY_NORMALIZED}


@var{params} returns a single value that is non-zero (true) if
fixed-point data types for the vertex attribute array indicated by
@var{index} are normalized when they are converted to floating point,
and 0 (false) otherwise.  The initial value is @code{GL_FALSE}.

@item @code{GL_CURRENT_VERTEX_ATTRIB}


@var{params} returns four values that represent the current value for
the generic vertex attribute specified by index.  Generic vertex
attribute 0 is unique in that it has no current state, so an error will
be generated if @var{index} is 0.  The initial value for all other
generic vertex attributes is (0,0,0,1).

@end table

All of the parameters except @code{GL_CURRENT_VERTEX_ATTRIB} represent
client-side state.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to @code{GL_MAX_VERTEX_ATTRIBS}.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @var{index} is 0 and
@var{pname} is @code{GL_CURRENT_VERTEX_ATTRIB}.

@end deftypefun

@deftypefun void glGetBooleanv pname params
@deftypefunx void glGetDoublev pname params
@deftypefunx void glGetFloatv pname params
@deftypefunx void glGetIntegerv pname params
Return the value or values of a selected parameter.

@table @asis
@item @var{pname}
Specifies the parameter value to be returned.  The symbolic constants in
the list below are accepted.

@item @var{params}
Returns the value or values of the specified parameter.

@end table

These four commands return values for simple state variables in GL.
@var{pname} is a symbolic constant indicating the state variable to be
returned, and @var{params} is a pointer to an array of the indicated
type in which to place the returned data.

Type conversion is performed if @var{params} has a different type than
the state variable value being requested.  If @code{glGetBooleanv} is
called, a floating-point (or integer) value is converted to
@code{GL_FALSE} if and only if it is 0.0 (or 0).  Otherwise, it is
converted to @code{GL_TRUE}.  If @code{glGetIntegerv} is called, boolean
values are returned as @code{GL_TRUE} or @code{GL_FALSE}, and most
floating-point values are rounded to the nearest integer value.
Floating-point colors and normals, however, are returned with a linear
mapping that maps 1.0 to the most positive representable integer value
and @r{-1.0} to the most negative representable integer value.  If
@code{glGetFloatv} or @code{glGetDoublev} is called, boolean values are
returned as @code{GL_TRUE} or @code{GL_FALSE}, and integer values are
converted to floating-point values.

The following symbolic constants are accepted by @var{pname}:

@table @asis
@item @code{GL_ACCUM_ALPHA_BITS}


@var{params} returns one value, the number of alpha bitplanes in the
accumulation buffer.

@item @code{GL_ACCUM_BLUE_BITS}


@var{params} returns one value, the number of blue bitplanes in the
accumulation buffer.

@item @code{GL_ACCUM_CLEAR_VALUE}


@var{params} returns four values: the red, green, blue, and alpha values
used to clear the accumulation buffer.  Integer values, if requested,
are linearly mapped from the internal floating-point representation such
that 1.0 returns the most positive representable integer value, and
@r{-1.0} returns the most negative representable integer value.  The
initial value is (0, 0, 0, 0).  See @code{glClearAccum}.

@item @code{GL_ACCUM_GREEN_BITS}


@var{params} returns one value, the number of green bitplanes in the
accumulation buffer.

@item @code{GL_ACCUM_RED_BITS}


@var{params} returns one value, the number of red bitplanes in the
accumulation buffer.

@item @code{GL_ACTIVE_TEXTURE}


@var{params} returns a single value indicating the active multitexture
unit.  The initial value is @code{GL_TEXTURE0}.  See
@code{glActiveTexture}.

@item @code{GL_ALIASED_POINT_SIZE_RANGE}


@var{params} returns two values, the smallest and largest supported
sizes for aliased points.

@item @code{GL_ALIASED_LINE_WIDTH_RANGE}


@var{params} returns two values, the smallest and largest supported
widths for aliased lines.

@item @code{GL_ALPHA_BIAS}


@var{params} returns one value, the alpha bias factor used during pixel
transfers.  The initial value is 0.  See @code{glPixelTransfer}.

@item @code{GL_ALPHA_BITS}


@var{params} returns one value, the number of alpha bitplanes in each
color buffer.

@item @code{GL_ALPHA_SCALE}


@var{params} returns one value, the alpha scale factor used during pixel
transfers.  The initial value is 1.  See @code{glPixelTransfer}.

@item @code{GL_ALPHA_TEST}


@var{params} returns a single boolean value indicating whether alpha
testing of fragments is enabled.  The initial value is @code{GL_FALSE}.
See @code{glAlphaFunc}.

@item @code{GL_ALPHA_TEST_FUNC}@var{params} returns one value,


the symbolic name of the alpha test function.  The initial value is
@code{GL_ALWAYS}.  See @code{glAlphaFunc}.

@item @code{GL_ALPHA_TEST_REF}


@var{params} returns one value, the reference value for the alpha test.
The initial value is 0.  See @code{glAlphaFunc}.  An integer value, if
requested, is linearly mapped from the internal floating-point
representation such that 1.0 returns the most positive representable
integer value, and @r{-1.0} returns the most negative representable
integer value.

@item @code{GL_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
currently bound to the target @code{GL_ARRAY_BUFFER}.  If no buffer
object is bound to this target, 0 is returned.  The initial value is 0.
See @code{glBindBuffer}.

@item @code{GL_ATTRIB_STACK_DEPTH}


@var{params} returns one value, the depth of the attribute stack.  If
the stack is empty, 0 is returned.  The initial value is 0.  See
@code{glPushAttrib}.

@item @code{GL_AUTO_NORMAL}


@var{params} returns a single boolean value indicating whether 2D map
evaluation automatically generates surface normals.  The initial value
is @code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_AUX_BUFFERS}


@var{params} returns one value, the number of auxiliary color buffers
available.

@item @code{GL_BLEND}


@var{params} returns a single boolean value indicating whether blending
is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glBlendFunc}.

@item @code{GL_BLEND_COLOR}


@var{params} returns four values, the red, green, blue, and alpha values
which are the components of the blend color.  See @code{glBlendColor}.

@item @code{GL_BLEND_DST_ALPHA}


@var{params} returns one value, the symbolic constant identifying the
alpha destination blend function.  The initial value is @code{GL_ZERO}.
See @code{glBlendFunc} and @code{glBlendFuncSeparate}.

@item @code{GL_BLEND_DST_RGB}


@var{params} returns one value, the symbolic constant identifying the
RGB destination blend function.  The initial value is @code{GL_ZERO}.
See @code{glBlendFunc} and @code{glBlendFuncSeparate}.

@item @code{GL_BLEND_EQUATION_RGB}


@var{params} returns one value, a symbolic constant indicating whether
the RGB blend equation is @code{GL_FUNC_ADD}, @code{GL_FUNC_SUBTRACT},
@code{GL_FUNC_REVERSE_SUBTRACT}, @code{GL_MIN} or @code{GL_MAX}.  See
@code{glBlendEquationSeparate}.

@item @code{GL_BLEND_EQUATION_ALPHA}


@var{params} returns one value, a symbolic constant indicating whether
the Alpha blend equation is @code{GL_FUNC_ADD}, @code{GL_FUNC_SUBTRACT},
@code{GL_FUNC_REVERSE_SUBTRACT}, @code{GL_MIN} or @code{GL_MAX}.  See
@code{glBlendEquationSeparate}.

@item @code{GL_BLEND_SRC_ALPHA}


@var{params} returns one value, the symbolic constant identifying the
alpha source blend function.  The initial value is @code{GL_ONE}.  See
@code{glBlendFunc} and @code{glBlendFuncSeparate}.

@item @code{GL_BLEND_SRC_RGB}


@var{params} returns one value, the symbolic constant identifying the
RGB source blend function.  The initial value is @code{GL_ONE}.  See
@code{glBlendFunc} and @code{glBlendFuncSeparate}.

@item @code{GL_BLUE_BIAS}


@var{params} returns one value, the blue bias factor used during pixel
transfers.  The initial value is 0.  See @code{glPixelTransfer}.

@item @code{GL_BLUE_BITS}


@var{params} returns one value, the number of blue bitplanes in each
color buffer.

@item @code{GL_BLUE_SCALE}


@var{params} returns one value, the blue scale factor used during pixel
transfers.  The initial value is 1.  See @code{glPixelTransfer}.

@item @code{GL_CLIENT_ACTIVE_TEXTURE}


@var{params} returns a single integer value indicating the current
client active multitexture unit.  The initial value is
@code{GL_TEXTURE0}.  See @code{glClientActiveTexture}.

@item @code{GL_CLIENT_ATTRIB_STACK_DEPTH}


@var{params} returns one value indicating the depth of the attribute
stack.  The initial value is 0.  See @code{glPushClientAttrib}.

@item @code{GL_CLIP_PLANE}@var{i}


@var{params} returns a single boolean value indicating whether the
specified clipping plane is enabled.  The initial value is
@code{GL_FALSE}.  See @code{glClipPlane}.

@item @code{GL_COLOR_ARRAY}


@var{params} returns a single boolean value indicating whether the color
array is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glColorPointer}.

@item @code{GL_COLOR_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the color array.  This buffer object would have been
bound to the target @code{GL_ARRAY_BUFFER} at the time of the most
recent call to @code{glColorPointer}.  If no buffer object was bound to
this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_COLOR_ARRAY_SIZE}


@var{params} returns one value, the number of components per color in
the color array.  The initial value is 4.  See @code{glColorPointer}.

@item @code{GL_COLOR_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive
colors in the color array.  The initial value is 0.  See
@code{glColorPointer}.

@item @code{GL_COLOR_ARRAY_TYPE}


@var{params} returns one value, the data type of each component in the
color array.  The initial value is @code{GL_FLOAT}.  See
@code{glColorPointer}.

@item @code{GL_COLOR_CLEAR_VALUE}


@var{params} returns four values: the red, green, blue, and alpha values
used to clear the color buffers.  Integer values, if requested, are
linearly mapped from the internal floating-point representation such
that 1.0 returns the most positive representable integer value, and
@r{-1.0} returns the most negative representable integer value.  The
initial value is (0, 0, 0, 0).  See @code{glClearColor}.

@item @code{GL_COLOR_LOGIC_OP}


@var{params} returns a single boolean value indicating whether a
fragment's RGBA color values are merged into the framebuffer using a
logical operation.  The initial value is @code{GL_FALSE}.  See
@code{glLogicOp}.

@item @code{GL_COLOR_MATERIAL}


@var{params} returns a single boolean value indicating whether one or
more material parameters are tracking the current color.  The initial
value is @code{GL_FALSE}.  See @code{glColorMaterial}.

@item @code{GL_COLOR_MATERIAL_FACE}


@var{params} returns one value, a symbolic constant indicating which
materials have a parameter that is tracking the current color.  The
initial value is @code{GL_FRONT_AND_BACK}.  See @code{glColorMaterial}.

@item @code{GL_COLOR_MATERIAL_PARAMETER}


@var{params} returns one value, a symbolic constant indicating which
material parameters are tracking the current color.  The initial value
is @code{GL_AMBIENT_AND_DIFFUSE}.  See @code{glColorMaterial}.

@item @code{GL_COLOR_MATRIX}


@var{params} returns sixteen values: the color matrix on the top of the
color matrix stack.  Initially this matrix is the identity matrix.  See
@code{glPushMatrix}.

@item @code{GL_COLOR_MATRIX_STACK_DEPTH}


@var{params} returns one value, the maximum supported depth of the
projection matrix stack.  The value must be at least 2.  See
@code{glPushMatrix}.

@item @code{GL_COLOR_SUM}


@var{params} returns a single boolean value indicating whether primary
and secondary color sum is enabled.  See @code{glSecondaryColor}.

@item @code{GL_COLOR_TABLE}


@var{params} returns a single boolean value indicating whether the color
table lookup is enabled.  See @code{glColorTable}.

@item @code{GL_COLOR_WRITEMASK}


@var{params} returns four boolean values: the red, green, blue, and
alpha write enables for the color buffers.  The initial value is
(@code{GL_TRUE}, @code{GL_TRUE}, @code{GL_TRUE}, @code{GL_TRUE}).  See
@code{glColorMask}.

@item @code{GL_COMPRESSED_TEXTURE_FORMATS}


@var{params} returns a list of symbolic constants of length
@code{GL_NUM_COMPRESSED_TEXTURE_FORMATS} indicating which compressed
texture formats are available.  See @code{glCompressedTexImage2D}.

@item @code{GL_CONVOLUTION_1D}


@var{params} returns a single boolean value indicating whether 1D
convolution is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glConvolutionFilter1D}.

@item @code{GL_CONVOLUTION_2D}


@var{params} returns a single boolean value indicating whether 2D
convolution is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glConvolutionFilter2D}.

@item @code{GL_CULL_FACE}


@var{params} returns a single boolean value indicating whether polygon
culling is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glCullFace}.

@item @code{GL_CULL_FACE_MODE}


@var{params} returns one value, a symbolic constant indicating which
polygon faces are to be culled.  The initial value is @code{GL_BACK}.
See @code{glCullFace}.

@item @code{GL_CURRENT_COLOR}


@var{params} returns four values: the red, green, blue, and alpha values
of the current color.  Integer values, if requested, are linearly mapped
from the internal floating-point representation such that 1.0 returns
the most positive representable integer value, and @r{-1.0} returns the
most negative representable integer value.  The initial value is (1, 1,
1, 1).  See @code{glColor}.

@item @code{GL_CURRENT_FOG_COORD}


@var{params} returns one value, the current fog coordinate.  The initial
value is 0.  See @code{glFogCoord}.

@item @code{GL_CURRENT_INDEX}


@var{params} returns one value, the current color index.  The initial
value is 1.  See @code{glIndex}.

@item @code{GL_CURRENT_NORMAL}


@var{params} returns three values: the @var{x}, @var{y}, and @var{z}
values of the current normal.  Integer values, if requested, are
linearly mapped from the internal floating-point representation such
that 1.0 returns the most positive representable integer value, and
@r{-1.0} returns the most negative representable integer value.  The
initial value is (0, 0, 1).  See @code{glNormal}.

@item @code{GL_CURRENT_PROGRAM}


@var{params} returns one value, the name of the program object that is
currently active, or 0 if no program object is active.  See
@code{glUseProgram}.

@item @code{GL_CURRENT_RASTER_COLOR}


@var{params} returns four values: the red, green, blue, and alpha color
values of the current raster position.  Integer values, if requested,
are linearly mapped from the internal floating-point representation such
that 1.0 returns the most positive representable integer value, and
@r{-1.0} returns the most negative representable integer value.  The
initial value is (1, 1, 1, 1).  See @code{glRasterPos}.

@item @code{GL_CURRENT_RASTER_DISTANCE}


@var{params} returns one value, the distance from the eye to the current
raster position.  The initial value is 0.  See @code{glRasterPos}.

@item @code{GL_CURRENT_RASTER_INDEX}


@var{params} returns one value, the color index of the current raster
position.  The initial value is 1.  See @code{glRasterPos}.

@item @code{GL_CURRENT_RASTER_POSITION}


@var{params} returns four values: the @var{x}, @var{y}, @var{z}, and
@var{w} components of the current raster position.  @var{x}, @var{y},
and @var{z} are in window coordinates, and @var{w} is in clip
coordinates.  The initial value is (0, 0, 0, 1).  See
@code{glRasterPos}.

@item @code{GL_CURRENT_RASTER_POSITION_VALID}


@var{params} returns a single boolean value indicating whether the
current raster position is valid.  The initial value is @code{GL_TRUE}.
See @code{glRasterPos}.

@item @code{GL_CURRENT_RASTER_SECONDARY_COLOR}


@var{params} returns four values: the red, green, blue, and alpha
secondary color values of the current raster position.  Integer values,
if requested, are linearly mapped from the internal floating-point
representation such that 1.0 returns the most positive representable
integer value, and @r{-1.0} returns the most negative representable
integer value.  The initial value is (1, 1, 1, 1).  See
@code{glRasterPos}.

@item @code{GL_CURRENT_RASTER_TEXTURE_COORDS}


@var{params} returns four values: the @var{s}, @var{t}, @var{r}, and
@var{q} texture coordinates of the current raster position.  The initial
value is (0, 0, 0, 1).  See @code{glRasterPos} and
@code{glMultiTexCoord}.

@item @code{GL_CURRENT_SECONDARY_COLOR}


@var{params} returns four values: the red, green, blue, and alpha values
of the current secondary color.  Integer values, if requested, are
linearly mapped from the internal floating-point representation such
that 1.0 returns the most positive representable integer value, and
@r{-1.0} returns the most negative representable integer value.  The
initial value is (0, 0, 0, 0).  See @code{glSecondaryColor}.

@item @code{GL_CURRENT_TEXTURE_COORDS}


@var{params} returns four values: the @var{s}, @var{t}, @var{r}, and
@var{q} current texture coordinates.  The initial value is (0, 0, 0, 1).
See @code{glMultiTexCoord}.

@item @code{GL_DEPTH_BIAS}


@var{params} returns one value, the depth bias factor used during pixel
transfers.  The initial value is 0.  See @code{glPixelTransfer}.

@item @code{GL_DEPTH_BITS}


@var{params} returns one value, the number of bitplanes in the depth
buffer.

@item @code{GL_DEPTH_CLEAR_VALUE}


@var{params} returns one value, the value that is used to clear the
depth buffer.  Integer values, if requested, are linearly mapped from
the internal floating-point representation such that 1.0 returns the
most positive representable integer value, and @r{-1.0} returns the most
negative representable integer value.  The initial value is 1.  See
@code{glClearDepth}.

@item @code{GL_DEPTH_FUNC}


@var{params} returns one value, the symbolic constant that indicates the
depth comparison function.  The initial value is @code{GL_LESS}.  See
@code{glDepthFunc}.

@item @code{GL_DEPTH_RANGE}


@var{params} returns two values: the near and far mapping limits for the
depth buffer.  Integer values, if requested, are linearly mapped from
the internal floating-point representation such that 1.0 returns the
most positive representable integer value, and @r{-1.0} returns the most
negative representable integer value.  The initial value is (0, 1).  See
@code{glDepthRange}.

@item @code{GL_DEPTH_SCALE}


@var{params} returns one value, the depth scale factor used during pixel
transfers.  The initial value is 1.  See @code{glPixelTransfer}.

@item @code{GL_DEPTH_TEST}


@var{params} returns a single boolean value indicating whether depth
testing of fragments is enabled.  The initial value is @code{GL_FALSE}.
See @code{glDepthFunc} and @code{glDepthRange}.

@item @code{GL_DEPTH_WRITEMASK}


@var{params} returns a single boolean value indicating if the depth
buffer is enabled for writing.  The initial value is @code{GL_TRUE}.  See
@code{glDepthMask}.

@item @code{GL_DITHER}


@var{params} returns a single boolean value indicating whether dithering
of fragment colors and indices is enabled.  The initial value is
@code{GL_TRUE}.

@item @code{GL_DOUBLEBUFFER}


@var{params} returns a single boolean value indicating whether double
buffering is supported.

@item @code{GL_DRAW_BUFFER}


@var{params} returns one value, a symbolic constant indicating which
buffers are being drawn to.  See @code{glDrawBuffer}.  The initial value
is @code{GL_BACK} if there are back buffers, otherwise it is
@code{GL_FRONT}.

@item @code{GL_DRAW_BUFFER}@var{i}


@var{params} returns one value, a symbolic constant indicating which
buffers are being drawn to by the corresponding output color.  See
@code{glDrawBuffers}.  The initial value of @code{GL_DRAW_BUFFER0} is
@code{GL_BACK} if there are back buffers, otherwise it is
@code{GL_FRONT}.  The initial values of draw buffers for all other
output colors is @code{GL_NONE}.

@item @code{GL_EDGE_FLAG}


@var{params} returns a single boolean value indicating whether the
current edge flag is @code{GL_TRUE} or @code{GL_FALSE}.  The initial
value is @code{GL_TRUE}.  See @code{glEdgeFlag}.

@item @code{GL_EDGE_FLAG_ARRAY}


@var{params} returns a single boolean value indicating whether the edge
flag array is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glEdgeFlagPointer}.

@item @code{GL_EDGE_FLAG_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the edge flag array.  This buffer object would have been
bound to the target @code{GL_ARRAY_BUFFER} at the time of the most
recent call to @code{glEdgeFlagPointer}.  If no buffer object was bound
to this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_EDGE_FLAG_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive edge
flags in the edge flag array.  The initial value is 0.  See
@code{glEdgeFlagPointer}.

@item @code{GL_ELEMENT_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
currently bound to the target @code{GL_ELEMENT_ARRAY_BUFFER}.  If no
buffer object is bound to this target, 0 is returned.  The initial value
is 0.  See @code{glBindBuffer}.

@item @code{GL_FEEDBACK_BUFFER_SIZE}


@var{params} returns one value, the size of the feedback buffer.  See
@code{glFeedbackBuffer}.

@item @code{GL_FEEDBACK_BUFFER_TYPE}


@var{params} returns one value, the type of the feedback buffer.  See
@code{glFeedbackBuffer}.

@item @code{GL_FOG}


@var{params} returns a single boolean value indicating whether fogging
is enabled.  The initial value is @code{GL_FALSE}.  See @code{glFog}.

@item @code{GL_FOG_COORD_ARRAY}


@var{params} returns a single boolean value indicating whether the fog
coordinate array is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glFogCoordPointer}.

@item @code{GL_FOG_COORD_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the fog coordinate array.  This buffer object would have
been bound to the target @code{GL_ARRAY_BUFFER} at the time of the most
recent call to @code{glFogCoordPointer}.  If no buffer object was bound
to this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_FOG_COORD_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive fog
coordinates in the fog coordinate array.  The initial value is 0.  See
@code{glFogCoordPointer}.

@item @code{GL_FOG_COORD_ARRAY_TYPE}


@var{params} returns one value, the type of the fog coordinate array.
The initial value is @code{GL_FLOAT}.  See @code{glFogCoordPointer}.

@item @code{GL_FOG_COORD_SRC}


@var{params} returns one value, a symbolic constant indicating the
source of the fog coordinate.  The initial value is
@code{GL_FRAGMENT_DEPTH}.  See @code{glFog}.

@item @code{GL_FOG_COLOR}


@var{params} returns four values: the red, green, blue, and alpha
components of the fog color.  Integer values, if requested, are linearly
mapped from the internal floating-point representation such that 1.0
returns the most positive representable integer value, and @r{-1.0}
returns the most negative representable integer value.  The initial
value is (0, 0, 0, 0).  See @code{glFog}.

@item @code{GL_FOG_DENSITY}


@var{params} returns one value, the fog density parameter.  The initial
value is 1.  See @code{glFog}.

@item @code{GL_FOG_END}


@var{params} returns one value, the end factor for the linear fog
equation.  The initial value is 1.  See @code{glFog}.

@item @code{GL_FOG_HINT}


@var{params} returns one value, a symbolic constant indicating the mode
of the fog hint.  The initial value is @code{GL_DONT_CARE}.  See
@code{glHint}.

@item @code{GL_FOG_INDEX}


@var{params} returns one value, the fog color index.  The initial value
is 0.  See @code{glFog}.

@item @code{GL_FOG_MODE}


@var{params} returns one value, a symbolic constant indicating which fog
equation is selected.  The initial value is @code{GL_EXP}.  See
@code{glFog}.

@item @code{GL_FOG_START}


@var{params} returns one value, the start factor for the linear fog
equation.  The initial value is 0.  See @code{glFog}.

@item @code{GL_FRAGMENT_SHADER_DERIVATIVE_HINT}


@var{params} returns one value, a symbolic constant indicating the mode
of the derivative accuracy hint for fragment shaders.  The initial value
is @code{GL_DONT_CARE}.  See @code{glHint}.

@item @code{GL_FRONT_FACE}


@var{params} returns one value, a symbolic constant indicating whether
clockwise or counterclockwise polygon winding is treated as
front-facing.  The initial value is @code{GL_CCW}.  See
@code{glFrontFace}.

@item @code{GL_GENERATE_MIPMAP_HINT}


@var{params} returns one value, a symbolic constant indicating the mode
of the mipmap generation filtering hint.  The initial value is
@code{GL_DONT_CARE}.  See @code{glHint}.

@item @code{GL_GREEN_BIAS}


@var{params} returns one value, the green bias factor used during pixel
transfers.  The initial value is 0.

@item @code{GL_GREEN_BITS}


@var{params} returns one value, the number of green bitplanes in each
color buffer.

@item @code{GL_GREEN_SCALE}


@var{params} returns one value, the green scale factor used during pixel
transfers.  The initial value is 1.  See @code{glPixelTransfer}.

@item @code{GL_HISTOGRAM}


@var{params} returns a single boolean value indicating whether histogram
is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glHistogram}.

@item @code{GL_INDEX_ARRAY}


@var{params} returns a single boolean value indicating whether the color
index array is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glIndexPointer}.

@item @code{GL_INDEX_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the color index array.  This buffer object would have
been bound to the target @code{GL_ARRAY_BUFFER} at the time of the most
recent call to @code{glIndexPointer}.  If no buffer object was bound to
this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_INDEX_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive
color indexes in the color index array.  The initial value is 0.  See
@code{glIndexPointer}.

@item @code{GL_INDEX_ARRAY_TYPE}


@var{params} returns one value, the data type of indexes in the color
index array.  The initial value is @code{GL_FLOAT}.  See
@code{glIndexPointer}.

@item @code{GL_INDEX_BITS}


@var{params} returns one value, the number of bitplanes in each color
index buffer.

@item @code{GL_INDEX_CLEAR_VALUE}


@var{params} returns one value, the color index used to clear the color
index buffers.  The initial value is 0.  See @code{glClearIndex}.

@item @code{GL_INDEX_LOGIC_OP}


@var{params} returns a single boolean value indicating whether a
fragment's index values are merged into the framebuffer using a logical
operation.  The initial value is @code{GL_FALSE}.  See @code{glLogicOp}.

@item @code{GL_INDEX_MODE}


@var{params} returns a single boolean value indicating whether the GL is
in color index mode (@code{GL_TRUE}) or RGBA mode (@code{GL_FALSE}).

@item @code{GL_INDEX_OFFSET}


@var{params} returns one value, the offset added to color and stencil
indices during pixel transfers.  The initial value is 0.  See
@code{glPixelTransfer}.

@item @code{GL_INDEX_SHIFT}


@var{params} returns one value, the amount that color and stencil
indices are shifted during pixel transfers.  The initial value is 0.  See
@code{glPixelTransfer}.

@item @code{GL_INDEX_WRITEMASK}


@var{params} returns one value, a mask indicating which bitplanes of
each color index buffer can be written.  The initial value is all 1's.
See @code{glIndexMask}.

@item @code{GL_LIGHT}@var{i}


@var{params} returns a single boolean value indicating whether the
specified light is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glLight} and @code{glLightModel}.

@item @code{GL_LIGHTING}


@var{params} returns a single boolean value indicating whether lighting
is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glLightModel}.

@item @code{GL_LIGHT_MODEL_AMBIENT}


@var{params} returns four values: the red, green, blue, and alpha
components of the ambient intensity of the entire scene.  Integer
values, if requested, are linearly mapped from the internal
floating-point representation such that 1.0 returns the most positive
representable integer value, and @r{-1.0} returns the most negative
representable integer value.  The initial value is (0.2, 0.2, 0.2, 1.0).
See @code{glLightModel}.

@item @code{GL_LIGHT_MODEL_COLOR_CONTROL}


@var{params} returns single enumerated value indicating whether specular
reflection calculations are separated from normal lighting computations.
The initial value is @code{GL_SINGLE_COLOR}.

@item @code{GL_LIGHT_MODEL_LOCAL_VIEWER}


@var{params} returns a single boolean value indicating whether specular
reflection calculations treat the viewer as being local to the scene.
The initial value is @code{GL_FALSE}.  See @code{glLightModel}.

@item @code{GL_LIGHT_MODEL_TWO_SIDE}


@var{params} returns a single boolean value indicating whether separate
materials are used to compute lighting for front- and back-facing
polygons.  The initial value is @code{GL_FALSE}.  See
@code{glLightModel}.

@item @code{GL_LINE_SMOOTH}


@var{params} returns a single boolean value indicating whether
antialiasing of lines is enabled.  The initial value is @code{GL_FALSE}.
See @code{glLineWidth}.

@item @code{GL_LINE_SMOOTH_HINT}


@var{params} returns one value, a symbolic constant indicating the mode
of the line antialiasing hint.  The initial value is
@code{GL_DONT_CARE}.  See @code{glHint}.

@item @code{GL_LINE_STIPPLE}


@var{params} returns a single boolean value indicating whether stippling
of lines is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glLineStipple}.

@item @code{GL_LINE_STIPPLE_PATTERN}


@var{params} returns one value, the 16-bit line stipple pattern.  The
initial value is all 1's.  See @code{glLineStipple}.

@item @code{GL_LINE_STIPPLE_REPEAT}


@var{params} returns one value, the line stipple repeat factor.  The
initial value is 1.  See @code{glLineStipple}.

@item @code{GL_LINE_WIDTH}


@var{params} returns one value, the line width as specified with
@code{glLineWidth}.  The initial value is 1.

@item @code{GL_LINE_WIDTH_GRANULARITY}


@var{params} returns one value, the width difference between adjacent
supported widths for antialiased lines.  See @code{glLineWidth}.

@item @code{GL_LINE_WIDTH_RANGE}


@var{params} returns two values: the smallest and largest supported
widths for antialiased lines.  See @code{glLineWidth}.

@item @code{GL_LIST_BASE}


@var{params} returns one value, the base offset added to all names in
arrays presented to @code{glCallLists}.  The initial value is 0.  See
@code{glListBase}.

@item @code{GL_LIST_INDEX}


@var{params} returns one value, the name of the display list currently
under construction.  0 is returned if no display list is currently under
construction.  The initial value is 0.  See @code{glNewList}.

@item @code{GL_LIST_MODE}


@var{params} returns one value, a symbolic constant indicating the
construction mode of the display list currently under construction.  The
initial value is 0.  See @code{glNewList}.

@item @code{GL_LOGIC_OP_MODE}


@var{params} returns one value, a symbolic constant indicating the
selected logic operation mode.  The initial value is @code{GL_COPY}.  See
@code{glLogicOp}.

@item @code{GL_MAP1_COLOR_4}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates colors.  The initial value is @code{GL_FALSE}.  See
@code{glMap1}.

@item @code{GL_MAP1_GRID_DOMAIN}


@var{params} returns two values: the endpoints of the 1D map's grid
domain.  The initial value is (0, 1).  See @code{glMapGrid}.

@item @code{GL_MAP1_GRID_SEGMENTS}


@var{params} returns one value, the number of partitions in the 1D map's
grid domain.  The initial value is 1.  See @code{glMapGrid}.

@item @code{GL_MAP1_INDEX}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates color indices.  The initial value is
@code{GL_FALSE}.  See @code{glMap1}.

@item @code{GL_MAP1_NORMAL}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates normals.  The initial value is @code{GL_FALSE}.  See
@code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_1}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates 1D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_2}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates 2D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_3}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates 3D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap1}.

@item @code{GL_MAP1_TEXTURE_COORD_4}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates 4D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap1}.

@item @code{GL_MAP1_VERTEX_3}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates 3D vertex coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap1}.

@item @code{GL_MAP1_VERTEX_4}


@var{params} returns a single boolean value indicating whether 1D
evaluation generates 4D vertex coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap1}.

@item @code{GL_MAP2_COLOR_4}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates colors.  The initial value is @code{GL_FALSE}.  See
@code{glMap2}.

@item @code{GL_MAP2_GRID_DOMAIN}


@var{params} returns four values: the endpoints of the 2D map's
@r{@var{i}} and @r{@var{j}} grid domains.  The initial value is (0,1;
0,1).  See @code{glMapGrid}.

@item @code{GL_MAP2_GRID_SEGMENTS}


@var{params} returns two values: the number of partitions in the 2D
map's @r{@var{i}} and @r{@var{j}} grid domains.  The initial value is
(1,1).  See @code{glMapGrid}.

@item @code{GL_MAP2_INDEX}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates color indices.  The initial value is
@code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_MAP2_NORMAL}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates normals.  The initial value is @code{GL_FALSE}.  See
@code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_1}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates 1D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_2}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates 2D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_3}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates 3D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_MAP2_TEXTURE_COORD_4}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates 4D texture coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_MAP2_VERTEX_3}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates 3D vertex coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_MAP2_VERTEX_4}


@var{params} returns a single boolean value indicating whether 2D
evaluation generates 4D vertex coordinates.  The initial value is
@code{GL_FALSE}.  See @code{glMap2}.

@item @code{GL_MAP_COLOR}


@var{params} returns a single boolean value indicating if colors and
color indices are to be replaced by table lookup during pixel transfers.
The initial value is @code{GL_FALSE}.  See @code{glPixelTransfer}.

@item @code{GL_MAP_STENCIL}


@var{params} returns a single boolean value indicating if stencil
indices are to be replaced by table lookup during pixel transfers.  The
initial value is @code{GL_FALSE}.  See @code{glPixelTransfer}.

@item @code{GL_MATRIX_MODE}


@var{params} returns one value, a symbolic constant indicating which
matrix stack is currently the target of all matrix operations.  The
initial value is @code{GL_MODELVIEW}.  See @code{glMatrixMode}.

@item @code{GL_MAX_3D_TEXTURE_SIZE}


@var{params} returns one value, a rough estimate of the largest 3D
texture that the GL can handle.  The value must be at least 16.  If the
GL version is 1.2 or greater, use @code{GL_PROXY_TEXTURE_3D} to
determine if a texture is too large.  See @code{glTexImage3D}.

@item @code{GL_MAX_CLIENT_ATTRIB_STACK_DEPTH}


@var{params} returns one value indicating the maximum supported depth of
the client attribute stack.  See @code{glPushClientAttrib}.

@item @code{GL_MAX_ATTRIB_STACK_DEPTH}


@var{params} returns one value, the maximum supported depth of the
attribute stack.  The value must be at least 16.  See
@code{glPushAttrib}.

@item @code{GL_MAX_CLIP_PLANES}


@var{params} returns one value, the maximum number of
application-defined clipping planes.  The value must be at least 6.  See
@code{glClipPlane}.

@item @code{GL_MAX_COLOR_MATRIX_STACK_DEPTH}


@var{params} returns one value, the maximum supported depth of the color
matrix stack.  The value must be at least 2.  See @code{glPushMatrix}.

@item @code{GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS}


@var{params} returns one value, the maximum supported texture image
units that can be used to access texture maps from the vertex shader and
the fragment processor combined.  If both the vertex shader and the
fragment processing stage access the same texture image unit, then that
counts as using two texture image units against this limit.  The value
must be at least 2.  See @code{glActiveTexture}.

@item @code{GL_MAX_CUBE_MAP_TEXTURE_SIZE}


@var{params} returns one value.  The value gives a rough estimate of the
largest cube-map texture that the GL can handle.  The value must be at
least 16.  If the GL version is 1.3 or greater, use
@code{GL_PROXY_TEXTURE_CUBE_MAP} to determine if a texture is too large.
See @code{glTexImage2D}.

@item @code{GL_MAX_DRAW_BUFFERS}


@var{params} returns one value, the maximum number of simultaneous
output colors allowed from a fragment shader using the
@code{gl_FragData} built-in array.  The value must be at least 1.  See
@code{glDrawBuffers}.

@item @code{GL_MAX_ELEMENTS_INDICES}


@var{params} returns one value, the recommended maximum number of vertex
array indices.  See @code{glDrawRangeElements}.

@item @code{GL_MAX_ELEMENTS_VERTICES}


@var{params} returns one value, the recommended maximum number of vertex
array vertices.  See @code{glDrawRangeElements}.

@item @code{GL_MAX_EVAL_ORDER}


@var{params} returns one value, the maximum equation order supported by
1D and 2D evaluators.  The value must be at least 8.  See @code{glMap1}
and @code{glMap2}.

@item @code{GL_MAX_FRAGMENT_UNIFORM_COMPONENTS}


@var{params} returns one value, the maximum number of individual
floating-point, integer, or boolean values that can be held in uniform
variable storage for a fragment shader.  The value must be at least 64.
See @code{glUniform}.

@item @code{GL_MAX_LIGHTS}


@var{params} returns one value, the maximum number of lights.  The value
must be at least 8.  See @code{glLight}.

@item @code{GL_MAX_LIST_NESTING}


@var{params} returns one value, the maximum recursion depth allowed
during display-list traversal.  The value must be at least 64.  See
@code{glCallList}.

@item @code{GL_MAX_MODELVIEW_STACK_DEPTH}


@var{params} returns one value, the maximum supported depth of the
modelview matrix stack.  The value must be at least 32.  See
@code{glPushMatrix}.

@item @code{GL_MAX_NAME_STACK_DEPTH}


@var{params} returns one value, the maximum supported depth of the
selection name stack.  The value must be at least 64.  See
@code{glPushName}.

@item @code{GL_MAX_PIXEL_MAP_TABLE}


@var{params} returns one value, the maximum supported size of a
@code{glPixelMap} lookup table.  The value must be at least 32.  See
@code{glPixelMap}.

@item @code{GL_MAX_PROJECTION_STACK_DEPTH}


@var{params} returns one value, the maximum supported depth of the
projection matrix stack.  The value must be at least 2.  See
@code{glPushMatrix}.

@item @code{GL_MAX_TEXTURE_COORDS}


@var{params} returns one value, the maximum number of texture coordinate
sets available to vertex and fragment shaders.  The value must be at
least 2.  See @code{glActiveTexture} and @code{glClientActiveTexture}.

@item @code{GL_MAX_TEXTURE_IMAGE_UNITS}


@var{params} returns one value, the maximum supported texture image
units that can be used to access texture maps from the fragment shader.
The value must be at least 2.  See @code{glActiveTexture}.

@item @code{GL_MAX_TEXTURE_LOD_BIAS}


@var{params} returns one value, the maximum, absolute value of the
texture level-of-detail bias.  The value must be at least 4.

@item @code{GL_MAX_TEXTURE_SIZE}


@var{params} returns one value.  The value gives a rough estimate of the
largest texture that the GL can handle.  The value must be at least 64.
If the GL version is 1.1 or greater, use @code{GL_PROXY_TEXTURE_1D} or
@code{GL_PROXY_TEXTURE_2D} to determine if a texture is too large.  See
@code{glTexImage1D} and @code{glTexImage2D}.

@item @code{GL_MAX_TEXTURE_STACK_DEPTH}


@var{params} returns one value, the maximum supported depth of the
texture matrix stack.  The value must be at least 2.  See
@code{glPushMatrix}.

@item @code{GL_MAX_TEXTURE_UNITS}


@var{params} returns a single value indicating the number of
conventional texture units supported.  Each conventional texture unit
includes both a texture coordinate set and a texture image unit.
Conventional texture units may be used for fixed-function (non-shader)
rendering.  The value must be at least 2.  Additional texture coordinate
sets and texture image units may be accessed from vertex and fragment
shaders.  See @code{glActiveTexture} and @code{glClientActiveTexture}.

@item @code{GL_MAX_VARYING_FLOATS}


@var{params} returns one value, the maximum number of interpolators
available for processing varying variables used by vertex and fragment
shaders.  This value represents the number of individual floating-point
values that can be interpolated; varying variables declared as vectors,
matrices, and arrays will all consume multiple interpolators.  The value
must be at least 32.

@item @code{GL_MAX_VERTEX_ATTRIBS}


@var{params} returns one value, the maximum number of 4-component
generic vertex attributes accessible to a vertex shader.  The value must
be at least 16.  See @code{glVertexAttrib}.

@item @code{GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS}


@var{params} returns one value, the maximum supported texture image
units that can be used to access texture maps from the vertex shader.
The value may be 0.  See @code{glActiveTexture}.

@item @code{GL_MAX_VERTEX_UNIFORM_COMPONENTS}


@var{params} returns one value, the maximum number of individual
floating-point, integer, or boolean values that can be held in uniform
variable storage for a vertex shader.  The value must be at least 512.
See @code{glUniform}.

@item @code{GL_MAX_VIEWPORT_DIMS}


@var{params} returns two values: the maximum supported width and height
of the viewport.  These must be at least as large as the visible
dimensions of the display being rendered to.  See @code{glViewport}.

@item @code{GL_MINMAX}


@var{params} returns a single boolean value indicating whether pixel
minmax values are computed.  The initial value is @code{GL_FALSE}.  See
@code{glMinmax}.

@item @code{GL_MODELVIEW_MATRIX}


@var{params} returns sixteen values: the modelview matrix on the top of
the modelview matrix stack.  Initially this matrix is the identity
matrix.  See @code{glPushMatrix}.

@item @code{GL_MODELVIEW_STACK_DEPTH}


@var{params} returns one value, the number of matrices on the modelview
matrix stack.  The initial value is 1.  See @code{glPushMatrix}.

@item @code{GL_NAME_STACK_DEPTH}


@var{params} returns one value, the number of names on the selection
name stack.  The initial value is 0.  See @code{glPushName}.

@item @code{GL_NORMAL_ARRAY}


@var{params} returns a single boolean value, indicating whether the
normal array is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glNormalPointer}.

@item @code{GL_NORMAL_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the normal array.  This buffer object would have been
bound to the target @code{GL_ARRAY_BUFFER} at the time of the most
recent call to @code{glNormalPointer}.  If no buffer object was bound to
this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_NORMAL_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive
normals in the normal array.  The initial value is 0.  See
@code{glNormalPointer}.

@item @code{GL_NORMAL_ARRAY_TYPE}


@var{params} returns one value, the data type of each coordinate in the
normal array.  The initial value is @code{GL_FLOAT}.  See
@code{glNormalPointer}.

@item @code{GL_NORMALIZE}


@var{params} returns a single boolean value indicating whether normals
are automatically scaled to unit length after they have been transformed
to eye coordinates.  The initial value is @code{GL_FALSE}.  See
@code{glNormal}.

@item @code{GL_NUM_COMPRESSED_TEXTURE_FORMATS}


@var{params} returns a single integer value indicating the number of
available compressed texture formats.  The minimum value is 0.  See
@code{glCompressedTexImage2D}.

@item @code{GL_PACK_ALIGNMENT}


@var{params} returns one value, the byte alignment used for writing
pixel data to memory.  The initial value is 4.  See @code{glPixelStore}.

@item @code{GL_PACK_IMAGE_HEIGHT}


@var{params} returns one value, the image height used for writing pixel
data to memory.  The initial value is 0.  See @code{glPixelStore}.

@item @code{GL_PACK_LSB_FIRST}


@var{params} returns a single boolean value indicating whether
single-bit pixels being written to memory are written first to the least
significant bit of each unsigned byte.  The initial value is
@code{GL_FALSE}.  See @code{glPixelStore}.

@item @code{GL_PACK_ROW_LENGTH}


@var{params} returns one value, the row length used for writing pixel
data to memory.  The initial value is 0.  See @code{glPixelStore}.

@item @code{GL_PACK_SKIP_IMAGES}


@var{params} returns one value, the number of pixel images skipped
before the first pixel is written into memory.  The initial value is 0.
See @code{glPixelStore}.

@item @code{GL_PACK_SKIP_PIXELS}


@var{params} returns one value, the number of pixel locations skipped
before the first pixel is written into memory.  The initial value is 0.
See @code{glPixelStore}.

@item @code{GL_PACK_SKIP_ROWS}


@var{params} returns one value, the number of rows of pixel locations
skipped before the first pixel is written into memory.  The initial
value is 0.  See @code{glPixelStore}.

@item @code{GL_PACK_SWAP_BYTES}


@var{params} returns a single boolean value indicating whether the bytes
of two-byte and four-byte pixel indices and components are swapped
before being written to memory.  The initial value is @code{GL_FALSE}.
See @code{glPixelStore}.

@item @code{GL_PERSPECTIVE_CORRECTION_HINT}


@var{params} returns one value, a symbolic constant indicating the mode
of the perspective correction hint.  The initial value is
@code{GL_DONT_CARE}.  See @code{glHint}.

@item @code{GL_PIXEL_MAP_A_TO_A_SIZE}


@var{params} returns one value, the size of the alpha-to-alpha pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_B_TO_B_SIZE}


@var{params} returns one value, the size of the blue-to-blue pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_G_TO_G_SIZE}


@var{params} returns one value, the size of the green-to-green pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_I_TO_A_SIZE}


@var{params} returns one value, the size of the index-to-alpha pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_I_TO_B_SIZE}


@var{params} returns one value, the size of the index-to-blue pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_I_TO_G_SIZE}


@var{params} returns one value, the size of the index-to-green pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_I_TO_I_SIZE}


@var{params} returns one value, the size of the index-to-index pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_I_TO_R_SIZE}


@var{params} returns one value, the size of the index-to-red pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_R_TO_R_SIZE}


@var{params} returns one value, the size of the red-to-red pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_MAP_S_TO_S_SIZE}


@var{params} returns one value, the size of the stencil-to-stencil pixel
translation table.  The initial value is 1.  See @code{glPixelMap}.

@item @code{GL_PIXEL_PACK_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
currently bound to the target @code{GL_PIXEL_PACK_BUFFER}.  If no buffer
object is bound to this target, 0 is returned.  The initial value is 0.
See @code{glBindBuffer}.

@item @code{GL_PIXEL_UNPACK_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
currently bound to the target @code{GL_PIXEL_UNPACK_BUFFER}.  If no
buffer object is bound to this target, 0 is returned.  The initial value
is 0.  See @code{glBindBuffer}.

@item @code{GL_POINT_DISTANCE_ATTENUATION}


@var{params} returns three values, the coefficients for computing the
attenuation value for points.  See @code{glPointParameter}.

@item @code{GL_POINT_FADE_THRESHOLD_SIZE}


@var{params} returns one value, the point size threshold for determining
the point size.  See @code{glPointParameter}.

@item @code{GL_POINT_SIZE}


@var{params} returns one value, the point size as specified by
@code{glPointSize}.  The initial value is 1.

@item @code{GL_POINT_SIZE_GRANULARITY}


@var{params} returns one value, the size difference between adjacent
supported sizes for antialiased points.  See @code{glPointSize}.

@item @code{GL_POINT_SIZE_MAX}


@var{params} returns one value, the upper bound for the attenuated point
sizes.  The initial value is 0.0.  See @code{glPointParameter}.

@item @code{GL_POINT_SIZE_MIN}


@var{params} returns one value, the lower bound for the attenuated point
sizes.  The initial value is 1.0.  See @code{glPointParameter}.

@item @code{GL_POINT_SIZE_RANGE}


@var{params} returns two values: the smallest and largest supported
sizes for antialiased points.  The smallest size must be at most 1, and
the largest size must be at least 1.  See @code{glPointSize}.

@item @code{GL_POINT_SMOOTH}


@var{params} returns a single boolean value indicating whether
antialiasing of points is enabled.  The initial value is
@code{GL_FALSE}.  See @code{glPointSize}.

@item @code{GL_POINT_SMOOTH_HINT}


@var{params} returns one value, a symbolic constant indicating the mode
of the point antialiasing hint.  The initial value is
@code{GL_DONT_CARE}.  See @code{glHint}.

@item @code{GL_POINT_SPRITE}


@var{params} returns a single boolean value indicating whether point
sprite is enabled.  The initial value is @code{GL_FALSE}.

@item @code{GL_POLYGON_MODE}


@var{params} returns two values: symbolic constants indicating whether
front-facing and back-facing polygons are rasterized as points, lines,
or filled polygons.  The initial value is @code{GL_FILL}.  See
@code{glPolygonMode}.

@item @code{GL_POLYGON_OFFSET_FACTOR}


@var{params} returns one value, the scaling factor used to determine the
variable offset that is added to the depth value of each fragment
generated when a polygon is rasterized.  The initial value is 0.  See
@code{glPolygonOffset}.

@item @code{GL_POLYGON_OFFSET_UNITS}


@var{params} returns one value.  This value is multiplied by an
implementation-specific value and then added to the depth value of each
fragment generated when a polygon is rasterized.  The initial value is
0.  See @code{glPolygonOffset}.

@item @code{GL_POLYGON_OFFSET_FILL}


@var{params} returns a single boolean value indicating whether polygon
offset is enabled for polygons in fill mode.  The initial value is
@code{GL_FALSE}.  See @code{glPolygonOffset}.

@item @code{GL_POLYGON_OFFSET_LINE}


@var{params} returns a single boolean value indicating whether polygon
offset is enabled for polygons in line mode.  The initial value is
@code{GL_FALSE}.  See @code{glPolygonOffset}.

@item @code{GL_POLYGON_OFFSET_POINT}


@var{params} returns a single boolean value indicating whether polygon
offset is enabled for polygons in point mode.  The initial value is
@code{GL_FALSE}.  See @code{glPolygonOffset}.

@item @code{GL_POLYGON_SMOOTH}


@var{params} returns a single boolean value indicating whether
antialiasing of polygons is enabled.  The initial value is
@code{GL_FALSE}.  See @code{glPolygonMode}.

@item @code{GL_POLYGON_SMOOTH_HINT}


@var{params} returns one value, a symbolic constant indicating the mode
of the polygon antialiasing hint.  The initial value is
@code{GL_DONT_CARE}.  See @code{glHint}.

@item @code{GL_POLYGON_STIPPLE}


@var{params} returns a single boolean value indicating whether polygon
stippling is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glPolygonStipple}.

@item @code{GL_POST_COLOR_MATRIX_COLOR_TABLE}


@var{params} returns a single boolean value indicating whether post
color matrix transformation lookup is enabled.  The initial value is
@code{GL_FALSE}.  See @code{glColorTable}.

@item @code{GL_POST_COLOR_MATRIX_RED_BIAS}


@var{params} returns one value, the red bias factor applied to RGBA
fragments after color matrix transformations.  The initial value is 0.
See @code{glPixelTransfer}.

@item @code{GL_POST_COLOR_MATRIX_GREEN_BIAS}


@var{params} returns one value, the green bias factor applied to RGBA
fragments after color matrix transformations.  The initial value is 0.
See @code{glPixelTransfer}

@item @code{GL_POST_COLOR_MATRIX_BLUE_BIAS}


@var{params} returns one value, the blue bias factor applied to RGBA
fragments after color matrix transformations.  The initial value is 0.
See @code{glPixelTransfer}.

@item @code{GL_POST_COLOR_MATRIX_ALPHA_BIAS}


@var{params} returns one value, the alpha bias factor applied to RGBA
fragments after color matrix transformations.  The initial value is 0.
See @code{glPixelTransfer}.

@item @code{GL_POST_COLOR_MATRIX_RED_SCALE}


@var{params} returns one value, the red scale factor applied to RGBA
fragments after color matrix transformations.  The initial value is 1.
See @code{glPixelTransfer}.

@item @code{GL_POST_COLOR_MATRIX_GREEN_SCALE}


@var{params} returns one value, the green scale factor applied to RGBA
fragments after color matrix transformations.  The initial value is 1.
See @code{glPixelTransfer}.

@item @code{GL_POST_COLOR_MATRIX_BLUE_SCALE}


@var{params} returns one value, the blue scale factor applied to RGBA
fragments after color matrix transformations.  The initial value is 1.
See @code{glPixelTransfer}.

@item @code{GL_POST_COLOR_MATRIX_ALPHA_SCALE}


@var{params} returns one value, the alpha scale factor applied to RGBA
fragments after color matrix transformations.  The initial value is 1.
See @code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_COLOR_TABLE}


@var{params} returns a single boolean value indicating whether post
convolution lookup is enabled.  The initial value is @code{GL_FALSE}.
See @code{glColorTable}.

@item @code{GL_POST_CONVOLUTION_RED_BIAS}


@var{params} returns one value, the red bias factor applied to RGBA
fragments after convolution.  The initial value is 0.  See
@code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_GREEN_BIAS}


@var{params} returns one value, the green bias factor applied to RGBA
fragments after convolution.  The initial value is 0.  See
@code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_BLUE_BIAS}


@var{params} returns one value, the blue bias factor applied to RGBA
fragments after convolution.  The initial value is 0.  See
@code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_ALPHA_BIAS}


@var{params} returns one value, the alpha bias factor applied to RGBA
fragments after convolution.  The initial value is 0.  See
@code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_RED_SCALE}


@var{params} returns one value, the red scale factor applied to RGBA
fragments after convolution.  The initial value is 1.  See
@code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_GREEN_SCALE}


@var{params} returns one value, the green scale factor applied to RGBA
fragments after convolution.  The initial value is 1.  See
@code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_BLUE_SCALE}


@var{params} returns one value, the blue scale factor applied to RGBA
fragments after convolution.  The initial value is 1.  See
@code{glPixelTransfer}.

@item @code{GL_POST_CONVOLUTION_ALPHA_SCALE}


@var{params} returns one value, the alpha scale factor applied to RGBA
fragments after convolution.  The initial value is 1.  See
@code{glPixelTransfer}.

@item @code{GL_PROJECTION_MATRIX}


@var{params} returns sixteen values: the projection matrix on the top of
the projection matrix stack.  Initially this matrix is the identity
matrix.  See @code{glPushMatrix}.

@item @code{GL_PROJECTION_STACK_DEPTH}


@var{params} returns one value, the number of matrices on the projection
matrix stack.  The initial value is 1.  See @code{glPushMatrix}.

@item @code{GL_READ_BUFFER}


@var{params} returns one value, a symbolic constant indicating which
color buffer is selected for reading.  The initial value is
@code{GL_BACK} if there is a back buffer, otherwise it is
@code{GL_FRONT}.  See @code{glReadPixels} and @code{glAccum}.

@item @code{GL_RED_BIAS}


@var{params} returns one value, the red bias factor used during pixel
transfers.  The initial value is 0.

@item @code{GL_RED_BITS}


@var{params} returns one value, the number of red bitplanes in each
color buffer.

@item @code{GL_RED_SCALE}


@var{params} returns one value, the red scale factor used during pixel
transfers.  The initial value is 1.  See @code{glPixelTransfer}.

@item @code{GL_RENDER_MODE}


@var{params} returns one value, a symbolic constant indicating whether
the GL is in render, select, or feedback mode.  The initial value is
@code{GL_RENDER}.  See @code{glRenderMode}.

@item @code{GL_RESCALE_NORMAL}


@var{params} returns single boolean value indicating whether normal
rescaling is enabled.  See @code{glEnable}.

@item @code{GL_RGBA_MODE}


@var{params} returns a single boolean value indicating whether the GL is
in RGBA mode (true) or color index mode (false).  See @code{glColor}.

@item @code{GL_SAMPLE_BUFFERS}


@var{params} returns a single integer value indicating the number of
sample buffers associated with the framebuffer.  See
@code{glSampleCoverage}.

@item @code{GL_SAMPLE_COVERAGE_VALUE}


@var{params} returns a single positive floating-point value indicating
the current sample coverage value.  See @code{glSampleCoverage}.

@item @code{GL_SAMPLE_COVERAGE_INVERT}


@var{params} returns a single boolean value indicating if the temporary
coverage value should be inverted.  See @code{glSampleCoverage}.

@item @code{GL_SAMPLES}


@var{params} returns a single integer value indicating the coverage mask
size.  See @code{glSampleCoverage}.

@item @code{GL_SCISSOR_BOX}


@var{params} returns four values: the @r{@var{x}} and @r{@var{y}} window
coordinates of the scissor box, followed by its width and height.
Initially the @r{@var{x}} and @r{@var{y}} window coordinates are both 0
and the width and height are set to the size of the window.  See
@code{glScissor}.

@item @code{GL_SCISSOR_TEST}


@var{params} returns a single boolean value indicating whether
scissoring is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glScissor}.

@item @code{GL_SECONDARY_COLOR_ARRAY}


@var{params} returns a single boolean value indicating whether the
secondary color array is enabled.  The initial value is @code{GL_FALSE}.
See @code{glSecondaryColorPointer}.

@item @code{GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the secondary color array.  This buffer object would
have been bound to the target @code{GL_ARRAY_BUFFER} at the time of the
most recent call to @code{glSecondaryColorPointer}.  If no buffer object
was bound to this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_SECONDARY_COLOR_ARRAY_SIZE}


@var{params} returns one value, the number of components per color in
the secondary color array.  The initial value is 3.  See
@code{glSecondaryColorPointer}.

@item @code{GL_SECONDARY_COLOR_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive
colors in the secondary color array.  The initial value is 0.  See
@code{glSecondaryColorPointer}.

@item @code{GL_SECONDARY_COLOR_ARRAY_TYPE}


@var{params} returns one value, the data type of each component in the
secondary color array.  The initial value is @code{GL_FLOAT}.  See
@code{glSecondaryColorPointer}.

@item @code{GL_SELECTION_BUFFER_SIZE}


@var{params} return one value, the size of the selection buffer.  See
@code{glSelectBuffer}.

@item @code{GL_SEPARABLE_2D}


@var{params} returns a single boolean value indicating whether 2D
separable convolution is enabled.  The initial value is @code{GL_FALSE}.
See @code{glSeparableFilter2D}.

@item @code{GL_SHADE_MODEL}


@var{params} returns one value, a symbolic constant indicating whether
the shading mode is flat or smooth.  The initial value is
@code{GL_SMOOTH}.  See @code{glShadeModel}.

@item @code{GL_SMOOTH_LINE_WIDTH_RANGE}


@var{params} returns two values, the smallest and largest supported
widths for antialiased lines.  See @code{glLineWidth}.

@item @code{GL_SMOOTH_LINE_WIDTH_GRANULARITY}


@var{params} returns one value, the granularity of widths for
antialiased lines.  See @code{glLineWidth}.

@item @code{GL_SMOOTH_POINT_SIZE_RANGE}


@var{params} returns two values, the smallest and largest supported
widths for antialiased points.  See @code{glPointSize}.

@item @code{GL_SMOOTH_POINT_SIZE_GRANULARITY}


@var{params} returns one value, the granularity of sizes for antialiased
points.  See @code{glPointSize}.

@item @code{GL_STENCIL_BACK_FAIL}


@var{params} returns one value, a symbolic constant indicating what
action is taken for back-facing polygons when the stencil test fails.
The initial value is @code{GL_KEEP}.  See @code{glStencilOpSeparate}.

@item @code{GL_STENCIL_BACK_FUNC}


@var{params} returns one value, a symbolic constant indicating what
function is used for back-facing polygons to compare the stencil
reference value with the stencil buffer value.  The initial value is
@code{GL_ALWAYS}.  See @code{glStencilFuncSeparate}.

@item @code{GL_STENCIL_BACK_PASS_DEPTH_FAIL}


@var{params} returns one value, a symbolic constant indicating what
action is taken for back-facing polygons when the stencil test passes,
but the depth test fails.  The initial value is @code{GL_KEEP}.  See
@code{glStencilOpSeparate}.

@item @code{GL_STENCIL_BACK_PASS_DEPTH_PASS}


@var{params} returns one value, a symbolic constant indicating what
action is taken for back-facing polygons when the stencil test passes
and the depth test passes.  The initial value is @code{GL_KEEP}.  See
@code{glStencilOpSeparate}.

@item @code{GL_STENCIL_BACK_REF}


@var{params} returns one value, the reference value that is compared
with the contents of the stencil buffer for back-facing polygons.  The
initial value is 0.  See @code{glStencilFuncSeparate}.

@item @code{GL_STENCIL_BACK_VALUE_MASK}


@var{params} returns one value, the mask that is used for back-facing
polygons to mask both the stencil reference value and the stencil buffer
value before they are compared.  The initial value is all 1's.  See
@code{glStencilFuncSeparate}.

@item @code{GL_STENCIL_BACK_WRITEMASK}


@var{params} returns one value, the mask that controls writing of the
stencil bitplanes for back-facing polygons.  The initial value is all
1's.  See @code{glStencilMaskSeparate}.

@item @code{GL_STENCIL_BITS}


@var{params} returns one value, the number of bitplanes in the stencil
buffer.

@item @code{GL_STENCIL_CLEAR_VALUE}


@var{params} returns one value, the index to which the stencil bitplanes
are cleared.  The initial value is 0.  See @code{glClearStencil}.

@item @code{GL_STENCIL_FAIL}


@var{params} returns one value, a symbolic constant indicating what
action is taken when the stencil test fails.  The initial value is
@code{GL_KEEP}.  See @code{glStencilOp}.  If the GL version is 2.0 or
greater, this stencil state only affects non-polygons and front-facing
polygons.  Back-facing polygons use separate stencil state.  See
@code{glStencilOpSeparate}.

@item @code{GL_STENCIL_FUNC}


@var{params} returns one value, a symbolic constant indicating what
function is used to compare the stencil reference value with the stencil
buffer value.  The initial value is @code{GL_ALWAYS}.  See
@code{glStencilFunc}.  If the GL version is 2.0 or greater, this stencil
state only affects non-polygons and front-facing polygons.  Back-facing
polygons use separate stencil state.  See @code{glStencilFuncSeparate}.

@item @code{GL_STENCIL_PASS_DEPTH_FAIL}


@var{params} returns one value, a symbolic constant indicating what
action is taken when the stencil test passes, but the depth test fails.
The initial value is @code{GL_KEEP}.  See @code{glStencilOp}.  If the GL
version is 2.0 or greater, this stencil state only affects non-polygons
and front-facing polygons.  Back-facing polygons use separate stencil
state.  See @code{glStencilOpSeparate}.

@item @code{GL_STENCIL_PASS_DEPTH_PASS}


@var{params} returns one value, a symbolic constant indicating what
action is taken when the stencil test passes and the depth test passes.
The initial value is @code{GL_KEEP}.  See @code{glStencilOp}.  If the GL
version is 2.0 or greater, this stencil state only affects non-polygons
and front-facing polygons.  Back-facing polygons use separate stencil
state.  See @code{glStencilOpSeparate}.

@item @code{GL_STENCIL_REF}


@var{params} returns one value, the reference value that is compared
with the contents of the stencil buffer.  The initial value is 0.  See
@code{glStencilFunc}.  If the GL version is 2.0 or greater, this stencil
state only affects non-polygons and front-facing polygons.  Back-facing
polygons use separate stencil state.  See @code{glStencilFuncSeparate}.

@item @code{GL_STENCIL_TEST}


@var{params} returns a single boolean value indicating whether stencil
testing of fragments is enabled.  The initial value is @code{GL_FALSE}.
See @code{glStencilFunc} and @code{glStencilOp}.

@item @code{GL_STENCIL_VALUE_MASK}


@var{params} returns one value, the mask that is used to mask both the
stencil reference value and the stencil buffer value before they are
compared.  The initial value is all 1's.  See @code{glStencilFunc}.  If
the GL version is 2.0 or greater, this stencil state only affects
non-polygons and front-facing polygons.  Back-facing polygons use
separate stencil state.  See @code{glStencilFuncSeparate}.

@item @code{GL_STENCIL_WRITEMASK}


@var{params} returns one value, the mask that controls writing of the
stencil bitplanes.  The initial value is all 1's.  See
@code{glStencilMask}.  If the GL version is 2.0 or greater, this stencil
state only affects non-polygons and front-facing polygons.  Back-facing
polygons use separate stencil state.  See @code{glStencilMaskSeparate}.

@item @code{GL_STEREO}


@var{params} returns a single boolean value indicating whether stereo
buffers (left and right) are supported.

@item @code{GL_SUBPIXEL_BITS}


@var{params} returns one value, an estimate of the number of bits of
subpixel resolution that are used to position rasterized geometry in
window coordinates.  The value must be at least 4.

@item @code{GL_TEXTURE_1D}


@var{params} returns a single boolean value indicating whether 1D
texture mapping is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glTexImage1D}.

@item @code{GL_TEXTURE_BINDING_1D}


@var{params} returns a single value, the name of the texture currently
bound to the target @code{GL_TEXTURE_1D}.  The initial value is 0.  See
@code{glBindTexture}.

@item @code{GL_TEXTURE_2D}


@var{params} returns a single boolean value indicating whether 2D
texture mapping is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glTexImage2D}.

@item @code{GL_TEXTURE_BINDING_2D}


@var{params} returns a single value, the name of the texture currently
bound to the target @code{GL_TEXTURE_2D}.  The initial value is 0.  See
@code{glBindTexture}.

@item @code{GL_TEXTURE_3D}


@var{params} returns a single boolean value indicating whether 3D
texture mapping is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glTexImage3D}.

@item @code{GL_TEXTURE_BINDING_3D}


@var{params} returns a single value, the name of the texture currently
bound to the target @code{GL_TEXTURE_3D}.  The initial value is 0.  See
@code{glBindTexture}.

@item @code{GL_TEXTURE_BINDING_CUBE_MAP}


@var{params} returns a single value, the name of the texture currently
bound to the target @code{GL_TEXTURE_CUBE_MAP}.  The initial value is 0.
See @code{glBindTexture}.

@item @code{GL_TEXTURE_COMPRESSION_HINT}


@var{params} returns a single value indicating the mode of the texture
compression hint.  The initial value is @code{GL_DONT_CARE}.

@item @code{GL_TEXTURE_COORD_ARRAY}


@var{params} returns a single boolean value indicating whether the
texture coordinate array is enabled.  The initial value is
@code{GL_FALSE}.  See @code{glTexCoordPointer}.

@item @code{GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the texture coordinate array.  This buffer object would
have been bound to the target @code{GL_ARRAY_BUFFER} at the time of the
most recent call to @code{glTexCoordPointer}.  If no buffer object was
bound to this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_TEXTURE_COORD_ARRAY_SIZE}


@var{params} returns one value, the number of coordinates per element in
the texture coordinate array.  The initial value is 4.  See
@code{glTexCoordPointer}.

@item @code{GL_TEXTURE_COORD_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive
elements in the texture coordinate array.  The initial value is 0.  See
@code{glTexCoordPointer}.

@item @code{GL_TEXTURE_COORD_ARRAY_TYPE}


@var{params} returns one value, the data type of the coordinates in the
texture coordinate array.  The initial value is @code{GL_FLOAT}.  See
@code{glTexCoordPointer}.

@item @code{GL_TEXTURE_CUBE_MAP}


@var{params} returns a single boolean value indicating whether
cube-mapped texture mapping is enabled.  The initial value is
@code{GL_FALSE}.  See @code{glTexImage2D}.

@item @code{GL_TEXTURE_GEN_Q}


@var{params} returns a single boolean value indicating whether automatic
generation of the @var{q} texture coordinate is enabled.  The initial
value is @code{GL_FALSE}.  See @code{glTexGen}.

@item @code{GL_TEXTURE_GEN_R}


@var{params} returns a single boolean value indicating whether automatic
generation of the @var{r} texture coordinate is enabled.  The initial
value is @code{GL_FALSE}.  See @code{glTexGen}.

@item @code{GL_TEXTURE_GEN_S}


@var{params} returns a single boolean value indicating whether automatic
generation of the @var{S} texture coordinate is enabled.  The initial
value is @code{GL_FALSE}.  See @code{glTexGen}.

@item @code{GL_TEXTURE_GEN_T}


@var{params} returns a single boolean value indicating whether automatic
generation of the T texture coordinate is enabled.  The initial value is
@code{GL_FALSE}.  See @code{glTexGen}.

@item @code{GL_TEXTURE_MATRIX}


@var{params} returns sixteen values: the texture matrix on the top of
the texture matrix stack.  Initially this matrix is the identity matrix.
See @code{glPushMatrix}.

@item @code{GL_TEXTURE_STACK_DEPTH}


@var{params} returns one value, the number of matrices on the texture
matrix stack.  The initial value is 1.  See @code{glPushMatrix}.

@item @code{GL_TRANSPOSE_COLOR_MATRIX}


@var{params} returns 16 values, the elements of the color matrix in
row-major order.  See @code{glLoadTransposeMatrix}.

@item @code{GL_TRANSPOSE_MODELVIEW_MATRIX}


@var{params} returns 16 values, the elements of the modelview matrix in
row-major order.  See @code{glLoadTransposeMatrix}.

@item @code{GL_TRANSPOSE_PROJECTION_MATRIX}


@var{params} returns 16 values, the elements of the projection matrix in
row-major order.  See @code{glLoadTransposeMatrix}.

@item @code{GL_TRANSPOSE_TEXTURE_MATRIX}


@var{params} returns 16 values, the elements of the texture matrix in
row-major order.  See @code{glLoadTransposeMatrix}.

@item @code{GL_UNPACK_ALIGNMENT}


@var{params} returns one value, the byte alignment used for reading
pixel data from memory.  The initial value is 4.  See
@code{glPixelStore}.

@item @code{GL_UNPACK_IMAGE_HEIGHT}


@var{params} returns one value, the image height used for reading pixel
data from memory.  The initial is 0.  See @code{glPixelStore}.

@item @code{GL_UNPACK_LSB_FIRST}


@var{params} returns a single boolean value indicating whether
single-bit pixels being read from memory are read first from the least
significant bit of each unsigned byte.  The initial value is
@code{GL_FALSE}.  See @code{glPixelStore}.

@item @code{GL_UNPACK_ROW_LENGTH}


@var{params} returns one value, the row length used for reading pixel
data from memory.  The initial value is 0.  See @code{glPixelStore}.

@item @code{GL_UNPACK_SKIP_IMAGES}


@var{params} returns one value, the number of pixel images skipped
before the first pixel is read from memory.  The initial value is 0.  See
@code{glPixelStore}.

@item @code{GL_UNPACK_SKIP_PIXELS}


@var{params} returns one value, the number of pixel locations skipped
before the first pixel is read from memory.  The initial value is 0.  See
@code{glPixelStore}.

@item @code{GL_UNPACK_SKIP_ROWS}


@var{params} returns one value, the number of rows of pixel locations
skipped before the first pixel is read from memory.  The initial value
is 0.  See @code{glPixelStore}.

@item @code{GL_UNPACK_SWAP_BYTES}


@var{params} returns a single boolean value indicating whether the bytes
of two-byte and four-byte pixel indices and components are swapped after
being read from memory.  The initial value is @code{GL_FALSE}.  See
@code{glPixelStore}.

@item @code{GL_VERTEX_ARRAY}


@var{params} returns a single boolean value indicating whether the
vertex array is enabled.  The initial value is @code{GL_FALSE}.  See
@code{glVertexPointer}.

@item @code{GL_VERTEX_ARRAY_BUFFER_BINDING}


@var{params} returns a single value, the name of the buffer object
associated with the vertex array.  This buffer object would have been
bound to the target @code{GL_ARRAY_BUFFER} at the time of the most
recent call to @code{glVertexPointer}.  If no buffer object was bound to
this target, 0 is returned.  The initial value is 0.  See
@code{glBindBuffer}.

@item @code{GL_VERTEX_ARRAY_SIZE}


@var{params} returns one value, the number of coordinates per vertex in
the vertex array.  The initial value is 4.  See @code{glVertexPointer}.

@item @code{GL_VERTEX_ARRAY_STRIDE}


@var{params} returns one value, the byte offset between consecutive
vertices in the vertex array.  The initial value is 0.  See
@code{glVertexPointer}.

@item @code{GL_VERTEX_ARRAY_TYPE}


@var{params} returns one value, the data type of each coordinate in the
vertex array.  The initial value is @code{GL_FLOAT}.  See
@code{glVertexPointer}.

@item @code{GL_VERTEX_PROGRAM_POINT_SIZE}


@var{params} returns a single boolean value indicating whether vertex
program point size mode is enabled.  If enabled, and a vertex shader is
active, then the point size is taken from the shader built-in
@code{gl_PointSize}.  If disabled, and a vertex shader is active, then
the point size is taken from the point state as specified by
@code{glPointSize}.  The initial value is @code{GL_FALSE}.

@item @code{GL_VERTEX_PROGRAM_TWO_SIDE}


@var{params} returns a single boolean value indicating whether vertex
program two-sided color mode is enabled.  If enabled, and a vertex
shader is active, then the GL chooses the back color output for
back-facing polygons, and the front color output for non-polygons and
front-facing polygons.  If disabled, and a vertex shader is active, then
the front color output is always selected.  The initial value is
@code{GL_FALSE}.

@item @code{GL_VIEWPORT}


@var{params} returns four values: the @r{@var{x}} and @r{@var{y}} window
coordinates of the viewport, followed by its width and height.  Initially
the @r{@var{x}} and @r{@var{y}} window coordinates are both set to 0,
and the width and height are set to the width and height of the window
into which the GL will do its rendering.  See @code{glViewport}.

@item @code{GL_ZOOM_X}


@var{params} returns one value, the @r{@var{x}} pixel zoom factor.  The
initial value is 1.  See @code{glPixelZoom}.

@item @code{GL_ZOOM_Y}


@var{params} returns one value, the @r{@var{y}} pixel zoom factor.  The
initial value is 1.  See @code{glPixelZoom}.

@end table

Many of the boolean parameters can also be queried more easily using
@code{glIsEnabled}.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glGet} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.



@end deftypefun

@deftypefun void glHint target mode
Specify implementation-specific hints.

@table @asis
@item @var{target}
Specifies a symbolic constant indicating the behavior to be controlled.
@code{GL_FOG_HINT}, @code{GL_GENERATE_MIPMAP_HINT},
@code{GL_LINE_SMOOTH_HINT}, @code{GL_PERSPECTIVE_CORRECTION_HINT},
@code{GL_POINT_SMOOTH_HINT}, @code{GL_POLYGON_SMOOTH_HINT},
@code{GL_TEXTURE_COMPRESSION_HINT}, and
@code{GL_FRAGMENT_SHADER_DERIVATIVE_HINT} are accepted.

@item @var{mode}
Specifies a symbolic constant indicating the desired behavior.
@code{GL_FASTEST}, @code{GL_NICEST}, and @code{GL_DONT_CARE} are
accepted.

@end table

Certain aspects of GL behavior, when there is room for interpretation,
can be controlled with hints.  A hint is specified with two arguments.
@var{target} is a symbolic constant indicating the behavior to be
controlled, and @var{mode} is another symbolic constant indicating the
desired behavior.  The initial value for each @var{target} is
@code{GL_DONT_CARE}.  @var{mode} can be one of the following:

@table @asis
@item @code{GL_FASTEST}


The most efficient option should be chosen.

@item @code{GL_NICEST}


The most correct, or highest quality, option should be chosen.

@item @code{GL_DONT_CARE}


No preference.

@end table

Though the implementation aspects that can be hinted are well defined,
the interpretation of the hints depends on the implementation.  The hint
aspects that can be specified with @var{target}, along with suggested
semantics, are as follows:

@table @asis
@item @code{GL_FOG_HINT}


Indicates the accuracy of fog calculation.  If per-pixel fog calculation
is not efficiently supported by the GL implementation, hinting
@code{GL_DONT_CARE} or @code{GL_FASTEST} can result in per-vertex
calculation of fog effects.

@item @code{GL_FRAGMENT_SHADER_DERIVATIVE_HINT}


Indicates the accuracy of the derivative calculation for the GL shading
language fragment processing built-in functions: @code{dFdx},
@code{dFdy}, and @code{fwidth}.

@item @code{GL_GENERATE_MIPMAP_HINT}


Indicates the quality of filtering when generating mipmap images.

@item @code{GL_LINE_SMOOTH_HINT}


Indicates the sampling quality of antialiased lines.  If a larger filter
function is applied, hinting @code{GL_NICEST} can result in more pixel
fragments being generated during rasterization.

@item @code{GL_PERSPECTIVE_CORRECTION_HINT}


Indicates the quality of color, texture coordinate, and fog coordinate
interpolation.  If perspective-corrected parameter interpolation is not
efficiently supported by the GL implementation, hinting
@code{GL_DONT_CARE} or @code{GL_FASTEST} can result in simple linear
interpolation of colors and/or texture coordinates.

@item @code{GL_POINT_SMOOTH_HINT}


Indicates the sampling quality of antialiased points.  If a larger
filter function is applied, hinting @code{GL_NICEST} can result in more
pixel fragments being generated during rasterization.

@item @code{GL_POLYGON_SMOOTH_HINT}


Indicates the sampling quality of antialiased polygons.  Hinting
@code{GL_NICEST} can result in more pixel fragments being generated
during rasterization, if a larger filter function is applied.

@item @code{GL_TEXTURE_COMPRESSION_HINT}


Indicates the quality and performance of the compressing texture images.
Hinting @code{GL_FASTEST} indicates that texture images should be
compressed as quickly as possible, while @code{GL_NICEST} indicates that
texture images should be compressed with as little image quality loss as
possible.  @code{GL_NICEST} should be selected if the texture is to be
retrieved by @code{glGetCompressedTexImage} for reuse.

@end table

@code{GL_INVALID_ENUM} is generated if either @var{target} or @var{mode}
is not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glHint} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glHistogram target width internalformat sink
Define histogram table.

@table @asis
@item @var{target}
The histogram whose parameters are to be set.  Must be one of
@code{GL_HISTOGRAM} or @code{GL_PROXY_HISTOGRAM}.

@item @var{width}
The number of entries in the histogram table.  Must be a power of 2.

@item @var{internalformat}
The format of entries in the histogram table.  Must be one of
@code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8}, @code{GL_ALPHA12},
@code{GL_ALPHA16}, @code{GL_LUMINANCE}, @code{GL_LUMINANCE4},
@code{GL_LUMINANCE8}, @code{GL_LUMINANCE12}, @code{GL_LUMINANCE16},
@code{GL_LUMINANCE_ALPHA}, @code{GL_LUMINANCE4_ALPHA4},
@code{GL_LUMINANCE6_ALPHA2}, @code{GL_LUMINANCE8_ALPHA8},
@code{GL_LUMINANCE12_ALPHA4}, @code{GL_LUMINANCE12_ALPHA12},
@code{GL_LUMINANCE16_ALPHA16}, @code{GL_R3_G3_B2}, @code{GL_RGB},
@code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8}, @code{GL_RGB10},
@code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA}, @code{GL_RGBA2},
@code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8}, @code{GL_RGB10_A2},
@code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{sink}
If @code{GL_TRUE}, pixels will be consumed by the histogramming process
and no drawing or texture loading will take place.  If @code{GL_FALSE},
pixels will proceed to the minmax process after histogramming.

@end table

When @code{GL_HISTOGRAM} is enabled, RGBA color components are converted
to histogram table indices by clamping to the range [0,1], multiplying
by the width of the histogram table, and rounding to the nearest
integer.  The table entries selected by the RGBA indices are then
incremented.  (If the internal format of the histogram table includes
luminance, then the index derived from the R color component determines
the luminance table entry to be incremented.) If a histogram table entry
is incremented beyond its maximum value, then its value becomes
undefined.  (This is not an error.)

Histogramming is performed only for RGBA pixels (though these may be
specified originally as color indices and converted to RGBA by index
table lookup).  Histogramming is enabled with @code{glEnable} and
disabled with @code{glDisable}.

When @var{target} is @code{GL_HISTOGRAM}, @code{glHistogram} redefines
the current histogram table to have @var{width} entries of the format
specified by @var{internalformat}.  The entries are indexed 0 through
@r{@var{width}-1}, and all entries are initialized to zero.  The values
in the previous histogram table, if any, are lost.  If @var{sink} is
@code{GL_TRUE}, then pixels are discarded after histogramming; no
further processing of the pixels takes place, and no drawing, texture
loading, or pixel readback will result.

When @var{target} is @code{GL_PROXY_HISTOGRAM}, @code{glHistogram}
computes all state information as if the histogram table were to be
redefined, but does not actually define the new table.  If the requested
histogram table is too large to be supported, then the state information
will be set to zero.  This provides a way to determine if a histogram
table with the given parameters can be supported.



@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero or
is not a power of 2.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_TABLE_TOO_LARGE} is generated if @var{target} is
@code{GL_HISTOGRAM} and the histogram table specified is too large for
the implementation.

@code{GL_INVALID_OPERATION} is generated if @code{glHistogram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glIndexMask mask
Control the writing of individual bits in the color index buffers.

@table @asis
@item @var{mask}
Specifies a bit mask to enable and disable the writing of individual
bits in the color index buffers.  Initially, the mask is all 1's.

@end table

@code{glIndexMask} controls the writing of individual bits in the color
index buffers.  The least significant @r{@var{n}} bits of @var{mask},
where @r{@var{n}} is the number of bits in a color index buffer, specify
a mask.  Where a 1 (one) appears in the mask, it's possible to write to
the corresponding bit in the color index buffer (or buffers).  Where a 0
(zero) appears, the corresponding bit is write-protected.

This mask is used only in color index mode, and it affects only the
buffers currently selected for writing (see @code{glDrawBuffer}).
Initially, all bits are enabled for writing.

@code{GL_INVALID_OPERATION} is generated if @code{glIndexMask} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glIndexPointer type stride pointer
Define an array of color indexes.

@table @asis
@item @var{type}
Specifies the data type of each color index in the array.  Symbolic
constants @code{GL_UNSIGNED_BYTE}, @code{GL_SHORT}, @code{GL_INT},
@code{GL_FLOAT}, and @code{GL_DOUBLE} are accepted.  The initial value
is @code{GL_FLOAT}.

@item @var{stride}
Specifies the byte offset between consecutive color indexes.  If
@var{stride} is 0, the color indexes are understood to be tightly packed
in the array.  The initial value is 0.

@item @var{pointer}
Specifies a pointer to the first index in the array.  The initial value
is 0.

@end table

@code{glIndexPointer} specifies the location and data format of an array
of color indexes to use when rendering.  @var{type} specifies the data
type of each color index and @var{stride} specifies the byte stride from
one color index to the next, allowing vertices and attributes to be
packed into a single array or stored in separate arrays.

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a color index array is specified,
@var{pointer} is treated as a byte offset into the buffer object's data
store.  Also, the buffer object binding (@code{GL_ARRAY_BUFFER_BINDING})
is saved as color index vertex array client-side state
(@code{GL_INDEX_ARRAY_BUFFER_BINDING}).

When a color index array is specified, @var{type}, @var{stride}, and
@var{pointer} are saved as client-side state, in addition to the current
vertex array buffer object binding.

To enable and disable the color index array, call
@code{glEnableClientState} and @code{glDisableClientState} with the
argument @code{GL_INDEX_ARRAY}.  If enabled, the color index array is
used when @code{glDrawArrays}, @code{glMultiDrawArrays},
@code{glDrawElements}, @code{glMultiDrawElements},
@code{glDrawRangeElements}, or @code{glArrayElement} is called.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glIndexs c
@deftypefunx void glIndexi c
@deftypefunx void glIndexf c
@deftypefunx void glIndexd c
@deftypefunx void glIndexub c
@deftypefunx void glIndexsv c
@deftypefunx void glIndexiv c
@deftypefunx void glIndexfv c
@deftypefunx void glIndexdv c
@deftypefunx void glIndexubv c
Set the current color index.

@table @asis
@item @var{c}
Specifies the new value for the current color index.



@end table

@code{glIndex} updates the current (single-valued) color index.  It
takes one argument, the new value for the current color index.

The current index is stored as a floating-point value.  Integer values
are converted directly to floating-point values, with no special
mapping.  The initial value is 1.

Index values outside the representable range of the color index buffer
are not clamped.  However, before an index is dithered (if enabled) and
written to the frame buffer, it is converted to fixed-point format.  Any
bits in the integer portion of the resulting fixed-point value that do
not correspond to bits in the frame buffer are masked out.

@end deftypefun

@deftypefun void glInitNames 
Initialize the name stack.

The name stack is used during selection mode to allow sets of rendering
commands to be uniquely identified.  It consists of an ordered set of
unsigned integers.  @code{glInitNames} causes the name stack to be
initialized to its default empty state.

The name stack is always empty while the render mode is not
@code{GL_SELECT}.  Calls to @code{glInitNames} while the render mode is
not @code{GL_SELECT} are ignored.

@code{GL_INVALID_OPERATION} is generated if @code{glInitNames} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glInterleavedArrays format stride pointer
Simultaneously specify and enable several interleaved arrays.

@table @asis
@item @var{format}
Specifies the type of array to enable.  Symbolic constants
@code{GL_V2F}, @code{GL_V3F}, @code{GL_C4UB_V2F}, @code{GL_C4UB_V3F},
@code{GL_C3F_V3F}, @code{GL_N3F_V3F}, @code{GL_C4F_N3F_V3F},
@code{GL_T2F_V3F}, @code{GL_T4F_V4F}, @code{GL_T2F_C4UB_V3F},
@code{GL_T2F_C3F_V3F}, @code{GL_T2F_N3F_V3F}, @code{GL_T2F_C4F_N3F_V3F},
and @code{GL_T4F_C4F_N3F_V4F} are accepted.

@item @var{stride}
Specifies the offset in bytes between each aggregate array element.

@end table

@code{glInterleavedArrays} lets you specify and enable individual color,
normal, texture and vertex arrays whose elements are part of a larger
aggregate array element.  For some implementations, this is more
efficient than specifying the arrays separately.

If @var{stride} is 0, the aggregate elements are stored consecutively.
Otherwise, @var{stride} bytes occur between the beginning of one
aggregate array element and the beginning of the next aggregate array
element.

@var{format} serves as a ``key'' describing the extraction of individual
arrays from the aggregate array.  If @var{format} contains a T, then
texture coordinates are extracted from the interleaved array.  If C is
present, color values are extracted.  If N is present, normal
coordinates are extracted.  Vertex coordinates are always extracted.

The digits 2, 3, and 4 denote how many values are extracted.  F
indicates that values are extracted as floating-point values.  Colors
may also be extracted as 4 unsigned bytes if 4UB follows the C.  If a
color is extracted as 4 unsigned bytes, the vertex array element which
follows is located at the first possible floating-point aligned address.

@code{GL_INVALID_ENUM} is generated if @var{format} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun GLboolean glIsBuffer buffer
Determine if a name corresponds to a buffer object.

@table @asis
@item @var{buffer}
Specifies a value that may be the name of a buffer object.

@end table

@code{glIsBuffer} returns @code{GL_TRUE} if @var{buffer} is currently
the name of a buffer object.  If @var{buffer} is zero, or is a non-zero
value that is not currently the name of a buffer object, or if an error
occurs, @code{glIsBuffer} returns @code{GL_FALSE}.

A name returned by @code{glGenBuffers}, but not yet associated with a
buffer object by calling @code{glBindBuffer}, is not the name of a
buffer object.

@code{GL_INVALID_OPERATION} is generated if @code{glIsBuffer} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLboolean glIsEnabled cap
Test whether a capability is enabled.

@table @asis
@item @var{cap}
Specifies a symbolic constant indicating a GL capability.

@end table

@code{glIsEnabled} returns @code{GL_TRUE} if @var{cap} is an enabled
capability and returns @code{GL_FALSE} otherwise.  Initially all
capabilities except @code{GL_DITHER} are disabled; @code{GL_DITHER} is
initially enabled.

The following capabilities are accepted for @var{cap}:



@table @asis
@item @strong{Constant}
@strong{See}

@item @code{GL_ALPHA_TEST}
@code{glAlphaFunc}

@item @code{GL_AUTO_NORMAL}
@code{glEvalCoord}

@item @code{GL_BLEND}
@code{glBlendFunc}, @code{glLogicOp}

@item @code{GL_CLIP_PLANE}@var{i}
@code{glClipPlane}

@item @code{GL_COLOR_ARRAY}
@code{glColorPointer}

@item @code{GL_COLOR_LOGIC_OP}
@code{glLogicOp}

@item @code{GL_COLOR_MATERIAL}
@code{glColorMaterial}

@item @code{GL_COLOR_SUM}
@code{glSecondaryColor}

@item @code{GL_COLOR_TABLE}
@code{glColorTable}

@item @code{GL_CONVOLUTION_1D}
@code{glConvolutionFilter1D}

@item @code{GL_CONVOLUTION_2D}
@code{glConvolutionFilter2D}

@item @code{GL_CULL_FACE}
@code{glCullFace}

@item @code{GL_DEPTH_TEST}
@code{glDepthFunc}, @code{glDepthRange}

@item @code{GL_DITHER}
@code{glEnable}

@item @code{GL_EDGE_FLAG_ARRAY}
@code{glEdgeFlagPointer}

@item @code{GL_FOG}
@code{glFog}

@item @code{GL_FOG_COORD_ARRAY}
@code{glFogCoordPointer}

@item @code{GL_HISTOGRAM}
@code{glHistogram}

@item @code{GL_INDEX_ARRAY}
@code{glIndexPointer}

@item @code{GL_INDEX_LOGIC_OP}
@code{glLogicOp}

@item @code{GL_LIGHT}@var{i}
@code{glLightModel}, @code{glLight}

@item @code{GL_LIGHTING}
@code{glMaterial}, @code{glLightModel}, @code{glLight}

@item @code{GL_LINE_SMOOTH}
@code{glLineWidth}

@item @code{GL_LINE_STIPPLE}
@code{glLineStipple}

@item @code{GL_MAP1_COLOR_4}
@code{glMap1}

@item @code{GL_MAP1_INDEX}
@code{glMap1}

@item @code{GL_MAP1_NORMAL}
@code{glMap1}

@item @code{GL_MAP1_TEXTURE_COORD_1}
@code{glMap1}

@item @code{GL_MAP1_TEXTURE_COORD_2}
@code{glMap1}

@item @code{GL_MAP1_TEXTURE_COORD_3}
@code{glMap1}

@item @code{GL_MAP1_TEXTURE_COORD_4}
@code{glMap1}

@item @code{GL_MAP2_COLOR_4}
@code{glMap2}

@item @code{GL_MAP2_INDEX}
@code{glMap2}

@item @code{GL_MAP2_NORMAL}
@code{glMap2}

@item @code{GL_MAP2_TEXTURE_COORD_1}
@code{glMap2}

@item @code{GL_MAP2_TEXTURE_COORD_2}
@code{glMap2}

@item @code{GL_MAP2_TEXTURE_COORD_3}
@code{glMap2}

@item @code{GL_MAP2_TEXTURE_COORD_4}
@code{glMap2}

@item @code{GL_MAP2_VERTEX_3}
@code{glMap2}

@item @code{GL_MAP2_VERTEX_4}
@code{glMap2}

@item @code{GL_MINMAX}
@code{glMinmax}

@item @code{GL_MULTISAMPLE}
@code{glSampleCoverage}

@item @code{GL_NORMAL_ARRAY}
@code{glNormalPointer}

@item @code{GL_NORMALIZE}
@code{glNormal}

@item @code{GL_POINT_SMOOTH}
@code{glPointSize}

@item @code{GL_POINT_SPRITE}
@code{glEnable}

@item @code{GL_POLYGON_SMOOTH}
@code{glPolygonMode}

@item @code{GL_POLYGON_OFFSET_FILL}
@code{glPolygonOffset}

@item @code{GL_POLYGON_OFFSET_LINE}
@code{glPolygonOffset}

@item @code{GL_POLYGON_OFFSET_POINT}
@code{glPolygonOffset}

@item @code{GL_POLYGON_STIPPLE}
@code{glPolygonStipple}

@item @code{GL_POST_COLOR_MATRIX_COLOR_TABLE}
@code{glColorTable}

@item @code{GL_POST_CONVOLUTION_COLOR_TABLE}
@code{glColorTable}

@item @code{GL_RESCALE_NORMAL}
@code{glNormal}

@item @code{GL_SAMPLE_ALPHA_TO_COVERAGE}
@code{glSampleCoverage}

@item @code{GL_SAMPLE_ALPHA_TO_ONE}
@code{glSampleCoverage}

@item @code{GL_SAMPLE_COVERAGE}
@code{glSampleCoverage}

@item @code{GL_SCISSOR_TEST}
@code{glScissor}

@item @code{GL_SECONDARY_COLOR_ARRAY}
@code{glSecondaryColorPointer}

@item @code{GL_SEPARABLE_2D}
@code{glSeparableFilter2D}

@item @code{GL_STENCIL_TEST}
@code{glStencilFunc}, @code{glStencilOp}

@item @code{GL_TEXTURE_1D}
@code{glTexImage1D}

@item @code{GL_TEXTURE_2D}
@code{glTexImage2D}

@item @code{GL_TEXTURE_3D}
@code{glTexImage3D}

@item @code{GL_TEXTURE_COORD_ARRAY}
@code{glTexCoordPointer}

@item @code{GL_TEXTURE_CUBE_MAP}
@code{glTexImage2D}

@item @code{GL_TEXTURE_GEN_Q}
@code{glTexGen}

@item @code{GL_TEXTURE_GEN_R}
@code{glTexGen}

@item @code{GL_TEXTURE_GEN_S}
@code{glTexGen}

@item @code{GL_TEXTURE_GEN_T}
@code{glTexGen}

@item @code{GL_VERTEX_ARRAY}
@code{glVertexPointer}

@item @code{GL_VERTEX_PROGRAM_POINT_SIZE}
@code{glEnable}

@item @code{GL_VERTEX_PROGRAM_TWO_SIDE}
@code{glEnable}

@end table



@code{GL_INVALID_ENUM} is generated if @var{cap} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glIsEnabled} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLboolean glIsList list
Determine if a name corresponds to a display list.

@table @asis
@item @var{list}
Specifies a potential display list name.

@end table

@code{glIsList} returns @code{GL_TRUE} if @var{list} is the name of a
display list and returns @code{GL_FALSE} if it is not, or if an error
occurs.

A name returned by @code{glGenLists}, but not yet associated with a
display list by calling @code{glNewList}, is not the name of a display
list.

@code{GL_INVALID_OPERATION} is generated if @code{glIsList} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun GLboolean glIsProgram program
Determines if a name corresponds to a program object.

@table @asis
@item @var{program}
Specifies a potential program object.

@end table

@code{glIsProgram} returns @code{GL_TRUE} if @var{program} is the name
of a program object previously created with @code{glCreateProgram} and
not yet deleted with @code{glDeleteProgram}.  If @var{program} is zero
or a non-zero value that is not the name of a program object, or if an
error occurs, @code{glIsProgram} returns @code{GL_FALSE}.

@code{GL_INVALID_OPERATION} is generated if @code{glIsProgram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLboolean glIsQuery id
Determine if a name corresponds to a query object.

@table @asis
@item @var{id}
Specifies a value that may be the name of a query object.

@end table

@code{glIsQuery} returns @code{GL_TRUE} if @var{id} is currently the
name of a query object.  If @var{id} is zero, or is a non-zero value
that is not currently the name of a query object, or if an error occurs,
@code{glIsQuery} returns @code{GL_FALSE}.

A name returned by @code{glGenQueries}, but not yet associated with a
query object by calling @code{glBeginQuery}, is not the name of a query
object.

@code{GL_INVALID_OPERATION} is generated if @code{glIsQuery} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun GLboolean glIsShader shader
Determines if a name corresponds to a shader object.

@table @asis
@item @var{shader}
Specifies a potential shader object.

@end table

@code{glIsShader} returns @code{GL_TRUE} if @var{shader} is the name of
a shader object previously created with @code{glCreateShader} and not
yet deleted with @code{glDeleteShader}.  If @var{shader} is zero or a
non-zero value that is not the name of a shader object, or if an error
occurs, @code{glIsShader } returns @code{GL_FALSE}.

@code{GL_INVALID_OPERATION} is generated if @code{glIsShader} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun GLboolean glIsTexture texture
Determine if a name corresponds to a texture.

@table @asis
@item @var{texture}
Specifies a value that may be the name of a texture.

@end table

@code{glIsTexture} returns @code{GL_TRUE} if @var{texture} is currently
the name of a texture.  If @var{texture} is zero, or is a non-zero value
that is not currently the name of a texture, or if an error occurs,
@code{glIsTexture} returns @code{GL_FALSE}.

A name returned by @code{glGenTextures}, but not yet associated with a
texture by calling @code{glBindTexture}, is not the name of a texture.

@code{GL_INVALID_OPERATION} is generated if @code{glIsTexture} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLightModelf pname param
@deftypefunx void glLightModeli pname param
@deftypefunx void glLightModelfv pname params
@deftypefunx void glLightModeliv pname params
Set the lighting model parameters.

@table @asis
@item @var{pname}
Specifies a single-valued lighting model parameter.
@code{GL_LIGHT_MODEL_LOCAL_VIEWER}, @code{GL_LIGHT_MODEL_COLOR_CONTROL},
and @code{GL_LIGHT_MODEL_TWO_SIDE} are accepted.

@item @var{param}
Specifies the value that @var{param} will be set to.

@end table

@code{glLightModel} sets the lighting model parameter.  @var{pname}
names a parameter and @var{params} gives the new value.  There are three
lighting model parameters:

@table @asis
@item @code{GL_LIGHT_MODEL_AMBIENT}


@var{params} contains four integer or floating-point values that specify
the ambient RGBA intensity of the entire scene.  Integer values are
mapped linearly such that the most positive representable value maps to
1.0, and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial ambient scene intensity
is (0.2, 0.2, 0.2, 1.0).

@item @code{GL_LIGHT_MODEL_COLOR_CONTROL}


@var{params} must be either @code{GL_SEPARATE_SPECULAR_COLOR} or
@code{GL_SINGLE_COLOR}.  @code{GL_SINGLE_COLOR} specifies that a single
color is generated from the lighting computation for a vertex.
@code{GL_SEPARATE_SPECULAR_COLOR} specifies that the specular color
computation of lighting be stored separately from the remainder of the
lighting computation.  The specular color is summed into the generated
fragment's color after the application of texture mapping (if enabled).
The initial value is @code{GL_SINGLE_COLOR}.

@item @code{GL_LIGHT_MODEL_LOCAL_VIEWER}


@var{params} is a single integer or floating-point value that specifies
how specular reflection angles are computed.  If @var{params} is 0 (or
0.0), specular reflection angles take the view direction to be parallel
to and in the direction of the -@var{z} axis, regardless of the location
of the vertex in eye coordinates.  Otherwise, specular reflections are
computed from the origin of the eye coordinate system.  The initial
value is 0.

@item @code{GL_LIGHT_MODEL_TWO_SIDE}


@var{params} is a single integer or floating-point value that specifies
whether one- or two-sided lighting calculations are done for polygons.
It has no effect on the lighting calculations for points, lines, or
bitmaps.  If @var{params} is 0 (or 0.0), one-sided lighting is
specified, and only the @var{front} material parameters are used in the
lighting equation.  Otherwise, two-sided lighting is specified.  In this
case, vertices of back-facing polygons are lighted using the @var{back}
material parameters and have their normals reversed before the lighting
equation is evaluated.  Vertices of front-facing polygons are always
lighted using the @var{front} material parameters, with no change to
their normals.  The initial value is 0.

@end table

In RGBA mode, the lighted color of a vertex is the sum of the material
emission intensity, the product of the material ambient reflectance and
the lighting model full-scene ambient intensity, and the contribution of
each enabled light source.  Each light source contributes the sum of
three terms: ambient, diffuse, and specular.  The ambient light source
contribution is the product of the material ambient reflectance and the
light's ambient intensity.  The diffuse light source contribution is the
product of the material diffuse reflectance, the light's diffuse
intensity, and the dot product of the vertex's normal with the
normalized vector from the vertex to the light source.  The specular
light source contribution is the product of the material specular
reflectance, the light's specular intensity, and the dot product of the
normalized vertex-to-eye and vertex-to-light vectors, raised to the
power of the shininess of the material.  All three light source
contributions are attenuated equally based on the distance from the
vertex to the light source and on light source direction, spread
exponent, and spread cutoff angle.  All dot products are replaced with 0
if they evaluate to a negative value.

The alpha component of the resulting lighted color is set to the alpha
value of the material diffuse reflectance.

In color index mode, the value of the lighted index of a vertex ranges
from the ambient to the specular values passed to @code{glMaterial}
using @code{GL_COLOR_INDEXES}.  Diffuse and specular coefficients,
computed with a (.30, .59, .11) weighting of the lights' colors, the
shininess of the material, and the same reflection and attenuation
equations as in the RGBA case, determine how much above ambient the
resulting index is.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_ENUM} is generated if @var{pname} is
@code{GL_LIGHT_MODEL_COLOR_CONTROL} and @var{params} is not one of
@code{GL_SINGLE_COLOR} or @code{GL_SEPARATE_SPECULAR_COLOR}.

@code{GL_INVALID_OPERATION} is generated if @code{glLightModel} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLightf light pname param
@deftypefunx void glLighti light pname param
@deftypefunx void glLightfv light pname params
@deftypefunx void glLightiv light pname params
Set light source parameters.

@table @asis
@item @var{light}
Specifies a light.  The number of lights depends on the implementation,
but at least eight lights are supported.  They are identified by
symbolic names of the form @code{GL_LIGHT}@r{@var{i}}, where i ranges
from 0 to the value of @code{GL_MAX_LIGHTS} - 1.

@item @var{pname}
Specifies a single-valued light source parameter for @var{light}.
@code{GL_SPOT_EXPONENT}, @code{GL_SPOT_CUTOFF},
@code{GL_CONSTANT_ATTENUATION}, @code{GL_LINEAR_ATTENUATION}, and
@code{GL_QUADRATIC_ATTENUATION} are accepted.

@item @var{param}
Specifies the value that parameter @var{pname} of light source
@var{light} will be set to.

@end table

@code{glLight} sets the values of individual light source parameters.
@var{light} names the light and is a symbolic name of the form
@code{GL_LIGHT}@r{@var{i}}, where i ranges from 0 to the value of
@code{GL_MAX_LIGHTS} - 1.  @var{pname} specifies one of ten light source
parameters, again by symbolic name.  @var{params} is either a single
value or a pointer to an array that contains the new values.

To enable and disable lighting calculation, call @code{glEnable} and
@code{glDisable} with argument @code{GL_LIGHTING}.  Lighting is
initially disabled.  When it is enabled, light sources that are enabled
contribute to the lighting calculation.  Light source @r{@var{i}} is
enabled and disabled using @code{glEnable} and @code{glDisable} with
argument @code{GL_LIGHT}@r{@var{i}}.

The ten light parameters are as follows:

@table @asis
@item @code{GL_AMBIENT}
@var{params} contains four integer or floating-point values that specify
the ambient RGBA intensity of the light.  Integer values are mapped
linearly such that the most positive representable value maps to 1.0,
and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial ambient light intensity
is (0, 0, 0, 1).

@item @code{GL_DIFFUSE}
@var{params} contains four integer or floating-point values that specify
the diffuse RGBA intensity of the light.  Integer values are mapped
linearly such that the most positive representable value maps to 1.0,
and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial value for
@code{GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is
(0, 0, 0, 1).

@item @code{GL_SPECULAR}
@var{params} contains four integer or floating-point values that specify
the specular RGBA intensity of the light.  Integer values are mapped
linearly such that the most positive representable value maps to 1.0,
and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial value for
@code{GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is
(0, 0, 0, 1).

@item @code{GL_POSITION}
@var{params} contains four integer or floating-point values that specify
the position of the light in homogeneous object coordinates.  Both
integer and floating-point values are mapped directly.  Neither integer
nor floating-point values are clamped.

The position is transformed by the modelview matrix when @code{glLight}
is called (just as if it were a point), and it is stored in eye
coordinates.  If the @r{@var{w}} component of the position is 0, the
light is treated as a directional source.  Diffuse and specular lighting
calculations take the light's direction, but not its actual position,
into account, and attenuation is disabled.  Otherwise, diffuse and
specular lighting calculations are based on the actual location of the
light in eye coordinates, and attenuation is enabled.  The initial
position is (0, 0, 1, 0); thus, the initial light source is directional,
parallel to, and in the direction of the @r{-@var{z}} axis.

@item @code{GL_SPOT_DIRECTION}
@var{params} contains three integer or floating-point values that
specify the direction of the light in homogeneous object coordinates.
Both integer and floating-point values are mapped directly.  Neither
integer nor floating-point values are clamped.

The spot direction is transformed by the upper 3x3 of the modelview
matrix when @code{glLight} is called, and it is stored in eye
coordinates.  It is significant only when @code{GL_SPOT_CUTOFF} is not
180, which it is initially.  The initial direction is @r{(0,0-1)}.

@item @code{GL_SPOT_EXPONENT}
@var{params} is a single integer or floating-point value that specifies
the intensity distribution of the light.  Integer and floating-point
values are mapped directly.  Only values in the range @r{[0,128]} are
accepted.

Effective light intensity is attenuated by the cosine of the angle
between the direction of the light and the direction from the light to
the vertex being lighted, raised to the power of the spot exponent.
Thus, higher spot exponents result in a more focused light source,
regardless of the spot cutoff angle (see @code{GL_SPOT_CUTOFF}, next
paragraph).  The initial spot exponent is 0, resulting in uniform light
distribution.

@item @code{GL_SPOT_CUTOFF}
@var{params} is a single integer or floating-point value that specifies
the maximum spread angle of a light source.  Integer and floating-point
values are mapped directly.  Only values in the range @r{[0,90]} and the
special value 180 are accepted.  If the angle between the direction of
the light and the direction from the light to the vertex being lighted
is greater than the spot cutoff angle, the light is completely masked.
Otherwise, its intensity is controlled by the spot exponent and the
attenuation factors.  The initial spot cutoff is 180, resulting in
uniform light distribution.

@item @code{GL_CONSTANT_ATTENUATION}
@item @code{GL_LINEAR_ATTENUATION}
@item @code{GL_QUADRATIC_ATTENUATION}
@var{params} is a single integer or floating-point value that specifies
one of the three light attenuation factors.  Integer and floating-point
values are mapped directly.  Only nonnegative values are accepted.  If
the light is positional, rather than directional, its intensity is
attenuated by the reciprocal of the sum of the constant factor, the
linear factor times the distance between the light and the vertex being
lighted, and the quadratic factor times the square of the same distance.
The initial attenuation factors are (1, 0, 0), resulting in no
attenuation.

@end table

@code{GL_INVALID_ENUM} is generated if either @var{light} or @var{pname}
is not an accepted value.

@code{GL_INVALID_VALUE} is generated if a spot exponent value is
specified outside the range @r{[0,128]}, or if spot cutoff is specified
outside the range @r{[0,90]} (except for the special value 180), or if a
negative attenuation factor is specified.

@code{GL_INVALID_OPERATION} is generated if @code{glLight} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glLineStipple factor pattern
Specify the line stipple pattern.

@table @asis
@item @var{factor}
Specifies a multiplier for each bit in the line stipple pattern.  If
@var{factor} is 3, for example, each bit in the pattern is used three
times before the next bit in the pattern is used.  @var{factor} is
clamped to the range [1, 256] and defaults to 1.

@item @var{pattern}
Specifies a 16-bit integer whose bit pattern determines which fragments
of a line will be drawn when the line is rasterized.  Bit zero is used
first; the default pattern is all 1's.

@end table

Line stippling masks out certain fragments produced by rasterization;
those fragments will not be drawn.  The masking is achieved by using
three parameters: the 16-bit line stipple pattern @var{pattern}, the
repeat count @var{factor}, and an integer stipple counter @r{@var{s}}.

Counter @r{@var{s}} is reset to 0 whenever @code{glBegin} is called and
before each line segment of a
@code{glBegin}(@code{GL_LINES})/@code{glEnd} sequence is generated.  It
is incremented after each fragment of a unit width aliased line segment
is generated or after each @r{@var{i}} fragments of an @r{@var{i}} width
line segment are generated.  The @r{@var{i}} fragments associated with
count @r{@var{s}} are masked out if

@var{pattern} bit @r{(@var{s}/@var{factor},)%16}

is 0, otherwise these fragments are sent to the frame buffer.  Bit zero
of @var{pattern} is the least significant bit.

Antialiased lines are treated as a sequence of @r{1×@var{width}}
rectangles for purposes of stippling.  Whether rectangle @r{@var{s}} is
rasterized or not depends on the fragment rule described for aliased
lines, counting rectangles rather than groups of fragments.

To enable and disable line stippling, call @code{glEnable} and
@code{glDisable} with argument @code{GL_LINE_STIPPLE}.  When enabled,
the line stipple pattern is applied as described above.  When disabled,
it is as if the pattern were all 1's.  Initially, line stippling is
disabled.

@code{GL_INVALID_OPERATION} is generated if @code{glLineStipple} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLineWidth width
Specify the width of rasterized lines.

@table @asis
@item @var{width}
Specifies the width of rasterized lines.  The initial value is 1.

@end table

@code{glLineWidth} specifies the rasterized width of both aliased and
antialiased lines.  Using a line width other than 1 has different
effects, depending on whether line antialiasing is enabled.  To enable
and disable line antialiasing, call @code{glEnable} and @code{glDisable}
with argument @code{GL_LINE_SMOOTH}.  Line antialiasing is initially
disabled.

If line antialiasing is disabled, the actual width is determined by
rounding the supplied width to the nearest integer.  (If the rounding
results in the value 0, it is as if the line width were 1.) If
@r{∣Δ@var{x},∣>=∣Δ@var{y},∣}, @var{i} pixels are filled in each column
that is rasterized, where @var{i} is the rounded value of @var{width}.
Otherwise, @var{i} pixels are filled in each row that is rasterized.

If antialiasing is enabled, line rasterization produces a fragment for
each pixel square that intersects the region lying within the rectangle
having width equal to the current line width, length equal to the actual
length of the line, and centered on the mathematical line segment.  The
coverage value for each fragment is the window coordinate area of the
intersection of the rectangular region with the corresponding pixel
square.  This value is saved and used in the final rasterization step.

Not all widths can be supported when line antialiasing is enabled.  If
an unsupported width is requested, the nearest supported width is used.
Only width 1 is guaranteed to be supported; others depend on the
implementation.  Likewise, there is a range for aliased line widths as
well.  To query the range of supported widths and the size difference
between supported widths within the range, call @code{glGet} with
arguments @code{GL_ALIASED_LINE_WIDTH_RANGE},
@code{GL_SMOOTH_LINE_WIDTH_RANGE}, and
@code{GL_SMOOTH_LINE_WIDTH_GRANULARITY}.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than or
equal to 0.

@code{GL_INVALID_OPERATION} is generated if @code{glLineWidth} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLinkProgram program
Links a program object.

@table @asis
@item @var{program}
Specifies the handle of the program object to be linked.

@end table

@code{glLinkProgram} links the program object specified by
@var{program}.  If any shader objects of type @code{GL_VERTEX_SHADER}
are attached to @var{program}, they will be used to create an executable
that will run on the programmable vertex processor.  If any shader
objects of type @code{GL_FRAGMENT_SHADER} are attached to @var{program},
they will be used to create an executable that will run on the
programmable fragment processor.

The status of the link operation will be stored as part of the program
object's state.  This value will be set to @code{GL_TRUE} if the program
object was linked without errors and is ready for use, and
@code{GL_FALSE} otherwise.  It can be queried by calling
@code{glGetProgram} with arguments @var{program} and
@code{GL_LINK_STATUS}.

As a result of a successful link operation, all active user-defined
uniform variables belonging to @var{program} will be initialized to 0,
and each of the program object's active uniform variables will be
assigned a location that can be queried by calling
@code{glGetUniformLocation}.  Also, any active user-defined attribute
variables that have not been bound to a generic vertex attribute index
will be bound to one at this time.

Linking of a program object can fail for a number of reasons as
specified in the @var{OpenGL Shading Language Specification}.  The
following lists some of the conditions that will cause a link error.

@itemize 
@item
The number of active attribute variables supported by the implementation
has been exceeded.

@item
The storage limit for uniform variables has been exceeded.

@item
The number of active uniform variables supported by the implementation
has been exceeded.

@item
The @code{main} function is missing for the vertex shader or the
fragment shader.

@item
A varying variable actually used in the fragment shader is not declared
in the same way (or is not declared at all) in the vertex shader.

@item
A reference to a function or variable name is unresolved.

@item
A shared global is declared with two different types or two different
initial values.

@item
One or more of the attached shader objects has not been successfully
compiled.

@item
Binding a generic attribute matrix caused some rows of the matrix to
fall outside the allowed maximum of @code{GL_MAX_VERTEX_ATTRIBS}.

@item
Not enough contiguous vertex attribute slots could be found to bind
attribute matrices.

@end itemize

When a program object has been successfully linked, the program object
can be made part of current state by calling @code{glUseProgram}.
Whether or not the link operation was successful, the program object's
information log will be overwritten.  The information log can be
retrieved by calling @code{glGetProgramInfoLog}.

@code{glLinkProgram} will also install the generated executables as part
of the current rendering state if the link operation was successful and
the specified program object is already currently in use as a result of
a previous call to @code{glUseProgram}.  If the program object currently
in use is relinked unsuccessfully, its link status will be set to
@code{GL_FALSE} , but the executables and associated state will remain
part of the current state until a subsequent call to @code{glUseProgram}
removes it from use.  After it is removed from use, it cannot be made
part of current state until it has been successfully relinked.

If @var{program} contains shader objects of type @code{GL_VERTEX_SHADER}
but does not contain shader objects of type @code{GL_FRAGMENT_SHADER},
the vertex shader will be linked against the implicit interface for
fixed functionality fragment processing.  Similarly, if @var{program}
contains shader objects of type @code{GL_FRAGMENT_SHADER} but it does
not contain shader objects of type @code{GL_VERTEX_SHADER}, the fragment
shader will be linked against the implicit interface for fixed
functionality vertex processing.

The program object's information log is updated and the program is
generated at the time of the link operation.  After the link operation,
applications are free to modify attached shader objects, compile
attached shader objects, detach shader objects, delete shader objects,
and attach additional shader objects.  None of these operations affects
the information log or the program that is part of the program object.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @code{glLinkProgram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glListBase base
Set the display-list base for .

@table @asis
@item @var{base}
Specifies an integer offset that will be added to @code{glCallLists}
offsets to generate display-list names.  The initial value is 0.

@end table

@code{glCallLists} specifies an array of offsets.  Display-list names
are generated by adding @var{base} to each offset.  Names that reference
valid display lists are executed; the others are ignored.

@code{GL_INVALID_OPERATION} is generated if @code{glListBase} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLoadIdentity 
Replace the current matrix with the identity matrix.

@code{glLoadIdentity} replaces the current matrix with the identity
matrix.  It is semantically equivalent to calling @code{glLoadMatrix}
with the identity matrix



@r{((1 0 0 0), (0 1 0 0), (0 0 1 0), (0 0 0 1),,)}



but in some cases it is more efficient.

@code{GL_INVALID_OPERATION} is generated if @code{glLoadIdentity} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLoadMatrixd m
@deftypefunx void glLoadMatrixf m
Replace the current matrix with the specified matrix.

@table @asis
@item @var{m}
Specifies a pointer to 16 consecutive values, which are used as the
elements of a @r{4×4} column-major matrix.

@end table

@code{glLoadMatrix} replaces the current matrix with the one whose
elements are specified by @var{m}.  The current matrix is the projection
matrix, modelview matrix, or texture matrix, depending on the current
matrix mode (see @code{glMatrixMode}).

The current matrix, M, defines a transformation of coordinates.  For
instance, assume M refers to the modelview matrix.  If
@r{@var{v}=(@var{v}⁡[0,],@var{v}⁡[1,]@var{v}⁡[2,]@var{v}⁡[3,])} is the
set of object coordinates of a vertex, and @var{m} points to an array of
@r{16} single- or double-precision floating-point values
@r{@var{m}=@{@var{m}⁡[0,],@var{m}⁡[1,]@var{...}@var{m}⁡[15,]@}}, then
the modelview transformation @r{@var{M}⁡(@var{v},)} does the following:

@r{@var{M}⁡(@var{v},)=((@var{m}⁡[0,] @var{m}⁡[4,] @var{m}⁡[8,]
@var{m}⁡[12,]), (@var{m}⁡[1,] @var{m}⁡[5,] @var{m}⁡[9,] @var{m}⁡[13,]),
(@var{m}⁡[2,] @var{m}⁡[6,] @var{m}⁡[10,] @var{m}⁡[14,]), (@var{m}⁡[3,]
@var{m}⁡[7,] @var{m}⁡[11,] @var{m}⁡[15,]),)×((@var{v}⁡[0,]),
(@var{v}⁡[1,]), (@var{v}⁡[2,]), (@var{v}⁡[3,]),)}



Projection and texture transformations are similarly defined.

@code{GL_INVALID_OPERATION} is generated if @code{glLoadMatrix} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLoadName name
Load a name onto the name stack.

@table @asis
@item @var{name}
Specifies a name that will replace the top value on the name stack.

@end table

The name stack is used during selection mode to allow sets of rendering
commands to be uniquely identified.  It consists of an ordered set of
unsigned integers and is initially empty.

@code{glLoadName} causes @var{name} to replace the value on the top of
the name stack.

The name stack is always empty while the render mode is not
@code{GL_SELECT}.  Calls to @code{glLoadName} while the render mode is
not @code{GL_SELECT} are ignored.

@code{GL_INVALID_OPERATION} is generated if @code{glLoadName} is called
while the name stack is empty.

@code{GL_INVALID_OPERATION} is generated if @code{glLoadName} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLoadTransposeMatrixd m
@deftypefunx void glLoadTransposeMatrixf m
Replace the current matrix with the specified row-major ordered matrix.

@table @asis
@item @var{m}
Specifies a pointer to 16 consecutive values, which are used as the
elements of a @r{4×4} row-major matrix.

@end table

@code{glLoadTransposeMatrix} replaces the current matrix with the one
whose elements are specified by @var{m}.  The current matrix is the
projection matrix, modelview matrix, or texture matrix, depending on the
current matrix mode (see @code{glMatrixMode}).

The current matrix, M, defines a transformation of coordinates.  For
instance, assume M refers to the modelview matrix.  If
@r{@var{v}=(@var{v}⁡[0,],@var{v}⁡[1,]@var{v}⁡[2,]@var{v}⁡[3,])} is the
set of object coordinates of a vertex, and @var{m} points to an array of
@r{16} single- or double-precision floating-point values
@r{@var{m}=@{@var{m}⁡[0,],@var{m}⁡[1,]@var{...}@var{m}⁡[15,]@}}, then
the modelview transformation @r{@var{M}⁡(@var{v},)} does the following:

@r{@var{M}⁡(@var{v},)=((@var{m}⁡[0,] @var{m}⁡[1,] @var{m}⁡[2,]
@var{m}⁡[3,]), (@var{m}⁡[4,] @var{m}⁡[5,] @var{m}⁡[6,] @var{m}⁡[7,]),
(@var{m}⁡[8,] @var{m}⁡[9,] @var{m}⁡[10,] @var{m}⁡[11,]), (@var{m}⁡[12,]
@var{m}⁡[13,] @var{m}⁡[14,] @var{m}⁡[15,]),)×((@var{v}⁡[0,]),
(@var{v}⁡[1,]), (@var{v}⁡[2,]), (@var{v}⁡[3,]),)}



Projection and texture transformations are similarly defined.

Calling @code{glLoadTransposeMatrix} with matrix @r{@var{M}} is
identical in operation to @code{glLoadMatrix} with @r{@var{M}^@var{T}},
where @r{@var{T}} represents the transpose.

@code{GL_INVALID_OPERATION} is generated if @code{glLoadTransposeMatrix}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glLogicOp opcode
Specify a logical pixel operation for color index rendering.

@table @asis
@item @var{opcode}
Specifies a symbolic constant that selects a logical operation.  The
following symbols are accepted: @code{GL_CLEAR}, @code{GL_SET},
@code{GL_COPY}, @code{GL_COPY_INVERTED}, @code{GL_NOOP},
@code{GL_INVERT}, @code{GL_AND}, @code{GL_NAND}, @code{GL_OR},
@code{GL_NOR}, @code{GL_XOR}, @code{GL_EQUIV}, @code{GL_AND_REVERSE},
@code{GL_AND_INVERTED}, @code{GL_OR_REVERSE}, and @code{GL_OR_INVERTED}.
The initial value is @code{GL_COPY}.

@end table

@code{glLogicOp} specifies a logical operation that, when enabled, is
applied between the incoming color index or RGBA color and the color
index or RGBA color at the corresponding location in the frame buffer.
To enable or disable the logical operation, call @code{glEnable} and
@code{glDisable} using the symbolic constant @code{GL_COLOR_LOGIC_OP}
for RGBA mode or @code{GL_INDEX_LOGIC_OP} for color index mode.  The
initial value is disabled for both operations.



@table @asis
@item @strong{Opcode}
@strong{Resulting Operation}

@item @code{GL_CLEAR}
0

@item @code{GL_SET}
1

@item @code{GL_COPY}
s

@item @code{GL_COPY_INVERTED}
~s

@item @code{GL_NOOP}
d

@item @code{GL_INVERT}
~d

@item @code{GL_AND}
s & d

@item @code{GL_NAND}
~(s & d)

@item @code{GL_OR}
s | d

@item @code{GL_NOR}
~(s | d)

@item @code{GL_XOR}
s ^ d

@item @code{GL_EQUIV}
~(s ^ d)

@item @code{GL_AND_REVERSE}
s & ~d

@item @code{GL_AND_INVERTED}
~s & d

@item @code{GL_OR_REVERSE}
s | ~d

@item @code{GL_OR_INVERTED}
~s | d

@end table

@var{opcode} is a symbolic constant chosen from the list above.  In the
explanation of the logical operations, @var{s} represents the incoming
color index and @var{d} represents the index in the frame buffer.
Standard C-language operators are used.  As these bitwise operators
suggest, the logical operation is applied independently to each bit pair
of the source and destination indices or colors.

@code{GL_INVALID_ENUM} is generated if @var{opcode} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glLogicOp} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glMap1f target u1 u2 stride order points
@deftypefunx void glMap1d target u1 u2 stride order points
Define a one-dimensional evaluator.

@table @asis
@item @var{target}
Specifies the kind of values that are generated by the evaluator.
Symbolic constants @code{GL_MAP1_VERTEX_3}, @code{GL_MAP1_VERTEX_4},
@code{GL_MAP1_INDEX}, @code{GL_MAP1_COLOR_4}, @code{GL_MAP1_NORMAL},
@code{GL_MAP1_TEXTURE_COORD_1}, @code{GL_MAP1_TEXTURE_COORD_2},
@code{GL_MAP1_TEXTURE_COORD_3}, and @code{GL_MAP1_TEXTURE_COORD_4} are
accepted.

@item @var{u1}
@itemx @var{u2}
Specify a linear mapping of @r{@var{u}}, as presented to
@code{glEvalCoord1}, to @r{@var{u}^}, the variable that is evaluated by
the equations specified by this command.

@item @var{stride}
Specifies the number of floats or doubles between the beginning of one
control point and the beginning of the next one in the data structure
referenced in @var{points}.  This allows control points to be embedded
in arbitrary data structures.  The only constraint is that the values
for a particular control point must occupy contiguous memory locations.

@item @var{order}
Specifies the number of control points.  Must be positive.

@item @var{points}
Specifies a pointer to the array of control points.

@end table

Evaluators provide a way to use polynomial or rational polynomial
mapping to produce vertices, normals, texture coordinates, and colors.
The values produced by an evaluator are sent to further stages of GL
processing just as if they had been presented using @code{glVertex},
@code{glNormal}, @code{glTexCoord}, and @code{glColor} commands, except
that the generated values do not update the current normal, texture
coordinates, or color.

All polynomial or rational polynomial splines of any degree (up to the
maximum degree supported by the GL implementation) can be described
using evaluators.  These include almost all splines used in computer
graphics: B-splines, Bezier curves, Hermite splines, and so on.

Evaluators define curves based on Bernstein polynomials.  Define
@r{@var{p}⁡(@var{u}^,)} as

@r{@var{p}⁡(@var{u}^,)=Σ@var{i}=0@var{n}@var{B}_@var{i},^@var{n}⁡(@var{u}^,)⁢@var{R}_@var{i}}



where @r{@var{R}_@var{i}} is a control point and
@r{@var{B}_@var{i},^@var{n}⁡(@var{u}^,)} is the @r{@var{i}}th Bernstein
polynomial of degree @r{@var{n}} (@var{order} = @r{@var{n}+1}):

@r{@var{B}_@var{i},^@var{n}⁡(@var{u}^,)=((@var{n}),
(@var{i}),,)⁢@var{u}^,^@var{i}⁢(1-@var{u}^,)^@var{n}-@var{i},,}

Recall that

@r{0^0==1} and @r{((@var{n}), (0),,)==1}

@code{glMap1} is used to define the basis and to specify what kind of
values are produced.  Once defined, a map can be enabled and disabled by
calling @code{glEnable} and @code{glDisable} with the map name, one of
the nine predefined values for @var{target} described below.
@code{glEvalCoord1} evaluates the one-dimensional maps that are enabled.
When @code{glEvalCoord1} presents a value @r{@var{u}}, the Bernstein
functions are evaluated using @r{@var{u}^}, where
@r{@var{u}^=@var{u}-@var{u1},/@var{u2}-@var{u1},}

@var{target} is a symbolic constant that indicates what kind of control
points are provided in @var{points}, and what output is generated when
the map is evaluated.  It can assume one of nine predefined values:

@table @asis
@item @code{GL_MAP1_VERTEX_3}
Each control point is three floating-point values representing
@r{@var{x}}, @r{@var{y}}, and @r{@var{z}}.  Internal @code{glVertex3}
commands are generated when the map is evaluated.

@item @code{GL_MAP1_VERTEX_4}
Each control point is four floating-point values representing
@r{@var{x}}, @r{@var{y}}, @r{@var{z}}, and @r{@var{w}}.  Internal
@code{glVertex4} commands are generated when the map is evaluated.

@item @code{GL_MAP1_INDEX}
Each control point is a single floating-point value representing a color
index.  Internal @code{glIndex} commands are generated when the map is
evaluated but the current index is not updated with the value of these
@code{glIndex} commands.

@item @code{GL_MAP1_COLOR_4}
Each control point is four floating-point values representing red,
green, blue, and alpha.  Internal @code{glColor4} commands are generated
when the map is evaluated but the current color is not updated with the
value of these @code{glColor4} commands.

@item @code{GL_MAP1_NORMAL}
Each control point is three floating-point values representing the
@r{@var{x}}, @r{@var{y}}, and @r{@var{z}} components of a normal vector.
Internal @code{glNormal} commands are generated when the map is
evaluated but the current normal is not updated with the value of these
@code{glNormal} commands.

@item @code{GL_MAP1_TEXTURE_COORD_1}
Each control point is a single floating-point value representing the
@r{@var{s}} texture coordinate.  Internal @code{glTexCoord1} commands
are generated when the map is evaluated but the current texture
coordinates are not updated with the value of these @code{glTexCoord}
commands.

@item @code{GL_MAP1_TEXTURE_COORD_2}
Each control point is two floating-point values representing the
@r{@var{s}} and @r{@var{t}} texture coordinates.  Internal
@code{glTexCoord2} commands are generated when the map is evaluated but
the current texture coordinates are not updated with the value of these
@code{glTexCoord} commands.

@item @code{GL_MAP1_TEXTURE_COORD_3}
Each control point is three floating-point values representing the
@r{@var{s}}, @r{@var{t}}, and @r{@var{r}} texture coordinates.  Internal
@code{glTexCoord3} commands are generated when the map is evaluated but
the current texture coordinates are not updated with the value of these
@code{glTexCoord} commands.

@item @code{GL_MAP1_TEXTURE_COORD_4}
Each control point is four floating-point values representing the
@r{@var{s}}, @r{@var{t}}, @r{@var{r}}, and @r{@var{q}} texture
coordinates.  Internal @code{glTexCoord4} commands are generated when
the map is evaluated but the current texture coordinates are not updated
with the value of these @code{glTexCoord} commands.

@end table

@var{stride}, @var{order}, and @var{points} define the array addressing
for accessing the control points.  @var{points} is the location of the
first control point, which occupies one, two, three, or four contiguous
memory locations, depending on which map is being defined.  @var{order}
is the number of control points in the array.  @var{stride} specifies
how many float or double locations to advance the internal memory
pointer to reach the next control point.

@code{GL_INVALID_ENUM} is generated if @var{target} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{u1} is equal to @var{u2}.

@code{GL_INVALID_VALUE} is generated if @var{stride} is less than the
number of values in a control point.

@code{GL_INVALID_VALUE} is generated if @var{order} is less than 1 or
greater than the return value of @code{GL_MAX_EVAL_ORDER}.

@code{GL_INVALID_OPERATION} is generated if @code{glMap1} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@code{GL_INVALID_OPERATION} is generated if @code{glMap1} is called and
the value of @code{GL_ACTIVE_TEXTURE} is not @code{GL_TEXTURE0}.

@end deftypefun

@deftypefun void glMap2f target u1 u2 ustride uorder v1 v2 vstride vorder points
@deftypefunx void glMap2d target u1 u2 ustride uorder v1 v2 vstride vorder points
Define a two-dimensional evaluator.

@table @asis
@item @var{target}
Specifies the kind of values that are generated by the evaluator.
Symbolic constants @code{GL_MAP2_VERTEX_3}, @code{GL_MAP2_VERTEX_4},
@code{GL_MAP2_INDEX}, @code{GL_MAP2_COLOR_4}, @code{GL_MAP2_NORMAL},
@code{GL_MAP2_TEXTURE_COORD_1}, @code{GL_MAP2_TEXTURE_COORD_2},
@code{GL_MAP2_TEXTURE_COORD_3}, and @code{GL_MAP2_TEXTURE_COORD_4} are
accepted.

@item @var{u1}
@itemx @var{u2}
Specify a linear mapping of @r{@var{u}}, as presented to
@code{glEvalCoord2}, to @r{@var{u}^}, one of the two variables that are
evaluated by the equations specified by this command.  Initially,
@var{u1} is 0 and @var{u2} is 1.

@item @var{ustride}
Specifies the number of floats or doubles between the beginning of
control point @r{@var{R}_@var{ij}} and the beginning of control point
@r{@var{R}_(@var{i}+1,)⁢@var{j},}, where @r{@var{i}} and @r{@var{j}} are
the @r{@var{u}} and @r{@var{v}} control point indices, respectively.
This allows control points to be embedded in arbitrary data structures.
The only constraint is that the values for a particular control point
must occupy contiguous memory locations.  The initial value of
@var{ustride} is 0.

@item @var{uorder}
Specifies the dimension of the control point array in the @r{@var{u}}
axis.  Must be positive.  The initial value is 1.

@item @var{v1}
@itemx @var{v2}
Specify a linear mapping of @r{@var{v}}, as presented to
@code{glEvalCoord2}, to @r{@var{v}^}, one of the two variables that are
evaluated by the equations specified by this command.  Initially,
@var{v1} is 0 and @var{v2} is 1.

@item @var{vstride}
Specifies the number of floats or doubles between the beginning of
control point @r{@var{R}_@var{ij}} and the beginning of control point
@r{@var{R}_@var{i}⁡(@var{j}+1,),}, where @r{@var{i}} and @r{@var{j}} are
the @r{@var{u}} and @r{@var{v}} control point indices, respectively.
This allows control points to be embedded in arbitrary data structures.
The only constraint is that the values for a particular control point
must occupy contiguous memory locations.  The initial value of
@var{vstride} is 0.

@item @var{vorder}
Specifies the dimension of the control point array in the @r{@var{v}}
axis.  Must be positive.  The initial value is 1.

@item @var{points}
Specifies a pointer to the array of control points.

@end table

Evaluators provide a way to use polynomial or rational polynomial
mapping to produce vertices, normals, texture coordinates, and colors.
The values produced by an evaluator are sent on to further stages of GL
processing just as if they had been presented using @code{glVertex},
@code{glNormal}, @code{glTexCoord}, and @code{glColor} commands, except
that the generated values do not update the current normal, texture
coordinates, or color.

All polynomial or rational polynomial splines of any degree (up to the
maximum degree supported by the GL implementation) can be described
using evaluators.  These include almost all surfaces used in computer
graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces,
and so on.

Evaluators define surfaces based on bivariate Bernstein polynomials.
Define @r{@var{p}⁡(@var{u}^,@var{v}^)} as

@r{@var{p}⁡(@var{u}^,@var{v}^)=Σ@var{i}=0@var{n}Σ@var{j}=0@var{m}@var{B}_@var{i},^@var{n}⁡(@var{u}^,)⁢@var{B}_@var{j},^@var{m}⁡(@var{v}^,)⁢@var{R}_@var{ij}}



where @r{@var{R}_@var{ij}} is a control point,
@r{@var{B}_@var{i},^@var{n}⁡(@var{u}^,)} is the @r{@var{i}}th Bernstein
polynomial of degree @r{@var{n}} (@var{uorder} = @r{@var{n}+1})

@r{@var{B}_@var{i},^@var{n}⁡(@var{u}^,)=((@var{n}),
(@var{i}),,)⁢@var{u}^,^@var{i}⁢(1-@var{u}^,)^@var{n}-@var{i},,}

and @r{@var{B}_@var{j},^@var{m}⁡(@var{v}^,)} is the @r{@var{j}}th
Bernstein polynomial of degree @r{@var{m}} (@var{vorder} =
@r{@var{m}+1})

@r{@var{B}_@var{j},^@var{m}⁡(@var{v}^,)=((@var{m}),
(@var{j}),,)⁢@var{v}^,^@var{j}⁢(1-@var{v}^,)^@var{m}-@var{j},,}

Recall that @r{0^0==1} and @r{((@var{n}), (0),,)==1}

@code{glMap2} is used to define the basis and to specify what kind of
values are produced.  Once defined, a map can be enabled and disabled by
calling @code{glEnable} and @code{glDisable} with the map name, one of
the nine predefined values for @var{target}, described below.  When
@code{glEvalCoord2} presents values @r{@var{u}} and @r{@var{v}}, the
bivariate Bernstein polynomials are evaluated using @r{@var{u}^} and
@r{@var{v}^}, where

@r{@var{u}^=@var{u}-@var{u1},/@var{u2}-@var{u1},}

@r{@var{v}^=@var{v}-@var{v1},/@var{v2}-@var{v1},}

@var{target} is a symbolic constant that indicates what kind of control
points are provided in @var{points}, and what output is generated when
the map is evaluated.  It can assume one of nine predefined values:

@table @asis
@item @code{GL_MAP2_VERTEX_3}
Each control point is three floating-point values representing
@r{@var{x}}, @r{@var{y}}, and @r{@var{z}}.  Internal @code{glVertex3}
commands are generated when the map is evaluated.

@item @code{GL_MAP2_VERTEX_4}
Each control point is four floating-point values representing
@r{@var{x}}, @r{@var{y}}, @r{@var{z}}, and @r{@var{w}}.  Internal
@code{glVertex4} commands are generated when the map is evaluated.

@item @code{GL_MAP2_INDEX}
Each control point is a single floating-point value representing a color
index.  Internal @code{glIndex} commands are generated when the map is
evaluated but the current index is not updated with the value of these
@code{glIndex} commands.

@item @code{GL_MAP2_COLOR_4}
Each control point is four floating-point values representing red,
green, blue, and alpha.  Internal @code{glColor4} commands are generated
when the map is evaluated but the current color is not updated with the
value of these @code{glColor4} commands.

@item @code{GL_MAP2_NORMAL}
Each control point is three floating-point values representing the
@r{@var{x}}, @r{@var{y}}, and @r{@var{z}} components of a normal vector.
Internal @code{glNormal} commands are generated when the map is
evaluated but the current normal is not updated with the value of these
@code{glNormal} commands.

@item @code{GL_MAP2_TEXTURE_COORD_1}
Each control point is a single floating-point value representing the
@r{@var{s}} texture coordinate.  Internal @code{glTexCoord1} commands
are generated when the map is evaluated but the current texture
coordinates are not updated with the value of these @code{glTexCoord}
commands.

@item @code{GL_MAP2_TEXTURE_COORD_2}
Each control point is two floating-point values representing the
@r{@var{s}} and @r{@var{t}} texture coordinates.  Internal
@code{glTexCoord2} commands are generated when the map is evaluated but
the current texture coordinates are not updated with the value of these
@code{glTexCoord} commands.

@item @code{GL_MAP2_TEXTURE_COORD_3}
Each control point is three floating-point values representing the
@r{@var{s}}, @r{@var{t}}, and @r{@var{r}} texture coordinates.  Internal
@code{glTexCoord3} commands are generated when the map is evaluated but
the current texture coordinates are not updated with the value of these
@code{glTexCoord} commands.

@item @code{GL_MAP2_TEXTURE_COORD_4}
Each control point is four floating-point values representing the
@r{@var{s}}, @r{@var{t}}, @r{@var{r}}, and @r{@var{q}} texture
coordinates.  Internal @code{glTexCoord4} commands are generated when
the map is evaluated but the current texture coordinates are not updated
with the value of these @code{glTexCoord} commands.

@end table

@var{ustride}, @var{uorder}, @var{vstride}, @var{vorder}, and
@var{points} define the array addressing for accessing the control
points.  @var{points} is the location of the first control point, which
occupies one, two, three, or four contiguous memory locations, depending
on which map is being defined.  There are @r{@var{uorder}×@var{vorder}}
control points in the array.  @var{ustride} specifies how many float or
double locations are skipped to advance the internal memory pointer from
control point @r{@var{R}_@var{i}⁢@var{j},} to control point
@r{@var{R}_(@var{i}+1,)⁢@var{j},}.  @var{vstride} specifies how many
float or double locations are skipped to advance the internal memory
pointer from control point @r{@var{R}_@var{i}⁢@var{j},} to control point
@r{@var{R}_@var{i}⁡(@var{j}+1,),}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{u1} is equal to @var{u2},
or if @var{v1} is equal to @var{v2}.

@code{GL_INVALID_VALUE} is generated if either @var{ustride} or
@var{vstride} is less than the number of values in a control point.

@code{GL_INVALID_VALUE} is generated if either @var{uorder} or
@var{vorder} is less than 1 or greater than the return value of
@code{GL_MAX_EVAL_ORDER}.

@code{GL_INVALID_OPERATION} is generated if @code{glMap2} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@code{GL_INVALID_OPERATION} is generated if @code{glMap2} is called and
the value of @code{GL_ACTIVE_TEXTURE} is not @code{GL_TEXTURE0}.

@end deftypefun

@deftypefun void-* glMapBuffer target access
@deftypefunx GLboolean glUnmapBuffer target
Map a buffer object's data store.

@table @asis
@item @var{target}
Specifies the target buffer object being mapped.  The symbolic constant
must be @code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@item @var{access}
Specifies the access policy, indicating whether it will be possible to
read from, write to, or both read from and write to the buffer object's
mapped data store.  The symbolic constant must be @code{GL_READ_ONLY},
@code{GL_WRITE_ONLY}, or @code{GL_READ_WRITE}.

@end table

@code{glMapBuffer} maps to the client's address space the entire data
store of the buffer object currently bound to @var{target}.  The data
can then be directly read and/or written relative to the returned
pointer, depending on the specified @var{access} policy.  If the GL is
unable to map the buffer object's data store, @code{glMapBuffer}
generates an error and returns @code{NULL}.  This may occur for
system-specific reasons, such as low virtual memory availability.

If a mapped data store is accessed in a way inconsistent with the
specified @var{access} policy, no error is generated, but performance
may be negatively impacted and system errors, including program
termination, may result.  Unlike the @var{usage} parameter of
@code{glBufferData}, @var{access} is not a hint, and does in fact
constrain the usage of the mapped data store on some GL implementations.
In order to achieve the highest performance available, a buffer object's
data store should be used in ways consistent with both its specified
@var{usage} and @var{access} parameters.

A mapped data store must be unmapped with @code{glUnmapBuffer} before
its buffer object is used.  Otherwise an error will be generated by any
GL command that attempts to dereference the buffer object's data store.
When a data store is unmapped, the pointer to its data store becomes
invalid.  @code{glUnmapBuffer} returns @code{GL_TRUE} unless the data
store contents have become corrupt during the time the data store was
mapped.  This can occur for system-specific reasons that affect the
availability of graphics memory, such as screen mode changes.  In such
situations, @code{GL_FALSE} is returned and the data store contents are
undefined.  An application must detect this rare condition and
reinitialize the data store.

A buffer object's mapped data store is automatically unmapped when the
buffer object is deleted or its data store is recreated with
@code{glBufferData}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_ARRAY_BUFFER}, @code{GL_ELEMENT_ARRAY_BUFFER},
@code{GL_PIXEL_PACK_BUFFER}, or @code{GL_PIXEL_UNPACK_BUFFER}.

@code{GL_INVALID_ENUM} is generated if @var{access} is not
@code{GL_READ_ONLY}, @code{GL_WRITE_ONLY}, or @code{GL_READ_WRITE}.

@code{GL_OUT_OF_MEMORY} is generated when @code{glMapBuffer} is executed
if the GL is unable to map the buffer object's data store.  This may
occur for a variety of system-specific reasons, such as the absence of
sufficient remaining virtual memory.

@code{GL_INVALID_OPERATION} is generated if the reserved buffer object
name 0 is bound to @var{target}.

@code{GL_INVALID_OPERATION} is generated if @code{glMapBuffer} is
executed for a buffer object whose data store is already mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glUnmapBuffer} is
executed for a buffer object whose data store is not currently mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glMapBuffer} or
@code{glUnmapBuffer} is executed between the execution of @code{glBegin}
and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glMapGrid1d un u1 u2
@deftypefunx void glMapGrid1f un u1 u2
@deftypefunx void glMapGrid2d un u1 u2 vn v1 v2
@deftypefunx void glMapGrid2f un u1 u2 vn v1 v2
Define a one- or two-dimensional mesh.

@table @asis
@item @var{un}
Specifies the number of partitions in the grid range interval [@var{u1},
@var{u2}].  Must be positive.

@item @var{u1}
@itemx @var{u2}
Specify the mappings for integer grid domain values @r{@var{i}=0} and
@r{@var{i}=@var{un}}.

@item @var{vn}
Specifies the number of partitions in the grid range interval [@var{v1},
@var{v2}] (@code{glMapGrid2} only).

@item @var{v1}
@itemx @var{v2}
Specify the mappings for integer grid domain values @r{@var{j}=0} and
@r{@var{j}=@var{vn}} (@code{glMapGrid2} only).

@end table

@code{glMapGrid} and @code{glEvalMesh} are used together to efficiently
generate and evaluate a series of evenly-spaced map domain values.
@code{glEvalMesh} steps through the integer domain of a one- or
two-dimensional grid, whose range is the domain of the evaluation maps
specified by @code{glMap1} and @code{glMap2}.

@code{glMapGrid1} and @code{glMapGrid2} specify the linear grid mappings
between the @r{@var{i}} (or @r{@var{i}} and @r{@var{j}}) integer grid
coordinates, to the @r{@var{u}} (or @r{@var{u}} and @r{@var{v}})
floating-point evaluation map coordinates.  See @code{glMap1} and
@code{glMap2} for details of how @r{@var{u}} and @r{@var{v}} coordinates
are evaluated.

@code{glMapGrid1} specifies a single linear mapping such that integer
grid coordinate 0 maps exactly to @var{u1}, and integer grid coordinate
@var{un} maps exactly to @var{u2}.  All other integer grid coordinates
@r{@var{i}} are mapped so that

@r{@var{u}=@var{i}⁡(@var{u2}-@var{u1},)/@var{un}+@var{u1}}

@code{glMapGrid2} specifies two such linear mappings.  One maps integer
grid coordinate @r{@var{i}=0} exactly to @var{u1}, and integer grid
coordinate @r{@var{i}=@var{un}} exactly to @var{u2}.  The other maps
integer grid coordinate @r{@var{j}=0} exactly to @var{v1}, and integer
grid coordinate @r{@var{j}=@var{vn}} exactly to @var{v2}.  Other integer
grid coordinates @r{@var{i}} and @r{@var{j}} are mapped such that

@r{@var{u}=@var{i}⁡(@var{u2}-@var{u1},)/@var{un}+@var{u1}}

@r{@var{v}=@var{j}⁡(@var{v2}-@var{v1},)/@var{vn}+@var{v1}}

The mappings specified by @code{glMapGrid} are used identically by
@code{glEvalMesh} and @code{glEvalPoint}.

@code{GL_INVALID_VALUE} is generated if either @var{un} or @var{vn} is
not positive.

@code{GL_INVALID_OPERATION} is generated if @code{glMapGrid} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glMaterialf face pname param
@deftypefunx void glMateriali face pname param
@deftypefunx void glMaterialfv face pname params
@deftypefunx void glMaterialiv face pname params
Specify material parameters for the lighting model.

@table @asis
@item @var{face}
Specifies which face or faces are being updated.  Must be one of
@code{GL_FRONT}, @code{GL_BACK}, or @code{GL_FRONT_AND_BACK}.

@item @var{pname}
Specifies the single-valued material parameter of the face or faces that
is being updated.  Must be @code{GL_SHININESS}.

@item @var{param}
Specifies the value that parameter @code{GL_SHININESS} will be set to.

@end table

@code{glMaterial} assigns values to material parameters.  There are two
matched sets of material parameters.  One, the @var{front-facing} set,
is used to shade points, lines, bitmaps, and all polygons (when
two-sided lighting is disabled), or just front-facing polygons (when
two-sided lighting is enabled).  The other set, @var{back-facing}, is
used to shade back-facing polygons only when two-sided lighting is
enabled.  Refer to the @code{glLightModel} reference page for details
concerning one- and two-sided lighting calculations.

@code{glMaterial} takes three arguments.  The first, @var{face},
specifies whether the @code{GL_FRONT} materials, the @code{GL_BACK}
materials, or both @code{GL_FRONT_AND_BACK} materials will be modified.
The second, @var{pname}, specifies which of several parameters in one or
both sets will be modified.  The third, @var{params}, specifies what
value or values will be assigned to the specified parameter.

Material parameters are used in the lighting equation that is optionally
applied to each vertex.  The equation is discussed in the
@code{glLightModel} reference page.  The parameters that can be
specified using @code{glMaterial}, and their interpretations by the
lighting equation, are as follows:

@table @asis
@item @code{GL_AMBIENT}
@var{params} contains four integer or floating-point values that specify
the ambient RGBA reflectance of the material.  Integer values are mapped
linearly such that the most positive representable value maps to 1.0,
and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial ambient reflectance for
both front- and back-facing materials is (0.2, 0.2, 0.2, 1.0).

@item @code{GL_DIFFUSE}
@var{params} contains four integer or floating-point values that specify
the diffuse RGBA reflectance of the material.  Integer values are mapped
linearly such that the most positive representable value maps to 1.0,
and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial diffuse reflectance for
both front- and back-facing materials is (0.8, 0.8, 0.8, 1.0).

@item @code{GL_SPECULAR}
@var{params} contains four integer or floating-point values that specify
the specular RGBA reflectance of the material.  Integer values are
mapped linearly such that the most positive representable value maps to
1.0, and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial specular reflectance for
both front- and back-facing materials is (0, 0, 0, 1).

@item @code{GL_EMISSION}
@var{params} contains four integer or floating-point values that specify
the RGBA emitted light intensity of the material.  Integer values are
mapped linearly such that the most positive representable value maps to
1.0, and the most negative representable value maps to @r{-1.0}.
Floating-point values are mapped directly.  Neither integer nor
floating-point values are clamped.  The initial emission intensity for
both front- and back-facing materials is (0, 0, 0, 1).

@item @code{GL_SHININESS}
@var{params} is a single integer or floating-point value that specifies
the RGBA specular exponent of the material.  Integer and floating-point
values are mapped directly.  Only values in the range @r{[0,128]} are
accepted.  The initial specular exponent for both front- and back-facing
materials is 0.

@item @code{GL_AMBIENT_AND_DIFFUSE}
Equivalent to calling @code{glMaterial} twice with the same parameter
values, once with @code{GL_AMBIENT} and once with @code{GL_DIFFUSE}.

@item @code{GL_COLOR_INDEXES}
@var{params} contains three integer or floating-point values specifying
the color indices for ambient, diffuse, and specular lighting.  These
three values, and @code{GL_SHININESS}, are the only material values used
by the color index mode lighting equation.  Refer to the
@code{glLightModel} reference page for a discussion of color index
lighting.

@end table

@code{GL_INVALID_ENUM} is generated if either @var{face} or @var{pname}
is not an accepted value.

@code{GL_INVALID_VALUE} is generated if a specular exponent outside the
range @r{[0,128]} is specified.

@end deftypefun

@deftypefun void glMatrixMode mode
Specify which matrix is the current matrix.

@table @asis
@item @var{mode}
Specifies which matrix stack is the target for subsequent matrix
operations.  Three values are accepted: @code{GL_MODELVIEW},
@code{GL_PROJECTION}, and @code{GL_TEXTURE}.  The initial value is
@code{GL_MODELVIEW}.  Additionally, if the @code{ARB_imaging} extension
is supported, @code{GL_COLOR} is also accepted.

@end table

@code{glMatrixMode} sets the current matrix mode.  @var{mode} can assume
one of four values:

@table @asis
@item @code{GL_MODELVIEW}
Applies subsequent matrix operations to the modelview matrix stack.

@item @code{GL_PROJECTION}
Applies subsequent matrix operations to the projection matrix stack.

@item @code{GL_TEXTURE}
Applies subsequent matrix operations to the texture matrix stack.

@item @code{GL_COLOR}
Applies subsequent matrix operations to the color matrix stack.

@end table

To find out which matrix stack is currently the target of all matrix
operations, call @code{glGet} with argument @code{GL_MATRIX_MODE}.  The
initial value is @code{GL_MODELVIEW}.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glMatrixMode} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glMinmax target internalformat sink
Define minmax table.

@table @asis
@item @var{target}
The minmax table whose parameters are to be set.  Must be
@code{GL_MINMAX}.

@item @var{internalformat}
The format of entries in the minmax table.  Must be one of
@code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8}, @code{GL_ALPHA12},
@code{GL_ALPHA16}, @code{GL_LUMINANCE}, @code{GL_LUMINANCE4},
@code{GL_LUMINANCE8}, @code{GL_LUMINANCE12}, @code{GL_LUMINANCE16},
@code{GL_LUMINANCE_ALPHA}, @code{GL_LUMINANCE4_ALPHA4},
@code{GL_LUMINANCE6_ALPHA2}, @code{GL_LUMINANCE8_ALPHA8},
@code{GL_LUMINANCE12_ALPHA4}, @code{GL_LUMINANCE12_ALPHA12},
@code{GL_LUMINANCE16_ALPHA16}, @code{GL_R3_G3_B2}, @code{GL_RGB},
@code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8}, @code{GL_RGB10},
@code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA}, @code{GL_RGBA2},
@code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8}, @code{GL_RGB10_A2},
@code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{sink}
If @code{GL_TRUE}, pixels will be consumed by the minmax process and no
drawing or texture loading will take place.  If @code{GL_FALSE}, pixels
will proceed to the final conversion process after minmax.

@end table

When @code{GL_MINMAX} is enabled, the RGBA components of incoming pixels
are compared to the minimum and maximum values for each component, which
are stored in the two-element minmax table.  (The first element stores
the minima, and the second element stores the maxima.) If a pixel
component is greater than the corresponding component in the maximum
element, then the maximum element is updated with the pixel component
value.  If a pixel component is less than the corresponding component in
the minimum element, then the minimum element is updated with the pixel
component value.  (In both cases, if the internal format of the minmax
table includes luminance, then the R color component of incoming pixels
is used for comparison.) The contents of the minmax table may be
retrieved at a later time by calling @code{glGetMinmax}.  The minmax
operation is enabled or disabled by calling @code{glEnable} or
@code{glDisable}, respectively, with an argument of @code{GL_MINMAX}.

@code{glMinmax} redefines the current minmax table to have entries of
the format specified by @var{internalformat}.  The maximum element is
initialized with the smallest possible component values, and the minimum
element is initialized with the largest possible component values.  The
values in the previous minmax table, if any, are lost.  If @var{sink} is
@code{GL_TRUE}, then pixels are discarded after minmax; no further
processing of the pixels takes place, and no drawing, texture loading,
or pixel readback will result.



@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_INVALID_OPERATION} is generated if @code{glMinmax} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glMultiDrawArrays mode first count primcount
Render multiple sets of primitives from array data.

@table @asis
@item @var{mode}
Specifies what kind of primitives to render.  Symbolic constants
@code{GL_POINTS}, @code{GL_LINE_STRIP}, @code{GL_LINE_LOOP},
@code{GL_LINES}, @code{GL_TRIANGLE_STRIP}, @code{GL_TRIANGLE_FAN},
@code{GL_TRIANGLES}, @code{GL_QUAD_STRIP}, @code{GL_QUADS}, and
@code{GL_POLYGON} are accepted.

@item @var{first}
Points to an array of starting indices in the enabled arrays.

@item @var{count}
Points to an array of the number of indices to be rendered.

@item @var{primcount}
Specifies the size of the first and count

@end table

@code{glMultiDrawArrays} specifies multiple sets of geometric primitives
with very few subroutine calls.  Instead of calling a GL procedure to
pass each individual vertex, normal, texture coordinate, edge flag, or
color, you can prespecify separate arrays of vertices, normals, and
colors and use them to construct a sequence of primitives with a single
call to @code{glMultiDrawArrays}.

@code{glMultiDrawArrays} behaves identically to @code{glDrawArrays}
except that @var{primcount} separate ranges of elements are specified
instead.

When @code{glMultiDrawArrays} is called, it uses @var{count} sequential
elements from each enabled array to construct a sequence of geometric
primitives, beginning with element @var{first}.  @var{mode} specifies
what kind of primitives are constructed, and how the array elements
construct those primitives.  If @code{GL_VERTEX_ARRAY} is not enabled,
no geometric primitives are generated.

Vertex attributes that are modified by @code{glMultiDrawArrays} have an
unspecified value after @code{glMultiDrawArrays} returns.  For example,
if @code{GL_COLOR_ARRAY} is enabled, the value of the current color is
undefined after @code{glMultiDrawArrays} executes.  Attributes that
aren't modified remain well defined.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{primcount} is negative.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to an enabled array and the buffer object's data store is
currently mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glMultiDrawArrays} is
executed between the execution of @code{glBegin} and the corresponding
@code{glEnd}.

@end deftypefun

@deftypefun void glMultiDrawElements mode count type indices primcount
Render multiple sets of primitives by specifying indices of array data
elements.

@table @asis
@item @var{mode}
Specifies what kind of primitives to render.  Symbolic constants
@code{GL_POINTS}, @code{GL_LINE_STRIP}, @code{GL_LINE_LOOP},
@code{GL_LINES}, @code{GL_TRIANGLE_STRIP}, @code{GL_TRIANGLE_FAN},
@code{GL_TRIANGLES}, @code{GL_QUAD_STRIP}, @code{GL_QUADS}, and
@code{GL_POLYGON} are accepted.

@item @var{count}
Points to an array of the elements counts.

@item @var{type}
Specifies the type of the values in @var{indices}.  Must be one of
@code{GL_UNSIGNED_BYTE}, @code{GL_UNSIGNED_SHORT}, or
@code{GL_UNSIGNED_INT}.

@item @var{indices}
Specifies a pointer to the location where the indices are stored.

@item @var{primcount}
Specifies the size of the @var{count} array.

@end table

@code{glMultiDrawElements} specifies multiple sets of geometric
primitives with very few subroutine calls.  Instead of calling a GL
function to pass each individual vertex, normal, texture coordinate,
edge flag, or color, you can prespecify separate arrays of vertices,
normals, and so on, and use them to construct a sequence of primitives
with a single call to @code{glMultiDrawElements}.

@code{glMultiDrawElements} is identical in operation to
@code{glDrawElements} except that @var{primcount} separate lists of
elements are specified.

Vertex attributes that are modified by @code{glMultiDrawElements} have
an unspecified value after @code{glMultiDrawElements} returns.  For
example, if @code{GL_COLOR_ARRAY} is enabled, the value of the current
color is undefined after @code{glMultiDrawElements} executes.  Attributes
that aren't modified maintain their previous values.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{primcount} is negative.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to an enabled array or the element array and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if @code{glMultiDrawElements}
is executed between the execution of @code{glBegin} and the
corresponding @code{glEnd}.

@end deftypefun

@deftypefun void glMultiTexCoord1s target s
@deftypefunx void glMultiTexCoord1i target s
@deftypefunx void glMultiTexCoord1f target s
@deftypefunx void glMultiTexCoord1d target s
@deftypefunx void glMultiTexCoord2s target s t
@deftypefunx void glMultiTexCoord2i target s t
@deftypefunx void glMultiTexCoord2f target s t
@deftypefunx void glMultiTexCoord2d target s t
@deftypefunx void glMultiTexCoord3s target s t r
@deftypefunx void glMultiTexCoord3i target s t r
@deftypefunx void glMultiTexCoord3f target s t r
@deftypefunx void glMultiTexCoord3d target s t r
@deftypefunx void glMultiTexCoord4s target s t r q
@deftypefunx void glMultiTexCoord4i target s t r q
@deftypefunx void glMultiTexCoord4f target s t r q
@deftypefunx void glMultiTexCoord4d target s t r q
@deftypefunx void glMultiTexCoord1sv target v
@deftypefunx void glMultiTexCoord1iv target v
@deftypefunx void glMultiTexCoord1fv target v
@deftypefunx void glMultiTexCoord1dv target v
@deftypefunx void glMultiTexCoord2sv target v
@deftypefunx void glMultiTexCoord2iv target v
@deftypefunx void glMultiTexCoord2fv target v
@deftypefunx void glMultiTexCoord2dv target v
@deftypefunx void glMultiTexCoord3sv target v
@deftypefunx void glMultiTexCoord3iv target v
@deftypefunx void glMultiTexCoord3fv target v
@deftypefunx void glMultiTexCoord3dv target v
@deftypefunx void glMultiTexCoord4sv target v
@deftypefunx void glMultiTexCoord4iv target v
@deftypefunx void glMultiTexCoord4fv target v
@deftypefunx void glMultiTexCoord4dv target v
Set the current texture coordinates.

@table @asis
@item @var{target}
Specifies the texture unit whose coordinates should be modified.  The
number of texture units is implementation dependent, but must be at
least two.  Symbolic constant must be one of
@code{GL_TEXTURE}@r{@var{i}}, where i ranges from 0 to
@code{GL_MAX_TEXTURE_COORDS} - 1, which is an implementation-dependent
value.

@item @var{s}
@itemx @var{t}
@itemx @var{r}
@itemx @var{q}
Specify @var{s}, @var{t}, @var{r}, and @var{q} texture coordinates for
@var{target} texture unit.  Not all parameters are present in all forms
of the command.

@end table

@code{glMultiTexCoord} specifies texture coordinates in one, two, three,
or four dimensions.  @code{glMultiTexCoord1} sets the current texture
coordinates to @r{(@var{s},001)}; a call to @code{glMultiTexCoord2} sets
them to @r{(@var{s},@var{t}01)}.  Similarly, @code{glMultiTexCoord3}
specifies the texture coordinates as @r{(@var{s},@var{t}@var{r}1)}, and
@code{glMultiTexCoord4} defines all four components explicitly as
@r{(@var{s},@var{t}@var{r}@var{q})}.

The current texture coordinates are part of the data that is associated
with each vertex and with the current raster position.  Initially, the
values for @r{(@var{s},@var{t}@var{r}@var{q})} are @r{(0,001)}.



@end deftypefun

@deftypefun void glMultMatrixd m
@deftypefunx void glMultMatrixf m
Multiply the current matrix with the specified matrix.

@table @asis
@item @var{m}
Points to 16 consecutive values that are used as the elements of a
@r{4×4} column-major matrix.

@end table

@code{glMultMatrix} multiplies the current matrix with the one specified
using @var{m}, and replaces the current matrix with the product.

The current matrix is determined by the current matrix mode (see
@code{glMatrixMode}).  It is either the projection matrix, modelview
matrix, or the texture matrix.

@code{GL_INVALID_OPERATION} is generated if @code{glMultMatrix} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glMultTransposeMatrixd m
@deftypefunx void glMultTransposeMatrixf m
Multiply the current matrix with the specified row-major ordered matrix.

@table @asis
@item @var{m}
Points to 16 consecutive values that are used as the elements of a
@r{4×4} row-major matrix.

@end table

@code{glMultTransposeMatrix} multiplies the current matrix with the one
specified using @var{m}, and replaces the current matrix with the
product.

The current matrix is determined by the current matrix mode (see
@code{glMatrixMode}).  It is either the projection matrix, modelview
matrix, or the texture matrix.

@code{GL_INVALID_OPERATION} is generated if @code{glMultTransposeMatrix}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glNewList list mode
@deftypefunx void glEndList 
Create or replace a display list.

@table @asis
@item @var{list}
Specifies the display-list name.

@item @var{mode}
Specifies the compilation mode, which can be @code{GL_COMPILE} or
@code{GL_COMPILE_AND_EXECUTE}.

@end table

Display lists are groups of GL commands that have been stored for
subsequent execution.  Display lists are created with @code{glNewList}.
All subsequent commands are placed in the display list, in the order
issued, until @code{glEndList} is called.

@code{glNewList} has two arguments.  The first argument, @var{list}, is
a positive integer that becomes the unique name for the display list.
Names can be created and reserved with @code{glGenLists} and tested for
uniqueness with @code{glIsList}.  The second argument, @var{mode}, is a
symbolic constant that can assume one of two values:

@table @asis
@item @code{GL_COMPILE}
Commands are merely compiled.

@item @code{GL_COMPILE_AND_EXECUTE}
Commands are executed as they are compiled into the display list.

@end table

Certain commands are not compiled into the display list but are executed
immediately, regardless of the display-list mode.  These commands are
@code{glAreTexturesResident}, @code{glColorPointer},
@code{glDeleteLists}, @code{glDeleteTextures},
@code{glDisableClientState}, @code{glEdgeFlagPointer},
@code{glEnableClientState}, @code{glFeedbackBuffer}, @code{glFinish},
@code{glFlush}, @code{glGenLists}, @code{glGenTextures},
@code{glIndexPointer}, @code{glInterleavedArrays}, @code{glIsEnabled},
@code{glIsList}, @code{glIsTexture}, @code{glNormalPointer},
@code{glPopClientAttrib}, @code{glPixelStore},
@code{glPushClientAttrib}, @code{glReadPixels}, @code{glRenderMode},
@code{glSelectBuffer}, @code{glTexCoordPointer}, @code{glVertexPointer},
and all of the @code{glGet} commands.

Similarly, @code{glTexImage1D}, @code{glTexImage2D}, and
@code{glTexImage3D} are executed immediately and not compiled into the
display list when their first argument is @code{GL_PROXY_TEXTURE_1D},
@code{GL_PROXY_TEXTURE_1D}, or @code{GL_PROXY_TEXTURE_3D}, respectively.

When the @code{ARB_imaging} extension is supported, @code{glHistogram}
executes immediately when its argument is @code{GL_PROXY_HISTOGRAM}.
Similarly, @code{glColorTable} executes immediately when its first
argument is @code{GL_PROXY_COLOR_TABLE},
@code{GL_PROXY_POST_CONVOLUTION_COLOR_TABLE}, or
@code{GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE}.

For OpenGL versions 1.3 and greater, or when the @code{ARB_multitexture}
extension is supported, @code{glClientActiveTexture} is not compiled
into display lists, but executed immediately.

When @code{glEndList} is encountered, the display-list definition is
completed by associating the list with the unique name @var{list}
(specified in the @code{glNewList} command).  If a display list with
name @var{list} already exists, it is replaced only when
@code{glEndList} is called.

@code{GL_INVALID_VALUE} is generated if @var{list} is 0.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glEndList} is called
without a preceding @code{glNewList}, or if @code{glNewList} is called
while a display list is being defined.

@code{GL_INVALID_OPERATION} is generated if @code{glNewList} or
@code{glEndList} is executed between the execution of @code{glBegin} and
the corresponding execution of @code{glEnd}.

@code{GL_OUT_OF_MEMORY} is generated if there is insufficient memory to
compile the display list.  If the GL version is 1.1 or greater, no
change is made to the previous contents of the display list, if any, and
no other change is made to the GL state.  (It is as if no attempt had
been made to create the new display list.)

@end deftypefun

@deftypefun void glNormalPointer type stride pointer
Define an array of normals.

@table @asis
@item @var{type}
Specifies the data type of each coordinate in the array.  Symbolic
constants @code{GL_BYTE}, @code{GL_SHORT}, @code{GL_INT},
@code{GL_FLOAT}, and @code{GL_DOUBLE} are accepted.  The initial value
is @code{GL_FLOAT}.

@item @var{stride}
Specifies the byte offset between consecutive normals.  If @var{stride}
is 0, the normals are understood to be tightly packed in the array.  The
initial value is 0.

@item @var{pointer}
Specifies a pointer to the first coordinate of the first normal in the
array.  The initial value is 0.

@end table

@code{glNormalPointer} specifies the location and data format of an
array of normals to use when rendering.  @var{type} specifies the data
type of each normal coordinate, and @var{stride} specifies the byte
stride from one normal to the next, allowing vertices and attributes to
be packed into a single array or stored in separate arrays.
(Single-array storage may be more efficient on some implementations; see
@code{glInterleavedArrays}.)

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a normal array is specified,
@var{pointer} is treated as a byte offset into the buffer object's data
store.  Also, the buffer object binding (@code{GL_ARRAY_BUFFER_BINDING})
is saved as normal vertex array client-side state
(@code{GL_NORMAL_ARRAY_BUFFER_BINDING}).

When a normal array is specified, @var{type}, @var{stride}, and
@var{pointer} are saved as client-side state, in addition to the current
vertex array buffer object binding.

To enable and disable the normal array, call @code{glEnableClientState}
and @code{glDisableClientState} with the argument
@code{GL_NORMAL_ARRAY}.  If enabled, the normal array is used when
@code{glDrawArrays}, @code{glMultiDrawArrays}, @code{glDrawElements},
@code{glMultiDrawElements}, @code{glDrawRangeElements}, or
@code{glArrayElement} is called.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glNormal3b nx ny nz
@deftypefunx void glNormal3d nx ny nz
@deftypefunx void glNormal3f nx ny nz
@deftypefunx void glNormal3i nx ny nz
@deftypefunx void glNormal3s nx ny nz
@deftypefunx void glNormal3bv v
@deftypefunx void glNormal3dv v
@deftypefunx void glNormal3fv v
@deftypefunx void glNormal3iv v
@deftypefunx void glNormal3sv v
Set the current normal vector.

@table @asis
@item @var{nx}
@itemx @var{ny}
@itemx @var{nz}
Specify the @r{@var{x}}, @r{@var{y}}, and @r{@var{z}} coordinates of the
new current normal.  The initial value of the current normal is the unit
vector, (0, 0, 1).



@end table

The current normal is set to the given coordinates whenever
@code{glNormal} is issued.  Byte, short, or integer arguments are
converted to floating-point format with a linear mapping that maps the
most positive representable integer value to 1.0 and the most negative
representable integer value to @r{-1.0}.

Normals specified with @code{glNormal} need not have unit length.  If
@code{GL_NORMALIZE} is enabled, then normals of any length specified
with @code{glNormal} are normalized after transformation.  If
@code{GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling
factor derived from the modelview matrix.  @code{GL_RESCALE_NORMAL}
requires that the originally specified normals were of unit length, and
that the modelview matrix contain only uniform scales for proper
results.  To enable and disable normalization, call @code{glEnable} and
@code{glDisable} with either @code{GL_NORMALIZE} or
@code{GL_RESCALE_NORMAL}.  Normalization is initially disabled.

@end deftypefun

@deftypefun void glOrtho left right bottom top nearVal farVal
Multiply the current matrix with an orthographic matrix.

@table @asis
@item @var{left}
@itemx @var{right}
Specify the coordinates for the left and right vertical clipping planes.

@item @var{bottom}
@itemx @var{top}
Specify the coordinates for the bottom and top horizontal clipping
planes.

@item @var{nearVal}
@itemx @var{farVal}
Specify the distances to the nearer and farther depth clipping planes.
These values are negative if the plane is to be behind the viewer.

@end table

@code{glOrtho} describes a transformation that produces a parallel
projection.  The current matrix (see @code{glMatrixMode}) is multiplied
by this matrix and the result replaces the current matrix, as if
@code{glMultMatrix} were called with the following matrix as its
argument:

@r{((2/@var{right}-@var{left},, 0 0 @var{t}_@var{x},), (0
2/@var{top}-@var{bottom},, 0 @var{t}_@var{y},), (0 0
-2/@var{farVal}-@var{nearVal},, @var{t}_@var{z},), (0 0 0 1),)}

where
@r{@var{t}_@var{x}=-@var{right}+@var{left},/@var{right}-@var{left},,}@r{@var{t}_@var{y}=-@var{top}+@var{bottom},/@var{top}-@var{bottom},,}@r{@var{t}_@var{z}=-@var{farVal}+@var{nearVal},/@var{farVal}-@var{nearVal},,}

Typically, the matrix mode is @code{GL_PROJECTION}, and
@r{(@var{left},@var{bottom}-@var{nearVal})} and
@r{(@var{right},@var{top}-@var{nearVal})} specify the points on the near
clipping plane that are mapped to the lower left and upper right corners
of the window, respectively, assuming that the eye is located at (0, 0,
0).  @r{-@var{farVal}} specifies the location of the far clipping plane.
Both @var{nearVal} and @var{farVal} can be either positive or negative.

Use @code{glPushMatrix} and @code{glPopMatrix} to save and restore the
current matrix stack.

@code{GL_INVALID_VALUE} is generated if @var{left} = @var{right}, or
@var{bottom} = @var{top}, or @var{near} = @var{far}.

@code{GL_INVALID_OPERATION} is generated if @code{glOrtho} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glPassThrough token
Place a marker in the feedback buffer.

@table @asis
@item @var{token}
Specifies a marker value to be placed in the feedback buffer following a
@code{GL_PASS_THROUGH_TOKEN}.

@end table



Feedback is a GL render mode.  The mode is selected by calling
@code{glRenderMode} with @code{GL_FEEDBACK}.  When the GL is in feedback
mode, no pixels are produced by rasterization.  Instead, information
about primitives that would have been rasterized is fed back to the
application using the GL.  See the @code{glFeedbackBuffer} reference
page for a description of the feedback buffer and the values in it.

@code{glPassThrough} inserts a user-defined marker in the feedback
buffer when it is executed in feedback mode.  @var{token} is returned as
if it were a primitive; it is indicated with its own unique identifying
value: @code{GL_PASS_THROUGH_TOKEN}.  The order of @code{glPassThrough}
commands with respect to the specification of graphics primitives is
maintained.

@code{GL_INVALID_OPERATION} is generated if @code{glPassThrough} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPixelMapfv map mapsize values
@deftypefunx void glPixelMapuiv map mapsize values
@deftypefunx void glPixelMapusv map mapsize values
Set up pixel transfer maps.

@table @asis
@item @var{map}
Specifies a symbolic map name.  Must be one of the following:
@code{GL_PIXEL_MAP_I_TO_I}, @code{GL_PIXEL_MAP_S_TO_S},
@code{GL_PIXEL_MAP_I_TO_R}, @code{GL_PIXEL_MAP_I_TO_G},
@code{GL_PIXEL_MAP_I_TO_B}, @code{GL_PIXEL_MAP_I_TO_A},
@code{GL_PIXEL_MAP_R_TO_R}, @code{GL_PIXEL_MAP_G_TO_G},
@code{GL_PIXEL_MAP_B_TO_B}, or @code{GL_PIXEL_MAP_A_TO_A}.

@item @var{mapsize}
Specifies the size of the map being defined.

@item @var{values}
Specifies an array of @var{mapsize} values.

@end table

@code{glPixelMap} sets up translation tables, or @var{maps}, used by
@code{glCopyPixels}, @code{glCopyTexImage1D}, @code{glCopyTexImage2D},
@code{glCopyTexSubImage1D}, @code{glCopyTexSubImage2D},
@code{glCopyTexSubImage3D}, @code{glDrawPixels}, @code{glReadPixels},
@code{glTexImage1D}, @code{glTexImage2D}, @code{glTexImage3D},
@code{glTexSubImage1D}, @code{glTexSubImage2D}, and
@code{glTexSubImage3D}.  Additionally, if the @code{ARB_imaging} subset
is supported, the routines @code{glColorTable}, @code{glColorSubTable},
@code{glConvolutionFilter1D}, @code{glConvolutionFilter2D},
@code{glHistogram}, @code{glMinmax}, and @code{glSeparableFilter2D}.  Use
of these maps is described completely in the @code{glPixelTransfer}
reference page, and partly in the reference pages for the pixel and
texture image commands.  Only the specification of the maps is described
in this reference page.

@var{map} is a symbolic map name, indicating one of ten maps to set.
@var{mapsize} specifies the number of entries in the map, and
@var{values} is a pointer to an array of @var{mapsize} map values.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
pixel transfer map is specified, @var{values} is treated as a byte
offset into the buffer object's data store.

The ten maps are as follows:

@table @asis
@item @code{GL_PIXEL_MAP_I_TO_I}
Maps color indices to color indices.

@item @code{GL_PIXEL_MAP_S_TO_S}
Maps stencil indices to stencil indices.

@item @code{GL_PIXEL_MAP_I_TO_R}
Maps color indices to red components.

@item @code{GL_PIXEL_MAP_I_TO_G}
Maps color indices to green components.

@item @code{GL_PIXEL_MAP_I_TO_B}
Maps color indices to blue components.

@item @code{GL_PIXEL_MAP_I_TO_A}
Maps color indices to alpha components.

@item @code{GL_PIXEL_MAP_R_TO_R}
Maps red components to red components.

@item @code{GL_PIXEL_MAP_G_TO_G}
Maps green components to green components.

@item @code{GL_PIXEL_MAP_B_TO_B}
Maps blue components to blue components.

@item @code{GL_PIXEL_MAP_A_TO_A}
Maps alpha components to alpha components.

@end table

The entries in a map can be specified as single-precision floating-point
numbers, unsigned short integers, or unsigned int integers.  Maps that
store color component values (all but @code{GL_PIXEL_MAP_I_TO_I} and
@code{GL_PIXEL_MAP_S_TO_S}) retain their values in floating-point
format, with unspecified mantissa and exponent sizes.  Floating-point
values specified by @code{glPixelMapfv} are converted directly to the
internal floating-point format of these maps, then clamped to the range
[0,1].  Unsigned integer values specified by @code{glPixelMapusv} and
@code{glPixelMapuiv} are converted linearly such that the largest
representable integer maps to 1.0, and 0 maps to 0.0.

Maps that store indices, @code{GL_PIXEL_MAP_I_TO_I} and
@code{GL_PIXEL_MAP_S_TO_S}, retain their values in fixed-point format,
with an unspecified number of bits to the right of the binary point.
Floating-point values specified by @code{glPixelMapfv} are converted
directly to the internal fixed-point format of these maps.  Unsigned
integer values specified by @code{glPixelMapusv} and
@code{glPixelMapuiv} specify integer values, with all 0's to the right
of the binary point.

The following table shows the initial sizes and values for each of the
maps.  Maps that are indexed by either color or stencil indices must
have @var{mapsize} = @r{2^@var{n}} for some @r{@var{n}} or the results
are undefined.  The maximum allowable size for each map depends on the
implementation and can be determined by calling @code{glGet} with
argument @code{GL_MAX_PIXEL_MAP_TABLE}.  The single maximum applies to
all maps; it is at least 32.

@table @asis
@item @strong{@var{map}}
@strong{Lookup Index}, @strong{Lookup Value}, @strong{Initial Size},
@strong{Initial Value}

@item @code{GL_PIXEL_MAP_I_TO_I}
color index , color index , 1 , 0

@item @code{GL_PIXEL_MAP_S_TO_S}
stencil index , stencil index , 1 , 0

@item @code{GL_PIXEL_MAP_I_TO_R}
color index , R , 1 , 0

@item @code{GL_PIXEL_MAP_I_TO_G}
color index , G , 1 , 0

@item @code{GL_PIXEL_MAP_I_TO_B}
color index , B , 1 , 0

@item @code{GL_PIXEL_MAP_I_TO_A}
color index , A , 1 , 0

@item @code{GL_PIXEL_MAP_R_TO_R}
R , R , 1 , 0

@item @code{GL_PIXEL_MAP_G_TO_G}
G , G , 1 , 0

@item @code{GL_PIXEL_MAP_B_TO_B}
B , B , 1 , 0

@item @code{GL_PIXEL_MAP_A_TO_A}
A , A , 1 , 0

@end table

@code{GL_INVALID_ENUM} is generated if @var{map} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{mapsize} is less than one
or larger than @code{GL_MAX_PIXEL_MAP_TABLE}.

@code{GL_INVALID_VALUE} is generated if @var{map} is
@code{GL_PIXEL_MAP_I_TO_I}, @code{GL_PIXEL_MAP_S_TO_S},
@code{GL_PIXEL_MAP_I_TO_R}, @code{GL_PIXEL_MAP_I_TO_G},
@code{GL_PIXEL_MAP_I_TO_B}, or @code{GL_PIXEL_MAP_I_TO_A}, and
@var{mapsize} is not a power of two.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated by @code{glPixelMapfv} if a
non-zero buffer object name is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target and @var{values} is not evenly
divisible into the number of bytes needed to store in memory a GLfloat
datum.

@code{GL_INVALID_OPERATION} is generated by @code{glPixelMapuiv} if a
non-zero buffer object name is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target and @var{values} is not evenly
divisible into the number of bytes needed to store in memory a GLuint
datum.

@code{GL_INVALID_OPERATION} is generated by @code{glPixelMapusv} if a
non-zero buffer object name is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target and @var{values} is not evenly
divisible into the number of bytes needed to store in memory a GLushort
datum.

@code{GL_INVALID_OPERATION} is generated if @code{glPixelMap} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPixelStoref pname param
@deftypefunx void glPixelStorei pname param
Set pixel storage modes.

@table @asis
@item @var{pname}
Specifies the symbolic name of the parameter to be set.  Six values
affect the packing of pixel data into memory: @code{GL_PACK_SWAP_BYTES},
@code{GL_PACK_LSB_FIRST}, @code{GL_PACK_ROW_LENGTH},
@code{GL_PACK_IMAGE_HEIGHT}, @code{GL_PACK_SKIP_PIXELS},
@code{GL_PACK_SKIP_ROWS}, @code{GL_PACK_SKIP_IMAGES}, and
@code{GL_PACK_ALIGNMENT}.  Six more affect the unpacking of pixel data
@var{from} memory: @code{GL_UNPACK_SWAP_BYTES},
@code{GL_UNPACK_LSB_FIRST}, @code{GL_UNPACK_ROW_LENGTH},
@code{GL_UNPACK_IMAGE_HEIGHT}, @code{GL_UNPACK_SKIP_PIXELS},
@code{GL_UNPACK_SKIP_ROWS}, @code{GL_UNPACK_SKIP_IMAGES}, and
@code{GL_UNPACK_ALIGNMENT}.

@item @var{param}
Specifies the value that @var{pname} is set to.

@end table

@code{glPixelStore} sets pixel storage modes that affect the operation
of subsequent @code{glDrawPixels} and @code{glReadPixels} as well as the
unpacking of polygon stipple patterns (see @code{glPolygonStipple}),
bitmaps (see @code{glBitmap}), texture patterns (see
@code{glTexImage1D}, @code{glTexImage2D}, @code{glTexImage3D},
@code{glTexSubImage1D}, @code{glTexSubImage2D}, @code{glTexSubImage3D}).
Additionally, if the @code{ARB_imaging} extension is supported, pixel
storage modes affect convolution filters (see
@code{glConvolutionFilter1D}, @code{glConvolutionFilter2D}, and
@code{glSeparableFilter2D}, color table (see @code{glColorTable}, and
@code{glColorSubTable}, and unpacking histogram (See
@code{glHistogram}), and minmax (See @code{glMinmax}) data.

@var{pname} is a symbolic constant indicating the parameter to be set,
and @var{param} is the new value.  Six of the twelve storage parameters
affect how pixel data is returned to client memory.  They are as
follows:

@table @asis
@item @code{GL_PACK_SWAP_BYTES}
If true, byte ordering for multibyte color components, depth components,
color indices, or stencil indices is reversed.  That is, if a four-byte
component consists of bytes @r{@var{b}_0}, @r{@var{b}_1}, @r{@var{b}_2},
@r{@var{b}_3}, it is stored in memory as @r{@var{b}_3}, @r{@var{b}_2},
@r{@var{b}_1}, @r{@var{b}_0} if @code{GL_PACK_SWAP_BYTES} is true.
@code{GL_PACK_SWAP_BYTES} has no effect on the memory order of
components within a pixel, only on the order of bytes within components
or indices.  For example, the three components of a @code{GL_RGB} format
pixel are always stored with red first, green second, and blue third,
regardless of the value of @code{GL_PACK_SWAP_BYTES}.

@item @code{GL_PACK_LSB_FIRST}
If true, bits are ordered within a byte from least significant to most
significant; otherwise, the first bit in each byte is the most
significant one.  This parameter is significant for bitmap data only.

@item @code{GL_PACK_ROW_LENGTH}
If greater than 0, @code{GL_PACK_ROW_LENGTH} defines the number of
pixels in a row.  If the first pixel of a row is placed at location
@r{@var{p}} in memory, then the location of the first pixel of the next
row is obtained by skipping

@r{@var{k}=@{(@var{n}⁢@var{l}),
(@var{a}/@var{s},⁢⌈@var{s}⁢@var{n}⁢@var{l},/@var{a},⌉)⁢(@var{s}>=@var{a}),
(@var{s}<@var{a}),}

components or indices, where @r{@var{n}} is the number of components or
indices in a pixel, @r{@var{l}} is the number of pixels in a row
(@code{GL_PACK_ROW_LENGTH} if it is greater than 0, the @r{@var{width}}
argument to the pixel routine otherwise), @r{@var{a}} is the value of
@code{GL_PACK_ALIGNMENT}, and @r{@var{s}} is the size, in bytes, of a
single component (if @r{@var{a}<@var{s}}, then it is as if
@r{@var{a}=@var{s}}).  In the case of 1-bit values, the location of the
next row is obtained by skipping

@r{@var{k}=8⁢@var{a}⁢⌈@var{n}⁢@var{l},/8⁢@var{a},,⌉}

components or indices.

The word @var{component} in this description refers to the nonindex
values red, green, blue, alpha, and depth.  Storage format
@code{GL_RGB}, for example, has three components per pixel: first red,
then green, and finally blue.

@item @code{GL_PACK_IMAGE_HEIGHT}
If greater than 0, @code{GL_PACK_IMAGE_HEIGHT} defines the number of
pixels in an image three-dimensional texture volume, where ``image'' is
defined by all pixels sharing the same third dimension index.  If the
first pixel of a row is placed at location @r{@var{p}} in memory, then
the location of the first pixel of the next row is obtained by skipping

@r{@var{k}=@{(@var{n}⁢@var{l}⁢@var{h}),
(@var{a}/@var{s},⁢⌈@var{s}⁢@var{n}⁢@var{l}⁢@var{h},/@var{a},⌉)⁢(@var{s}>=@var{a}),
(@var{s}<@var{a}),}

components or indices, where @r{@var{n}} is the number of components or
indices in a pixel, @r{@var{l}} is the number of pixels in a row
(@code{GL_PACK_ROW_LENGTH} if it is greater than 0, the @r{@var{width}}
argument to @code{glTexImage3D} otherwise), @r{@var{h}} is the number of
rows in a pixel image (@code{GL_PACK_IMAGE_HEIGHT} if it is greater than
0, the @r{@var{height}} argument to the @code{glTexImage3D} routine
otherwise), @r{@var{a}} is the value of @code{GL_PACK_ALIGNMENT}, and
@r{@var{s}} is the size, in bytes, of a single component (if
@r{@var{a}<@var{s}}, then it is as if @r{@var{a}=@var{s}}).

The word @var{component} in this description refers to the nonindex
values red, green, blue, alpha, and depth.  Storage format
@code{GL_RGB}, for example, has three components per pixel: first red,
then green, and finally blue.

@item @code{GL_PACK_SKIP_PIXELS}, @code{GL_PACK_SKIP_ROWS}, and @code{GL_PACK_SKIP_IMAGES}
These values are provided as a convenience to the programmer; they
provide no functionality that cannot be duplicated simply by
incrementing the pointer passed to @code{glReadPixels}.  Setting
@code{GL_PACK_SKIP_PIXELS} to @r{@var{i}} is equivalent to incrementing
the pointer by @r{@var{i}⁢@var{n}} components or indices, where
@r{@var{n}} is the number of components or indices in each pixel.
Setting @code{GL_PACK_SKIP_ROWS} to @r{@var{j}} is equivalent to
incrementing the pointer by @r{@var{j}⁢@var{m}} components or indices,
where @r{@var{m}} is the number of components or indices per row, as
just computed in the @code{GL_PACK_ROW_LENGTH} section.  Setting
@code{GL_PACK_SKIP_IMAGES} to @r{@var{k}} is equivalent to incrementing
the pointer by @r{@var{k}⁢@var{p}}, where @r{@var{p}} is the number of
components or indices per image, as computed in the
@code{GL_PACK_IMAGE_HEIGHT} section.

@item @code{GL_PACK_ALIGNMENT}
Specifies the alignment requirements for the start of each pixel row in
memory.  The allowable values are 1 (byte-alignment), 2 (rows aligned to
even-numbered bytes), 4 (word-alignment), and 8 (rows start on
double-word boundaries).

@end table

The other six of the twelve storage parameters affect how pixel data is
read from client memory.  These values are significant for
@code{glDrawPixels}, @code{glTexImage1D}, @code{glTexImage2D},
@code{glTexImage3D}, @code{glTexSubImage1D}, @code{glTexSubImage2D},
@code{glTexSubImage3D}, @code{glBitmap}, and @code{glPolygonStipple}.

Additionally, if the @code{ARB_imaging} extension is supported,
@code{glColorTable}, @code{glColorSubTable},
@code{glConvolutionFilter1D}, @code{glConvolutionFilter2D}, and
@code{glSeparableFilter2D}.  They are as follows:

@table @asis
@item @code{GL_UNPACK_SWAP_BYTES}
If true, byte ordering for multibyte color components, depth components,
color indices, or stencil indices is reversed.  That is, if a four-byte
component consists of bytes @r{@var{b}_0}, @r{@var{b}_1}, @r{@var{b}_2},
@r{@var{b}_3}, it is taken from memory as @r{@var{b}_3}, @r{@var{b}_2},
@r{@var{b}_1}, @r{@var{b}_0} if @code{GL_UNPACK_SWAP_BYTES} is true.
@code{GL_UNPACK_SWAP_BYTES} has no effect on the memory order of
components within a pixel, only on the order of bytes within components
or indices.  For example, the three components of a @code{GL_RGB} format
pixel are always stored with red first, green second, and blue third,
regardless of the value of @code{GL_UNPACK_SWAP_BYTES}.

@item @code{GL_UNPACK_LSB_FIRST}
If true, bits are ordered within a byte from least significant to most
significant; otherwise, the first bit in each byte is the most
significant one.  This is relevant only for bitmap data.

@item @code{GL_UNPACK_ROW_LENGTH}
If greater than 0, @code{GL_UNPACK_ROW_LENGTH} defines the number of
pixels in a row.  If the first pixel of a row is placed at location
@r{@var{p}} in memory, then the location of the first pixel of the next
row is obtained by skipping

@r{@var{k}=@{(@var{n}⁢@var{l}),
(@var{a}/@var{s},⁢⌈@var{s}⁢@var{n}⁢@var{l},/@var{a},⌉)⁢(@var{s}>=@var{a}),
(@var{s}<@var{a}),}

components or indices, where @r{@var{n}} is the number of components or
indices in a pixel, @r{@var{l}} is the number of pixels in a row
(@code{GL_UNPACK_ROW_LENGTH} if it is greater than 0, the
@r{@var{width}} argument to the pixel routine otherwise), @r{@var{a}} is
the value of @code{GL_UNPACK_ALIGNMENT}, and @r{@var{s}} is the size, in
bytes, of a single component (if @r{@var{a}<@var{s}}, then it is as if
@r{@var{a}=@var{s}}).  In the case of 1-bit values, the location of the
next row is obtained by skipping

@r{@var{k}=8⁢@var{a}⁢⌈@var{n}⁢@var{l},/8⁢@var{a},,⌉}

components or indices.

The word @var{component} in this description refers to the nonindex
values red, green, blue, alpha, and depth.  Storage format
@code{GL_RGB}, for example, has three components per pixel: first red,
then green, and finally blue.

@item @code{GL_UNPACK_IMAGE_HEIGHT}
If greater than 0, @code{GL_UNPACK_IMAGE_HEIGHT} defines the number of
pixels in an image of a three-dimensional texture volume.  Where
``image'' is defined by all pixel sharing the same third dimension
index.  If the first pixel of a row is placed at location @r{@var{p}} in
memory, then the location of the first pixel of the next row is obtained
by skipping

@r{@var{k}=@{(@var{n}⁢@var{l}⁢@var{h}),
(@var{a}/@var{s},⁢⌈@var{s}⁢@var{n}⁢@var{l}⁢@var{h},/@var{a},⌉)⁢(@var{s}>=@var{a}),
(@var{s}<@var{a}),}

components or indices, where @r{@var{n}} is the number of components or
indices in a pixel, @r{@var{l}} is the number of pixels in a row
(@code{GL_UNPACK_ROW_LENGTH} if it is greater than 0, the
@r{@var{width}} argument to @code{glTexImage3D} otherwise), @r{@var{h}}
is the number of rows in an image (@code{GL_UNPACK_IMAGE_HEIGHT} if it
is greater than 0, the @r{@var{height}} argument to @code{glTexImage3D}
otherwise), @r{@var{a}} is the value of @code{GL_UNPACK_ALIGNMENT}, and
@r{@var{s}} is the size, in bytes, of a single component (if
@r{@var{a}<@var{s}}, then it is as if @r{@var{a}=@var{s}}).

The word @var{component} in this description refers to the nonindex
values red, green, blue, alpha, and depth.  Storage format
@code{GL_RGB}, for example, has three components per pixel: first red,
then green, and finally blue.

@item @code{GL_UNPACK_SKIP_PIXELS} and @code{GL_UNPACK_SKIP_ROWS}
These values are provided as a convenience to the programmer; they
provide no functionality that cannot be duplicated by incrementing the
pointer passed to @code{glDrawPixels}, @code{glTexImage1D},
@code{glTexImage2D}, @code{glTexSubImage1D}, @code{glTexSubImage2D},
@code{glBitmap}, or @code{glPolygonStipple}.  Setting
@code{GL_UNPACK_SKIP_PIXELS} to @r{@var{i}} is equivalent to
incrementing the pointer by @r{@var{i}⁢@var{n}} components or indices,
where @r{@var{n}} is the number of components or indices in each pixel.
Setting @code{GL_UNPACK_SKIP_ROWS} to @r{@var{j}} is equivalent to
incrementing the pointer by @r{@var{j}⁢@var{k}} components or indices,
where @r{@var{k}} is the number of components or indices per row, as
just computed in the @code{GL_UNPACK_ROW_LENGTH} section.

@item @code{GL_UNPACK_ALIGNMENT}
Specifies the alignment requirements for the start of each pixel row in
memory.  The allowable values are 1 (byte-alignment), 2 (rows aligned to
even-numbered bytes), 4 (word-alignment), and 8 (rows start on
double-word boundaries).

@end table

The following table gives the type, initial value, and range of valid
values for each storage parameter that can be set with
@code{glPixelStore}.



@table @asis
@item @strong{@var{pname}}
@strong{Type}, @strong{Initial Value}, @strong{Valid Range}

@item @code{GL_PACK_SWAP_BYTES}
boolean , false , true or false

@item @code{GL_PACK_LSB_FIRST}
boolean , false , true or false

@item @code{GL_PACK_ROW_LENGTH}
integer , 0 , @r{[0,∞)}

@item @code{GL_PACK_IMAGE_HEIGHT}
integer , 0 , @r{[0,∞)}

@item @code{GL_PACK_SKIP_ROWS}
integer , 0 , @r{[0,∞)}

@item @code{GL_PACK_SKIP_PIXELS}
integer , 0 , @r{[0,∞)}

@item @code{GL_PACK_SKIP_IMAGES}
integer , 0 , @r{[0,∞)}

@item @code{GL_PACK_ALIGNMENT}
integer , 4 , 1, 2, 4, or 8

@item @code{GL_UNPACK_SWAP_BYTES}
boolean , false , true or false

@item @code{GL_UNPACK_LSB_FIRST}
boolean , false , true or false

@item @code{GL_UNPACK_ROW_LENGTH}
integer , 0 , @r{[0,∞)}

@item @code{GL_UNPACK_IMAGE_HEIGHT}
integer , 0 , @r{[0,∞)}

@item @code{GL_UNPACK_SKIP_ROWS}
integer , 0 , @r{[0,∞)}

@item @code{GL_UNPACK_SKIP_PIXELS}
integer , 0 , @r{[0,∞)}

@item @code{GL_UNPACK_SKIP_IMAGES}
integer , 0 , @r{[0,∞)}

@item @code{GL_UNPACK_ALIGNMENT}
integer , 4 , 1, 2, 4, or 8

@end table

@code{glPixelStoref} can be used to set any pixel store parameter.  If
the parameter type is boolean, then if @var{param} is 0, the parameter
is false; otherwise it is set to true.  If @var{pname} is a integer type
parameter, @var{param} is rounded to the nearest integer.

Likewise, @code{glPixelStorei} can also be used to set any of the pixel
store parameters.  Boolean parameters are set to false if @var{param} is
0 and true otherwise.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if a negative row length, pixel
skip, or row skip value is specified, or if alignment is specified as
other than 1, 2, 4, or 8.

@code{GL_INVALID_OPERATION} is generated if @code{glPixelStore} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPixelTransferf pname param
@deftypefunx void glPixelTransferi pname param
Set pixel transfer modes.

@table @asis
@item @var{pname}
Specifies the symbolic name of the pixel transfer parameter to be set.
Must be one of the following: @code{GL_MAP_COLOR},
@code{GL_MAP_STENCIL}, @code{GL_INDEX_SHIFT}, @code{GL_INDEX_OFFSET},
@code{GL_RED_SCALE}, @code{GL_RED_BIAS}, @code{GL_GREEN_SCALE},
@code{GL_GREEN_BIAS}, @code{GL_BLUE_SCALE}, @code{GL_BLUE_BIAS},
@code{GL_ALPHA_SCALE}, @code{GL_ALPHA_BIAS}, @code{GL_DEPTH_SCALE}, or
@code{GL_DEPTH_BIAS}.

Additionally, if the @code{ARB_imaging} extension is supported, the
following symbolic names are accepted:
@code{GL_POST_COLOR_MATRIX_RED_SCALE},
@code{GL_POST_COLOR_MATRIX_GREEN_SCALE},
@code{GL_POST_COLOR_MATRIX_BLUE_SCALE},
@code{GL_POST_COLOR_MATRIX_ALPHA_SCALE},
@code{GL_POST_COLOR_MATRIX_RED_BIAS},
@code{GL_POST_COLOR_MATRIX_GREEN_BIAS},
@code{GL_POST_COLOR_MATRIX_BLUE_BIAS},
@code{GL_POST_COLOR_MATRIX_ALPHA_BIAS},
@code{GL_POST_CONVOLUTION_RED_SCALE},
@code{GL_POST_CONVOLUTION_GREEN_SCALE},
@code{GL_POST_CONVOLUTION_BLUE_SCALE},
@code{GL_POST_CONVOLUTION_ALPHA_SCALE},
@code{GL_POST_CONVOLUTION_RED_BIAS},
@code{GL_POST_CONVOLUTION_GREEN_BIAS},
@code{GL_POST_CONVOLUTION_BLUE_BIAS}, and
@code{GL_POST_CONVOLUTION_ALPHA_BIAS}.

@item @var{param}
Specifies the value that @var{pname} is set to.

@end table

@code{glPixelTransfer} sets pixel transfer modes that affect the
operation of subsequent @code{glCopyPixels}, @code{glCopyTexImage1D},
@code{glCopyTexImage2D}, @code{glCopyTexSubImage1D},
@code{glCopyTexSubImage2D}, @code{glCopyTexSubImage3D},
@code{glDrawPixels}, @code{glReadPixels}, @code{glTexImage1D},
@code{glTexImage2D}, @code{glTexImage3D}, @code{glTexSubImage1D},
@code{glTexSubImage2D}, and @code{glTexSubImage3D} commands.
Additionally, if the @code{ARB_imaging} subset is supported, the
routines @code{glColorTable}, @code{glColorSubTable},
@code{glConvolutionFilter1D}, @code{glConvolutionFilter2D},
@code{glHistogram}, @code{glMinmax}, and @code{glSeparableFilter2D} are
also affected.  The algorithms that are specified by pixel transfer
modes operate on pixels after they are read from the frame buffer
(@code{glCopyPixels}@code{glCopyTexImage1D}, @code{glCopyTexImage2D},
@code{glCopyTexSubImage1D}, @code{glCopyTexSubImage2D},
@code{glCopyTexSubImage3D}, and @code{glReadPixels}), or unpacked from
client memory (@code{glDrawPixels}, @code{glTexImage1D},
@code{glTexImage2D}, @code{glTexImage3D}, @code{glTexSubImage1D},
@code{glTexSubImage2D}, and @code{glTexSubImage3D}).  Pixel transfer
operations happen in the same order, and in the same manner, regardless
of the command that resulted in the pixel operation.  Pixel storage
modes (see @code{glPixelStore}) control the unpacking of pixels being
read from client memory and the packing of pixels being written back
into client memory.

Pixel transfer operations handle four fundamental pixel types:
@var{color}, @var{color index}, @var{depth}, and @var{stencil}.
@var{Color} pixels consist of four floating-point values with
unspecified mantissa and exponent sizes, scaled such that 0 represents
zero intensity and 1 represents full intensity.  @var{Color indices}
comprise a single fixed-point value, with unspecified precision to the
right of the binary point.  @var{Depth} pixels comprise a single
floating-point value, with unspecified mantissa and exponent sizes,
scaled such that 0.0 represents the minimum depth buffer value, and 1.0
represents the maximum depth buffer value.  Finally, @var{stencil}
pixels comprise a single fixed-point value, with unspecified precision
to the right of the binary point.

The pixel transfer operations performed on the four basic pixel types
are as follows:

@table @asis
@item @var{Color}
Each of the four color components is multiplied by a scale factor, then
added to a bias factor.  That is, the red component is multiplied by
@code{GL_RED_SCALE}, then added to @code{GL_RED_BIAS}; the green
component is multiplied by @code{GL_GREEN_SCALE}, then added to
@code{GL_GREEN_BIAS}; the blue component is multiplied by
@code{GL_BLUE_SCALE}, then added to @code{GL_BLUE_BIAS}; and the alpha
component is multiplied by @code{GL_ALPHA_SCALE}, then added to
@code{GL_ALPHA_BIAS}.  After all four color components are scaled and
biased, each is clamped to the range @r{[0,1]}.  All color, scale, and
bias values are specified with @code{glPixelTransfer}.

If @code{GL_MAP_COLOR} is true, each color component is scaled by the
size of the corresponding color-to-color map, then replaced by the
contents of that map indexed by the scaled component.  That is, the red
component is scaled by @code{GL_PIXEL_MAP_R_TO_R_SIZE}, then replaced by
the contents of @code{GL_PIXEL_MAP_R_TO_R} indexed by itself.  The green
component is scaled by @code{GL_PIXEL_MAP_G_TO_G_SIZE}, then replaced by
the contents of @code{GL_PIXEL_MAP_G_TO_G} indexed by itself.  The blue
component is scaled by @code{GL_PIXEL_MAP_B_TO_B_SIZE}, then replaced by
the contents of @code{GL_PIXEL_MAP_B_TO_B} indexed by itself.  And the
alpha component is scaled by @code{GL_PIXEL_MAP_A_TO_A_SIZE}, then
replaced by the contents of @code{GL_PIXEL_MAP_A_TO_A} indexed by
itself.  All components taken from the maps are then clamped to the
range @r{[0,1]}.  @code{GL_MAP_COLOR} is specified with
@code{glPixelTransfer}.  The contents of the various maps are specified
with @code{glPixelMap}.

If the @code{ARB_imaging} extension is supported, each of the four color
components may be scaled and biased after transformation by the color
matrix.  That is, the red component is multiplied by
@code{GL_POST_COLOR_MATRIX_RED_SCALE}, then added to
@code{GL_POST_COLOR_MATRIX_RED_BIAS}; the green component is multiplied
by @code{GL_POST_COLOR_MATRIX_GREEN_SCALE}, then added to
@code{GL_POST_COLOR_MATRIX_GREEN_BIAS}; the blue component is multiplied
by @code{GL_POST_COLOR_MATRIX_BLUE_SCALE}, then added to
@code{GL_POST_COLOR_MATRIX_BLUE_BIAS}; and the alpha component is
multiplied by @code{GL_POST_COLOR_MATRIX_ALPHA_SCALE}, then added to
@code{GL_POST_COLOR_MATRIX_ALPHA_BIAS}.  After all four color components
are scaled and biased, each is clamped to the range @r{[0,1]}.

Similarly, if the @code{ARB_imaging} extension is supported, each of the
four color components may be scaled and biased after processing by the
enabled convolution filter.  That is, the red component is multiplied by
@code{GL_POST_CONVOLUTION_RED_SCALE}, then added to
@code{GL_POST_CONVOLUTION_RED_BIAS}; the green component is multiplied
by @code{GL_POST_CONVOLUTION_GREEN_SCALE}, then added to
@code{GL_POST_CONVOLUTION_GREEN_BIAS}; the blue component is multiplied
by @code{GL_POST_CONVOLUTION_BLUE_SCALE}, then added to
@code{GL_POST_CONVOLUTION_BLUE_BIAS}; and the alpha component is
multiplied by @code{GL_POST_CONVOLUTION_ALPHA_SCALE}, then added to
@code{GL_POST_CONVOLUTION_ALPHA_BIAS}.  After all four color components
are scaled and biased, each is clamped to the range @r{[0,1]}.

@item @var{Color index}
Each color index is shifted left by @code{GL_INDEX_SHIFT} bits; any bits
beyond the number of fraction bits carried by the fixed-point index are
filled with zeros.  If @code{GL_INDEX_SHIFT} is negative, the shift is
to the right, again zero filled.  Then @code{GL_INDEX_OFFSET} is added
to the index.  @code{GL_INDEX_SHIFT} and @code{GL_INDEX_OFFSET} are
specified with @code{glPixelTransfer}.

From this point, operation diverges depending on the required format of
the resulting pixels.  If the resulting pixels are to be written to a
color index buffer, or if they are being read back to client memory in
@code{GL_COLOR_INDEX} format, the pixels continue to be treated as
indices.  If @code{GL_MAP_COLOR} is true, each index is masked by
@r{2^@var{n}-1}, where @r{@var{n}} is @code{GL_PIXEL_MAP_I_TO_I_SIZE},
then replaced by the contents of @code{GL_PIXEL_MAP_I_TO_I} indexed by
the masked value.  @code{GL_MAP_COLOR} is specified with
@code{glPixelTransfer}.  The contents of the index map is specified with
@code{glPixelMap}.

If the resulting pixels are to be written to an RGBA color buffer, or if
they are read back to client memory in a format other than
@code{GL_COLOR_INDEX}, the pixels are converted from indices to colors
by referencing the four maps @code{GL_PIXEL_MAP_I_TO_R},
@code{GL_PIXEL_MAP_I_TO_G}, @code{GL_PIXEL_MAP_I_TO_B}, and
@code{GL_PIXEL_MAP_I_TO_A}.  Before being dereferenced, the index is
masked by @r{2^@var{n}-1}, where @r{@var{n}} is
@code{GL_PIXEL_MAP_I_TO_R_SIZE} for the red map,
@code{GL_PIXEL_MAP_I_TO_G_SIZE} for the green map,
@code{GL_PIXEL_MAP_I_TO_B_SIZE} for the blue map, and
@code{GL_PIXEL_MAP_I_TO_A_SIZE} for the alpha map.  All components taken
from the maps are then clamped to the range @r{[0,1]}.  The contents of
the four maps is specified with @code{glPixelMap}.

@item @var{Depth}
Each depth value is multiplied by @code{GL_DEPTH_SCALE}, added to
@code{GL_DEPTH_BIAS}, then clamped to the range @r{[0,1]}.

@item @var{Stencil}
Each index is shifted @code{GL_INDEX_SHIFT} bits just as a color index
is, then added to @code{GL_INDEX_OFFSET}.  If @code{GL_MAP_STENCIL} is
true, each index is masked by @r{2^@var{n}-1}, where @r{@var{n}} is
@code{GL_PIXEL_MAP_S_TO_S_SIZE}, then replaced by the contents of
@code{GL_PIXEL_MAP_S_TO_S} indexed by the masked value.

@end table

The following table gives the type, initial value, and range of valid
values for each of the pixel transfer parameters that are set with
@code{glPixelTransfer}.



@table @asis
@item @strong{@var{pname}}
@strong{Type}, @strong{Initial Value}, @strong{Valid Range}

@item @code{GL_MAP_COLOR}
boolean , false , true/false

@item @code{GL_MAP_STENCIL}
boolean , false , true/false

@item @code{GL_INDEX_SHIFT}
integer , 0 , @r{(-∞,∞)}

@item @code{GL_INDEX_OFFSET}
integer , 0 , @r{(-∞,∞)}

@item @code{GL_RED_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_GREEN_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_BLUE_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_ALPHA_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_DEPTH_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_RED_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_GREEN_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_BLUE_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_ALPHA_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_DEPTH_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_RED_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_GREEN_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_BLUE_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_ALPHA_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_RED_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_GREEN_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_BLUE_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_COLOR_MATRIX_ALPHA_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_RED_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_GREEN_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_BLUE_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_ALPHA_SCALE}
float , 1 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_RED_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_GREEN_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_BLUE_BIAS}
float , 0 , @r{(-∞,∞)}

@item @code{GL_POST_CONVOLUTION_ALPHA_BIAS}
float , 0 , @r{(-∞,∞)}

@end table

@code{glPixelTransferf} can be used to set any pixel transfer parameter.
If the parameter type is boolean, 0 implies false and any other value
implies true.  If @var{pname} is an integer parameter, @var{param} is
rounded to the nearest integer.

Likewise, @code{glPixelTransferi} can be used to set any of the pixel
transfer parameters.  Boolean parameters are set to false if @var{param}
is 0 and to true otherwise.  @var{param} is converted to floating point
before being assigned to real-valued parameters.

@code{GL_INVALID_ENUM} is generated if @var{pname} is not an accepted
value.

@code{GL_INVALID_OPERATION} is generated if @code{glPixelTransfer} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPixelZoom xfactor yfactor
Specify the pixel zoom factors.

@table @asis
@item @var{xfactor}
@itemx @var{yfactor}
Specify the @r{@var{x}} and @r{@var{y}} zoom factors for pixel write
operations.

@end table

@code{glPixelZoom} specifies values for the @r{@var{x}} and @r{@var{y}}
zoom factors.  During the execution of @code{glDrawPixels} or
@code{glCopyPixels}, if (@r{@var{xr}}, @r{@var{yr}}) is the current
raster position, and a given element is in the @r{@var{m}}th row and
@r{@var{n}}th column of the pixel rectangle, then pixels whose centers
are in the rectangle with corners at

(@r{@var{xr}+@var{n}·@var{xfactor}}, @r{@var{yr}+@var{m}·@var{yfactor}})

(@r{@var{xr}+(@var{n}+1,)·@var{xfactor}},
@r{@var{yr}+(@var{m}+1,)·@var{yfactor}})

are candidates for replacement.  Any pixel whose center lies on the
bottom or left edge of this rectangular region is also modified.

Pixel zoom factors are not limited to positive values.  Negative zoom
factors reflect the resulting image about the current raster position.

@code{GL_INVALID_OPERATION} is generated if @code{glPixelZoom} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPointParameterf pname param
@deftypefunx void glPointParameteri pname param
@deftypefunx void glPointParameterfv pname params
@deftypefunx void glPointParameteriv pname params
Specify point parameters.

@table @asis
@item @var{pname}
Specifies a single-valued point parameter.  @code{GL_POINT_SIZE_MIN},
@code{GL_POINT_SIZE_MAX}, @code{GL_POINT_FADE_THRESHOLD_SIZE}, and
@code{GL_POINT_SPRITE_COORD_ORIGIN} are accepted.

@item @var{param}
Specifies the value that @var{pname} will be set to.

@end table

The following values are accepted for @var{pname}:

@table @asis
@item @code{GL_POINT_SIZE_MIN}


@var{params} is a single floating-point value that specifies the minimum
point size.  The default value is 0.0.

@item @code{GL_POINT_SIZE_MAX}


@var{params} is a single floating-point value that specifies the maximum
point size.  The default value is 1.0.

@item @code{GL_POINT_FADE_THRESHOLD_SIZE}


@var{params} is a single floating-point value that specifies the
threshold value to which point sizes are clamped if they exceed the
specified value.  The default value is 1.0.

@item @code{GL_POINT_DISTANCE_ATTENUATION}


@var{params} is an array of three floating-point values that specify the
coefficients used for scaling the computed point size.  The default
values are @r{(1,00)}.

@item @code{GL_POINT_SPRITE_COORD_ORIGIN}


@var{params} is a single enum specifying the point sprite texture
coordinate origin, either @code{GL_LOWER_LEFT} or @code{GL_UPPER_LEFT}.
The default value is @code{GL_UPPER_LEFT}.

@end table

@code{GL_INVALID_VALUE} is generated If the value specified for
@code{GL_POINT_SIZE_MIN}, @code{GL_POINT_SIZE_MAX}, or
@code{GL_POINT_FADE_THRESHOLD_SIZE} is less than zero.

@code{GL_INVALID_ENUM} is generated If the value specified for
@code{GL_POINT_SPRITE_COORD_ORIGIN} is not @code{GL_LOWER_LEFT} or
@code{GL_UPPER_LEFT}.

If the value for @code{GL_POINT_SIZE_MIN} is greater than
@code{GL_POINT_SIZE_MAX}, the point size after clamping is undefined,
but no error is generated.



@end deftypefun

@deftypefun void glPointSize size
Specify the diameter of rasterized points.

@table @asis
@item @var{size}
Specifies the diameter of rasterized points.  The initial value is 1.

@end table

@code{glPointSize} specifies the rasterized diameter of both aliased and
antialiased points.  Using a point size other than 1 has different
effects, depending on whether point antialiasing is enabled.  To enable
and disable point antialiasing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_POINT_SMOOTH}.  Point
antialiasing is initially disabled.

The specified point size is multiplied with a distance attenuation
factor and clamped to the specified point size range, and further
clamped to the implementation-dependent point size range to produce the
derived point size using

@r{@var{pointSize}=@var{clamp}⁢(@var{size}×√(1/@var{a}+@var{b}×@var{d}+@var{c}×@var{d}^2,,,),,)}

where @r{@var{d}} is the eye-coordinate distance from the eye to the
vertex, and @r{@var{a}}, @r{@var{b}}, and @r{@var{c}} are the distance
attenuation coefficients (see @code{glPointParameter}).

If multisampling is disabled, the computed point size is used as the
point's width.

If multisampling is enabled, the point may be faded by modifying the
point alpha value (see @code{glSampleCoverage}) instead of allowing the
point width to go below a given threshold (see @code{glPointParameter}).
In this case, the width is further modified in the following manner:

@r{@var{pointWidth}=@{(@var{pointSize}),
(@var{threshold})⁢(@var{pointSize}>=@var{threshold}),
(@var{otherwise}),}

The point alpha value is modified by computing:

@r{@var{pointAlpha}=@{(1),
((@var{pointSize}/@var{threshold},)^2)⁢(@var{pointSize}>=@var{threshold}),
(@var{otherwise}),}

If point antialiasing is disabled, the actual size is determined by
rounding the supplied size to the nearest integer.  (If the rounding
results in the value 0, it is as if the point size were 1.) If the
rounded size is odd, then the center point (@r{@var{x}}, @r{@var{y}}) of
the pixel fragment that represents the point is computed as

@r{(⌊@var{x}_@var{w},⌋+.5,⌊@var{y}_@var{w},⌋+.5)}

where @r{@var{w}} subscripts indicate window coordinates.  All pixels
that lie within the square grid of the rounded size centered at
(@r{@var{x}}, @r{@var{y}}) make up the fragment.  If the size is even,
the center point is

@r{(⌊@var{x}_@var{w}+.5,⌋,⌊@var{y}_@var{w}+.5,⌋)}

and the rasterized fragment's centers are the half-integer window
coordinates within the square of the rounded size centered at
@r{(@var{x},@var{y})}.  All pixel fragments produced in rasterizing a
nonantialiased point are assigned the same associated data, that of the
vertex corresponding to the point.

If antialiasing is enabled, then point rasterization produces a fragment
for each pixel square that intersects the region lying within the circle
having diameter equal to the current point size and centered at the
point's @r{(@var{x}_@var{w},@var{y}_@var{w})}.  The coverage value for
each fragment is the window coordinate area of the intersection of the
circular region with the corresponding pixel square.  This value is
saved and used in the final rasterization step.  The data associated
with each fragment is the data associated with the point being
rasterized.

Not all sizes are supported when point antialiasing is enabled.  If an
unsupported size is requested, the nearest supported size is used.  Only
size 1 is guaranteed to be supported; others depend on the
implementation.  To query the range of supported sizes and the size
difference between supported sizes within the range, call @code{glGet}
with arguments @code{GL_SMOOTH_POINT_SIZE_RANGE} and
@code{GL_SMOOTH_POINT_SIZE_GRANULARITY}.  For aliased points, query the
supported ranges and granularity with @code{glGet} with arguments
@code{GL_ALIASED_POINT_SIZE_RANGE}.

@code{GL_INVALID_VALUE} is generated if @var{size} is less than or equal
to 0.

@code{GL_INVALID_OPERATION} is generated if @code{glPointSize} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPolygonMode face mode
Select a polygon rasterization mode.

@table @asis
@item @var{face}
Specifies the polygons that @var{mode} applies to.  Must be
@code{GL_FRONT} for front-facing polygons, @code{GL_BACK} for
back-facing polygons, or @code{GL_FRONT_AND_BACK} for front- and
back-facing polygons.

@item @var{mode}
Specifies how polygons will be rasterized.  Accepted values are
@code{GL_POINT}, @code{GL_LINE}, and @code{GL_FILL}.  The initial value
is @code{GL_FILL} for both front- and back-facing polygons.

@end table

@code{glPolygonMode} controls the interpretation of polygons for
rasterization.  @var{face} describes which polygons @var{mode} applies
to: front-facing polygons (@code{GL_FRONT}), back-facing polygons
(@code{GL_BACK}), or both (@code{GL_FRONT_AND_BACK}).  The polygon mode
affects only the final rasterization of polygons.  In particular, a
polygon's vertices are lit and the polygon is clipped and possibly
culled before these modes are applied.

Three modes are defined and can be specified in @var{mode}:

@table @asis
@item @code{GL_POINT}
Polygon vertices that are marked as the start of a boundary edge are
drawn as points.  Point attributes such as @code{GL_POINT_SIZE} and
@code{GL_POINT_SMOOTH} control the rasterization of the points.  Polygon
rasterization attributes other than @code{GL_POLYGON_MODE} have no
effect.

@item @code{GL_LINE}
Boundary edges of the polygon are drawn as line segments.  They are
treated as connected line segments for line stippling; the line stipple
counter and pattern are not reset between segments (see
@code{glLineStipple}).  Line attributes such as @code{GL_LINE_WIDTH} and
@code{GL_LINE_SMOOTH} control the rasterization of the lines.  Polygon
rasterization attributes other than @code{GL_POLYGON_MODE} have no
effect.

@item @code{GL_FILL}
The interior of the polygon is filled.  Polygon attributes such as
@code{GL_POLYGON_STIPPLE} and @code{GL_POLYGON_SMOOTH} control the
rasterization of the polygon.

@end table

@code{GL_INVALID_ENUM} is generated if either @var{face} or @var{mode}
is not an accepted value.

@code{GL_INVALID_OPERATION} is generated if @code{glPolygonMode} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPolygonOffset factor units
Set the scale and units used to calculate depth values.

@table @asis
@item @var{factor}
Specifies a scale factor that is used to create a variable depth offset
for each polygon.  The initial value is 0.

@item @var{units}
Is multiplied by an implementation-specific value to create a constant
depth offset.  The initial value is 0.

@end table

When @code{GL_POLYGON_OFFSET_FILL}, @code{GL_POLYGON_OFFSET_LINE}, or
@code{GL_POLYGON_OFFSET_POINT} is enabled, each fragment's @var{depth}
value will be offset after it is interpolated from the @var{depth}
values of the appropriate vertices.  The value of the offset is
@r{@var{factor}×@var{DZ}+@var{r}×@var{units}}, where @r{@var{DZ}} is a
measurement of the change in depth relative to the screen area of the
polygon, and @r{@var{r}} is the smallest value that is guaranteed to
produce a resolvable offset for a given implementation.  The offset is
added before the depth test is performed and before the value is written
into the depth buffer.

@code{glPolygonOffset} is useful for rendering hidden-line images, for
applying decals to surfaces, and for rendering solids with highlighted
edges.

@code{GL_INVALID_OPERATION} is generated if @code{glPolygonOffset} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPolygonStipple pattern
Set the polygon stippling pattern.

@table @asis
@item @var{pattern}
Specifies a pointer to a @r{32×32} stipple pattern that will be unpacked
from memory in the same way that @code{glDrawPixels} unpacks pixels.

@end table

Polygon stippling, like line stippling (see @code{glLineStipple}), masks
out certain fragments produced by rasterization, creating a pattern.
Stippling is independent of polygon antialiasing.

@var{pattern} is a pointer to a @r{32×32} stipple pattern that is stored
in memory just like the pixel data supplied to a @code{glDrawPixels}
call with height and @var{width} both equal to 32, a pixel format of
@code{GL_COLOR_INDEX}, and data type of @code{GL_BITMAP}.  That is, the
stipple pattern is represented as a @r{32×32} array of 1-bit color
indices packed in unsigned bytes.  @code{glPixelStore} parameters like
@code{GL_UNPACK_SWAP_BYTES} and @code{GL_UNPACK_LSB_FIRST} affect the
assembling of the bits into a stipple pattern.  Pixel transfer
operations (shift, offset, pixel map) are not applied to the stipple
image, however.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
stipple pattern is specified, @var{pattern} is treated as a byte offset
into the buffer object's data store.

To enable and disable polygon stippling, call @code{glEnable} and
@code{glDisable} with argument @code{GL_POLYGON_STIPPLE}.  Polygon
stippling is initially disabled.  If it's enabled, a rasterized polygon
fragment with window coordinates @r{@var{x}_@var{w}} and
@r{@var{y}_@var{w}} is sent to the next stage of the GL if and only if
the (@r{@var{x}_@var{w}%32})th bit in the (@r{@var{y}_@var{w}%32})th row
of the stipple pattern is 1 (one).  When polygon stippling is disabled,
it is as if the stipple pattern consists of all 1's.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if @code{glPolygonStipple} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPrioritizeTextures n textures priorities
Set texture residence priority.

@table @asis
@item @var{n}
Specifies the number of textures to be prioritized.

@item @var{textures}
Specifies an array containing the names of the textures to be
prioritized.

@item @var{priorities}
Specifies an array containing the texture priorities.  A priority given
in an element of @var{priorities} applies to the texture named by the
corresponding element of @var{textures}.

@end table

@code{glPrioritizeTextures} assigns the @var{n} texture priorities given
in @var{priorities} to the @var{n} textures named in @var{textures}.

The GL establishes a ``working set'' of textures that are resident in
texture memory.  These textures may be bound to a texture target much
more efficiently than textures that are not resident.  By specifying a
priority for each texture, @code{glPrioritizeTextures} allows
applications to guide the GL implementation in determining which
textures should be resident.

The priorities given in @var{priorities} are clamped to the range
@r{[0,1]} before they are assigned.  0 indicates the lowest priority;
textures with priority 0 are least likely to be resident.  1 indicates
the highest priority; textures with priority 1 are most likely to be
resident.  However, textures are not guaranteed to be resident until
they are used.

@code{glPrioritizeTextures} silently ignores attempts to prioritize
texture 0 or any texture name that does not correspond to an existing
texture.

@code{glPrioritizeTextures} does not require that any of the textures
named by @var{textures} be bound to a texture target.
@code{glTexParameter} may also be used to set a texture's priority, but
only if the texture is currently bound.  This is the only way to set the
priority of a default texture.

@code{GL_INVALID_VALUE} is generated if @var{n} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glPrioritizeTextures}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPushAttrib mask
@deftypefunx void glPopAttrib 
Push and pop the server attribute stack.

@table @asis
@item @var{mask}
Specifies a mask that indicates which attributes to save.  Values for
@var{mask} are listed below.

@end table

@code{glPushAttrib} takes one argument, a mask that indicates which
groups of state variables to save on the attribute stack.  Symbolic
constants are used to set bits in the mask.  @var{mask} is typically
constructed by specifying the bitwise-or of several of these constants
together.  The special mask @code{GL_ALL_ATTRIB_BITS} can be used to
save all stackable states.

The symbolic mask constants and their associated GL state are as follows
(the second column lists which attributes are saved):



@table @asis
@item @code{GL_ACCUM_BUFFER_BIT}
Accumulation buffer clear value

@item @code{GL_COLOR_BUFFER_BIT}
@code{GL_ALPHA_TEST} enable bit

@item .
Alpha test function and reference value

@item .
@code{GL_BLEND} enable bit

@item .
Blending source and destination functions

@item .
Constant blend color

@item .
Blending equation

@item .
@code{GL_DITHER} enable bit

@item .
@code{GL_DRAW_BUFFER} setting

@item .
@code{GL_COLOR_LOGIC_OP} enable bit

@item .
@code{GL_INDEX_LOGIC_OP} enable bit

@item .
Logic op function

@item .
Color mode and index mode clear values

@item .
Color mode and index mode writemasks

@item @code{GL_CURRENT_BIT}
Current RGBA color

@item .
Current color index

@item .
Current normal vector

@item .
Current texture coordinates

@item .
Current raster position

@item .
@code{GL_CURRENT_RASTER_POSITION_VALID} flag

@item .
RGBA color associated with current raster position

@item .
Color index associated with current raster position

@item .
Texture coordinates associated with current raster position

@item .
@code{GL_EDGE_FLAG} flag

@item @code{GL_DEPTH_BUFFER_BIT}
@code{GL_DEPTH_TEST} enable bit

@item .
Depth buffer test function

@item .
Depth buffer clear value

@item .
@code{GL_DEPTH_WRITEMASK} enable bit

@item @code{GL_ENABLE_BIT}
@code{GL_ALPHA_TEST} flag

@item .
@code{GL_AUTO_NORMAL} flag

@item .
@code{GL_BLEND} flag

@item .
Enable bits for the user-definable clipping planes

@item .
@code{GL_COLOR_MATERIAL}

@item .
@code{GL_CULL_FACE} flag

@item .
@code{GL_DEPTH_TEST} flag

@item .
@code{GL_DITHER} flag

@item .
@code{GL_FOG} flag

@item .
@code{GL_LIGHT}@var{i} where @code{0} <= @var{i} < @code{GL_MAX_LIGHTS}

@item .
@code{GL_LIGHTING} flag

@item .
@code{GL_LINE_SMOOTH} flag

@item .
@code{GL_LINE_STIPPLE} flag

@item .
@code{GL_COLOR_LOGIC_OP} flag

@item .
@code{GL_INDEX_LOGIC_OP} flag

@item .
@code{GL_MAP1_}@var{x} where @var{x} is a map type

@item .
@code{GL_MAP2_}@var{x} where @var{x} is a map type

@item .
@code{GL_MULTISAMPLE} flag

@item .
@code{GL_NORMALIZE} flag

@item .
@code{GL_POINT_SMOOTH} flag

@item .
@code{GL_POLYGON_OFFSET_LINE} flag

@item .
@code{GL_POLYGON_OFFSET_FILL} flag

@item .
@code{GL_POLYGON_OFFSET_POINT} flag

@item .
@code{GL_POLYGON_SMOOTH} flag

@item .
@code{GL_POLYGON_STIPPLE} flag

@item .
@code{GL_SAMPLE_ALPHA_TO_COVERAGE} flag

@item .
@code{GL_SAMPLE_ALPHA_TO_ONE} flag

@item .
@code{GL_SAMPLE_COVERAGE} flag

@item .
@code{GL_SCISSOR_TEST} flag

@item .
@code{GL_STENCIL_TEST} flag

@item .
@code{GL_TEXTURE_1D} flag

@item .
@code{GL_TEXTURE_2D} flag

@item .
@code{GL_TEXTURE_3D} flag

@item .
Flags @code{GL_TEXTURE_GEN_}@var{x} where @var{x} is S, T, R, or Q

@item @code{GL_EVAL_BIT}
@code{GL_MAP1_}@var{x} enable bits, where @var{x} is a map type

@item .
@code{GL_MAP2_}@var{x} enable bits, where @var{x} is a map type

@item .
1D grid endpoints and divisions

@item .
2D grid endpoints and divisions

@item .
@code{GL_AUTO_NORMAL} enable bit

@item @code{GL_FOG_BIT}
@code{GL_FOG} enable bit

@item .
Fog color

@item .
Fog density

@item .
Linear fog start

@item .
Linear fog end

@item .
Fog index

@item .
@code{GL_FOG_MODE} value

@item @code{GL_HINT_BIT}
@code{GL_PERSPECTIVE_CORRECTION_HINT} setting

@item .
@code{GL_POINT_SMOOTH_HINT} setting

@item .
@code{GL_LINE_SMOOTH_HINT} setting

@item .
@code{GL_POLYGON_SMOOTH_HINT} setting

@item .
@code{GL_FOG_HINT} setting

@item .
@code{GL_GENERATE_MIPMAP_HINT} setting

@item .
@code{GL_TEXTURE_COMPRESSION_HINT} setting

@item @code{GL_LIGHTING_BIT}
@code{GL_COLOR_MATERIAL} enable bit

@item .
@code{GL_COLOR_MATERIAL_FACE} value

@item .
Color material parameters that are tracking the current color

@item .
Ambient scene color

@item .
@code{GL_LIGHT_MODEL_LOCAL_VIEWER} value

@item .
@code{GL_LIGHT_MODEL_TWO_SIDE} setting

@item .
@code{GL_LIGHTING} enable bit

@item .
Enable bit for each light

@item .
Ambient, diffuse, and specular intensity for each light

@item .
Direction, position, exponent, and cutoff angle for each light

@item .
Constant, linear, and quadratic attenuation factors for each light

@item .
Ambient, diffuse, specular, and emissive color for each material

@item .
Ambient, diffuse, and specular color indices for each material

@item .
Specular exponent for each material

@item .
@code{GL_SHADE_MODEL} setting

@item @code{GL_LINE_BIT}
@code{GL_LINE_SMOOTH} flag

@item .
@code{GL_LINE_STIPPLE} enable bit

@item .
Line stipple pattern and repeat counter

@item .
Line width

@item @code{GL_LIST_BIT}
@code{GL_LIST_BASE} setting

@item @code{GL_MULTISAMPLE_BIT}
@code{GL_MULTISAMPLE} flag

@item .
@code{GL_SAMPLE_ALPHA_TO_COVERAGE} flag

@item .
@code{GL_SAMPLE_ALPHA_TO_ONE} flag

@item .
@code{GL_SAMPLE_COVERAGE} flag

@item .
@code{GL_SAMPLE_COVERAGE_VALUE} value

@item .
@code{GL_SAMPLE_COVERAGE_INVERT} value

@item @code{GL_PIXEL_MODE_BIT}
@code{GL_RED_BIAS} and @code{GL_RED_SCALE} settings

@item .
@code{GL_GREEN_BIAS} and @code{GL_GREEN_SCALE} values

@item .
@code{GL_BLUE_BIAS} and @code{GL_BLUE_SCALE}

@item .
@code{GL_ALPHA_BIAS} and @code{GL_ALPHA_SCALE}

@item .
@code{GL_DEPTH_BIAS} and @code{GL_DEPTH_SCALE}

@item .
@code{GL_INDEX_OFFSET} and @code{GL_INDEX_SHIFT} values

@item .
@code{GL_MAP_COLOR} and @code{GL_MAP_STENCIL} flags

@item .
@code{GL_ZOOM_X} and @code{GL_ZOOM_Y} factors

@item .
@code{GL_READ_BUFFER} setting

@item @code{GL_POINT_BIT}
@code{GL_POINT_SMOOTH} flag

@item .
Point size

@item @code{GL_POLYGON_BIT}
@code{GL_CULL_FACE} enable bit

@item .
@code{GL_CULL_FACE_MODE} value

@item .
@code{GL_FRONT_FACE} indicator

@item .
@code{GL_POLYGON_MODE} setting

@item .
@code{GL_POLYGON_SMOOTH} flag

@item .
@code{GL_POLYGON_STIPPLE} enable bit

@item .
@code{GL_POLYGON_OFFSET_FILL} flag

@item .
@code{GL_POLYGON_OFFSET_LINE} flag

@item .
@code{GL_POLYGON_OFFSET_POINT} flag

@item .
@code{GL_POLYGON_OFFSET_FACTOR}

@item .
@code{GL_POLYGON_OFFSET_UNITS}

@item @code{GL_POLYGON_STIPPLE_BIT}
Polygon stipple image

@item @code{GL_SCISSOR_BIT}
@code{GL_SCISSOR_TEST} flag

@item .
Scissor box

@item @code{GL_STENCIL_BUFFER_BIT}
@code{GL_STENCIL_TEST} enable bit

@item .
Stencil function and reference value

@item .
Stencil value mask

@item .
Stencil fail, pass, and depth buffer pass actions

@item .
Stencil buffer clear value

@item .
Stencil buffer writemask

@item @code{GL_TEXTURE_BIT}
Enable bits for the four texture coordinates

@item .
Border color for each texture image

@item .
Minification function for each texture image

@item .
Magnification function for each texture image

@item .
Texture coordinates and wrap mode for each texture image

@item .
Color and mode for each texture environment

@item .
Enable bits @code{GL_TEXTURE_GEN_}@var{x}, @var{x} is S, T, R, and Q

@item .
@code{GL_TEXTURE_GEN_MODE} setting for S, T, R, and Q

@item .
@code{glTexGen} plane equations for S, T, R, and Q

@item .
Current texture bindings (for example, @code{GL_TEXTURE_BINDING_2D})

@item @code{GL_TRANSFORM_BIT}
Coefficients of the six clipping planes

@item .
Enable bits for the user-definable clipping planes

@item .
@code{GL_MATRIX_MODE} value

@item .
@code{GL_NORMALIZE} flag

@item .
@code{GL_RESCALE_NORMAL} flag

@item @code{GL_VIEWPORT_BIT}
Depth range (near and far)

@item .
Viewport origin and extent

@end table

@code{glPopAttrib} restores the values of the state variables saved with
the last @code{glPushAttrib} command.  Those not saved are left
unchanged.

It is an error to push attributes onto a full stack or to pop attributes
off an empty stack.  In either case, the error flag is set and no other
change is made to GL state.

Initially, the attribute stack is empty.

@code{GL_STACK_OVERFLOW} is generated if @code{glPushAttrib} is called
while the attribute stack is full.

@code{GL_STACK_UNDERFLOW} is generated if @code{glPopAttrib} is called
while the attribute stack is empty.

@code{GL_INVALID_OPERATION} is generated if @code{glPushAttrib} or
@code{glPopAttrib} is executed between the execution of @code{glBegin}
and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPushClientAttrib mask
@deftypefunx void glPopClientAttrib 
Push and pop the client attribute stack.

@table @asis
@item @var{mask}
Specifies a mask that indicates which attributes to save.  Values for
@var{mask} are listed below.

@end table

@code{glPushClientAttrib} takes one argument, a mask that indicates
which groups of client-state variables to save on the client attribute
stack.  Symbolic constants are used to set bits in the mask.  @var{mask}
is typically constructed by specifying the bitwise-or of several of
these constants together.  The special mask
@code{GL_CLIENT_ALL_ATTRIB_BITS} can be used to save all stackable
client state.

The symbolic mask constants and their associated GL client state are as
follows (the second column lists which attributes are saved):

@code{GL_CLIENT_PIXEL_STORE_BIT} Pixel storage modes
@code{GL_CLIENT_VERTEX_ARRAY_BIT} Vertex arrays (and enables)

@code{glPopClientAttrib} restores the values of the client-state
variables saved with the last @code{glPushClientAttrib}.  Those not
saved are left unchanged.

It is an error to push attributes onto a full client attribute stack or
to pop attributes off an empty stack.  In either case, the error flag is
set, and no other change is made to GL state.

Initially, the client attribute stack is empty.

@code{GL_STACK_OVERFLOW} is generated if @code{glPushClientAttrib} is
called while the attribute stack is full.

@code{GL_STACK_UNDERFLOW} is generated if @code{glPopClientAttrib} is
called while the attribute stack is empty.

@end deftypefun

@deftypefun void glPushMatrix 
@deftypefunx void glPopMatrix 
Push and pop the current matrix stack.

There is a stack of matrices for each of the matrix modes.  In
@code{GL_MODELVIEW} mode, the stack depth is at least 32.  In the other
modes, @code{GL_COLOR}, @code{GL_PROJECTION}, and @code{GL_TEXTURE}, the
depth is at least 2.  The current matrix in any mode is the matrix on
the top of the stack for that mode.

@code{glPushMatrix} pushes the current matrix stack down by one,
duplicating the current matrix.  That is, after a @code{glPushMatrix}
call, the matrix on top of the stack is identical to the one below it.

@code{glPopMatrix} pops the current matrix stack, replacing the current
matrix with the one below it on the stack.

Initially, each of the stacks contains one matrix, an identity matrix.

It is an error to push a full matrix stack or to pop a matrix stack that
contains only a single matrix.  In either case, the error flag is set
and no other change is made to GL state.

@code{GL_STACK_OVERFLOW} is generated if @code{glPushMatrix} is called
while the current matrix stack is full.

@code{GL_STACK_UNDERFLOW} is generated if @code{glPopMatrix} is called
while the current matrix stack contains only a single matrix.

@code{GL_INVALID_OPERATION} is generated if @code{glPushMatrix} or
@code{glPopMatrix} is executed between the execution of @code{glBegin}
and the corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glPushName name
@deftypefunx void glPopName 
Push and pop the name stack.

@table @asis
@item @var{name}
Specifies a name that will be pushed onto the name stack.

@end table

The name stack is used during selection mode to allow sets of rendering
commands to be uniquely identified.  It consists of an ordered set of
unsigned integers and is initially empty.

@code{glPushName} causes @var{name} to be pushed onto the name stack.
@code{glPopName} pops one name off the top of the stack.

The maximum name stack depth is implementation-dependent; call
@code{GL_MAX_NAME_STACK_DEPTH} to find out the value for a particular
implementation.  It is an error to push a name onto a full stack or to
pop a name off an empty stack.  It is also an error to manipulate the
name stack between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.  In any of these cases, the error flag is set
and no other change is made to GL state.

The name stack is always empty while the render mode is not
@code{GL_SELECT}.  Calls to @code{glPushName} or @code{glPopName} while
the render mode is not @code{GL_SELECT} are ignored.

@code{GL_STACK_OVERFLOW} is generated if @code{glPushName} is called
while the name stack is full.

@code{GL_STACK_UNDERFLOW} is generated if @code{glPopName} is called
while the name stack is empty.

@code{GL_INVALID_OPERATION} is generated if @code{glPushName} or
@code{glPopName} is executed between a call to @code{glBegin} and the
corresponding call to @code{glEnd}.

@end deftypefun

@deftypefun void glRasterPos2s x y
@deftypefunx void glRasterPos2i x y
@deftypefunx void glRasterPos2f x y
@deftypefunx void glRasterPos2d x y
@deftypefunx void glRasterPos3s x y z
@deftypefunx void glRasterPos3i x y z
@deftypefunx void glRasterPos3f x y z
@deftypefunx void glRasterPos3d x y z
@deftypefunx void glRasterPos4s x y z w
@deftypefunx void glRasterPos4i x y z w
@deftypefunx void glRasterPos4f x y z w
@deftypefunx void glRasterPos4d x y z w
@deftypefunx void glRasterPos2sv v
@deftypefunx void glRasterPos2iv v
@deftypefunx void glRasterPos2fv v
@deftypefunx void glRasterPos2dv v
@deftypefunx void glRasterPos3sv v
@deftypefunx void glRasterPos3iv v
@deftypefunx void glRasterPos3fv v
@deftypefunx void glRasterPos3dv v
@deftypefunx void glRasterPos4sv v
@deftypefunx void glRasterPos4iv v
@deftypefunx void glRasterPos4fv v
@deftypefunx void glRasterPos4dv v
Specify the raster position for pixel operations.

@table @asis
@item @var{x}
@itemx @var{y}
@itemx @var{z}
@itemx @var{w}
Specify the @r{@var{x}}, @r{@var{y}}, @r{@var{z}}, and @r{@var{w}}
object coordinates (if present) for the raster position.

@end table

The GL maintains a 3D position in window coordinates.  This position,
called the raster position, is used to position pixel and bitmap write
operations.  It is maintained with subpixel accuracy.  See
@code{glBitmap}, @code{glDrawPixels}, and @code{glCopyPixels}.

The current raster position consists of three window coordinates
(@r{@var{x}}, @r{@var{y}}, @r{@var{z}}), a clip coordinate value
(@r{@var{w}}), an eye coordinate distance, a valid bit, and associated
color data and texture coordinates.  The @r{@var{w}} coordinate is a
clip coordinate, because @r{@var{w}} is not projected to window
coordinates.  @code{glRasterPos4} specifies object coordinates
@r{@var{x}}, @r{@var{y}}, @r{@var{z}}, and @r{@var{w}} explicitly.
@code{glRasterPos3} specifies object coordinate @r{@var{x}},
@r{@var{y}}, and @r{@var{z}} explicitly, while @r{@var{w}} is implicitly
set to 1.  @code{glRasterPos2} uses the argument values for @r{@var{x}}
and @r{@var{y}} while implicitly setting @r{@var{z}} and @r{@var{w}} to
0 and 1.

The object coordinates presented by @code{glRasterPos} are treated just
like those of a @code{glVertex} command: They are transformed by the
current modelview and projection matrices and passed to the clipping
stage.  If the vertex is not culled, then it is projected and scaled to
window coordinates, which become the new current raster position, and
the @code{GL_CURRENT_RASTER_POSITION_VALID} flag is set.  If the vertex
@var{is} culled, then the valid bit is cleared and the current raster
position and associated color and texture coordinates are undefined.

The current raster position also includes some associated color data and
texture coordinates.  If lighting is enabled, then
@code{GL_CURRENT_RASTER_COLOR} (in RGBA mode) or
@code{GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color
produced by the lighting calculation (see @code{glLight},
@code{glLightModel}, and @code{glShadeModel}).  If lighting is disabled,
current color (in RGBA mode, state variable @code{GL_CURRENT_COLOR}) or
color index (in color index mode, state variable
@code{GL_CURRENT_INDEX}) is used to update the current raster color.
@code{GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise
updated.

Likewise, @code{GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a
function of @code{GL_CURRENT_TEXTURE_COORDS}, based on the texture
matrix and the texture generation functions (see @code{glTexGen}).
Finally, the distance from the origin of the eye coordinate system to
the vertex as transformed by only the modelview matrix replaces
@code{GL_CURRENT_RASTER_DISTANCE}.

Initially, the current raster position is (0, 0, 0, 1), the current
raster distance is 0, the valid bit is set, the associated RGBA color is
(1, 1, 1, 1), the associated color index is 1, and the associated
texture coordinates are (0, 0, 0, 1).  In RGBA mode,
@code{GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the
current raster RGBA color always maintains its initial value.

@code{GL_INVALID_OPERATION} is generated if @code{glRasterPos} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glReadBuffer mode
Select a color buffer source for pixels.

@table @asis
@item @var{mode}
Specifies a color buffer.  Accepted values are @code{GL_FRONT_LEFT},
@code{GL_FRONT_RIGHT}, @code{GL_BACK_LEFT}, @code{GL_BACK_RIGHT},
@code{GL_FRONT}, @code{GL_BACK}, @code{GL_LEFT}, @code{GL_RIGHT}, and
@code{GL_AUX}@var{i}, where @var{i} is between 0 and the value of
@code{GL_AUX_BUFFERS} minus 1.

@end table

@code{glReadBuffer} specifies a color buffer as the source for
subsequent @code{glReadPixels}, @code{glCopyTexImage1D},
@code{glCopyTexImage2D}, @code{glCopyTexSubImage1D},
@code{glCopyTexSubImage2D}, @code{glCopyTexSubImage3D}, and
@code{glCopyPixels} commands.  @var{mode} accepts one of twelve or more
predefined values.  (@code{GL_AUX0} through @code{GL_AUX3} are always
defined.) In a fully configured system, @code{GL_FRONT}, @code{GL_LEFT},
and @code{GL_FRONT_LEFT} all name the front left buffer,
@code{GL_FRONT_RIGHT} and @code{GL_RIGHT} name the front right buffer,
and @code{GL_BACK_LEFT} and @code{GL_BACK} name the back left buffer.

Nonstereo double-buffered configurations have only a front left and a
back left buffer.  Single-buffered configurations have a front left and
a front right buffer if stereo, and only a front left buffer if
nonstereo.  It is an error to specify a nonexistent buffer to
@code{glReadBuffer}.

@var{mode} is initially @code{GL_FRONT} in single-buffered
configurations and @code{GL_BACK} in double-buffered configurations.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not one of the
twelve (or more) accepted values.

@code{GL_INVALID_OPERATION} is generated if @var{mode} specifies a
buffer that does not exist.

@code{GL_INVALID_OPERATION} is generated if @code{glReadBuffer} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glReadPixels x y width height format type data
Read a block of pixels from the frame buffer.

@table @asis
@item @var{x}
@itemx @var{y}
Specify the window coordinates of the first pixel that is read from the
frame buffer.  This location is the lower left corner of a rectangular
block of pixels.

@item @var{width}
@itemx @var{height}
Specify the dimensions of the pixel rectangle.  @var{width} and
@var{height} of one correspond to a single pixel.

@item @var{format}
Specifies the format of the pixel data.  The following symbolic values
are accepted: @code{GL_COLOR_INDEX}, @code{GL_STENCIL_INDEX},
@code{GL_DEPTH_COMPONENT}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR},
@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies the data type of the pixel data.  Must be one of
@code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
or @code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Returns the pixel data.

@end table

@code{glReadPixels} returns pixel data from the frame buffer, starting
with the pixel whose lower left corner is at location (@var{x},
@var{y}), into client memory starting at location @var{data}.  Several
parameters control the processing of the pixel data before it is placed
into client memory.  These parameters are set with three commands:
@code{glPixelStore}, @code{glPixelTransfer}, and @code{glPixelMap}.  This
reference page describes the effects on @code{glReadPixels} of most, but
not all of the parameters specified by these three commands.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_PACK_BUFFER} target (see @code{glBindBuffer}) while a
block of pixels is requested, @var{data} is treated as a byte offset
into the buffer object's data store rather than a pointer to client
memory.

When the @code{ARB_imaging} extension is supported, the pixel data may
be processed by additional operations including color table lookup,
color matrix transformations, convolutions, histograms, and minimum and
maximum pixel value computations.

@code{glReadPixels} returns values from each pixel with lower left
corner at @r{(@var{x}+@var{i},@var{y}+@var{j})} for
@r{0<=@var{i}<@var{width}} and @r{0<=@var{j}<@var{height}}.  This pixel
is said to be the @r{@var{i}}th pixel in the @r{@var{j}}th row.  Pixels
are returned in row order from the lowest to the highest row, left to
right in each row.

@var{format} specifies the format for the returned pixel values;
accepted values are:

@table @asis
@item @code{GL_COLOR_INDEX}
Color indices are read from the color buffer selected by
@code{glReadBuffer}.  Each index is converted to fixed point, shifted
left or right depending on the value and sign of @code{GL_INDEX_SHIFT},
and added to @code{GL_INDEX_OFFSET}.  If @code{GL_MAP_COLOR} is
@code{GL_TRUE}, indices are replaced by their mappings in the table
@code{GL_PIXEL_MAP_I_TO_I}.

@item @code{GL_STENCIL_INDEX}
Stencil values are read from the stencil buffer.  Each index is
converted to fixed point, shifted left or right depending on the value
and sign of @code{GL_INDEX_SHIFT}, and added to @code{GL_INDEX_OFFSET}.
If @code{GL_MAP_STENCIL} is @code{GL_TRUE}, indices are replaced by
their mappings in the table @code{GL_PIXEL_MAP_S_TO_S}.

@item @code{GL_DEPTH_COMPONENT}
Depth values are read from the depth buffer.  Each component is
converted to floating point such that the minimum depth value maps to 0
and the maximum value maps to 1.  Each component is then multiplied by
@code{GL_DEPTH_SCALE}, added to @code{GL_DEPTH_BIAS}, and finally
clamped to the range @r{[0,1]}.

@item @code{GL_RED}
@item @code{GL_GREEN}
@item @code{GL_BLUE}
@item @code{GL_ALPHA}
@item @code{GL_RGB}
@item @code{GL_BGR}
@item @code{GL_RGBA}
@item @code{GL_BGRA}
@item @code{GL_LUMINANCE}
@item @code{GL_LUMINANCE_ALPHA}
Processing differs depending on whether color buffers store color
indices or RGBA color components.  If color indices are stored, they are
read from the color buffer selected by @code{glReadBuffer}.  Each index
is converted to fixed point, shifted left or right depending on the
value and sign of @code{GL_INDEX_SHIFT}, and added to
@code{GL_INDEX_OFFSET}.  Indices are then replaced by the red, green,
blue, and alpha values obtained by indexing the tables
@code{GL_PIXEL_MAP_I_TO_R}, @code{GL_PIXEL_MAP_I_TO_G},
@code{GL_PIXEL_MAP_I_TO_B}, and @code{GL_PIXEL_MAP_I_TO_A}.  Each table
must be of size @r{2^@var{n}}, but @r{@var{n}} may be different for
different tables.  Before an index is used to look up a value in a table
of size @r{2^@var{n}}, it must be masked against @r{2^@var{n}-1}.

If RGBA color components are stored in the color buffers, they are read
from the color buffer selected by @code{glReadBuffer}.  Each color
component is converted to floating point such that zero intensity maps
to 0.0 and full intensity maps to 1.0.  Each component is then
multiplied by @code{GL_c_SCALE} and added to @code{GL_c_BIAS}, where
@var{c} is RED, GREEN, BLUE, or ALPHA.  Finally, if @code{GL_MAP_COLOR}
is @code{GL_TRUE}, each component is clamped to the range @r{[0,1]},
scaled to the size of its corresponding table, and is then replaced by
its mapping in the table @code{GL_PIXEL_MAP_c_TO_c}, where @var{c} is R,
G, B, or A.

Unneeded data is then discarded.  For example, @code{GL_RED} discards
the green, blue, and alpha components, while @code{GL_RGB} discards only
the alpha component.  @code{GL_LUMINANCE} computes a single-component
value as the sum of the red, green, and blue components, and
@code{GL_LUMINANCE_ALPHA} does the same, while keeping alpha as a second
value.  The final values are clamped to the range @r{[0,1]}.

@end table

The shift, scale, bias, and lookup factors just described are all
specified by @code{glPixelTransfer}.  The lookup table contents
themselves are specified by @code{glPixelMap}.

Finally, the indices or components are converted to the proper format,
as specified by @var{type}.  If @var{format} is @code{GL_COLOR_INDEX} or
@code{GL_STENCIL_INDEX} and @var{type} is not @code{GL_FLOAT}, each
index is masked with the mask value given in the following table.  If
@var{type} is @code{GL_FLOAT}, then each integer index is converted to
single-precision floating-point format.

If @var{format} is @code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE},
@code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR}, @code{GL_RGBA},
@code{GL_BGRA}, @code{GL_LUMINANCE}, or @code{GL_LUMINANCE_ALPHA} and
@var{type} is not @code{GL_FLOAT}, each component is multiplied by the
multiplier shown in the following table.  If type is @code{GL_FLOAT},
then each component is passed as is (or converted to the client's
single-precision floating-point format if it is different from the one
used by the GL).



@table @asis
@item @var{type}
@strong{Index Mask}, @strong{Component Conversion}

@item @code{GL_UNSIGNED_BYTE}
@r{2^8-1}, @r{(2^8-1,)⁢@var{c}}

@item @code{GL_BYTE}
@r{2^7-1}, @r{(2^8-1,)⁢@var{c}-1,/2}

@item @code{GL_BITMAP}
@r{1}, @r{1}

@item @code{GL_UNSIGNED_SHORT}
@r{2^16-1}, @r{(2^16-1,)⁢@var{c}}

@item @code{GL_SHORT}
@r{2^15-1}, @r{(2^16-1,)⁢@var{c}-1,/2}

@item @code{GL_UNSIGNED_INT}
@r{2^32-1}, @r{(2^32-1,)⁢@var{c}}

@item @code{GL_INT}
@r{2^31-1}, @r{(2^32-1,)⁢@var{c}-1,/2}

@item @code{GL_FLOAT}
none , @r{@var{c}}

@end table

Return values are placed in memory as follows.  If @var{format} is
@code{GL_COLOR_INDEX}, @code{GL_STENCIL_INDEX},
@code{GL_DEPTH_COMPONENT}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, or @code{GL_LUMINANCE}, a single value
is returned and the data for the @r{@var{i}}th pixel in the
@r{@var{j}}th row is placed in location
@r{(@var{j},)⁢@var{width}+@var{i}}.  @code{GL_RGB} and @code{GL_BGR}
return three values, @code{GL_RGBA} and @code{GL_BGRA} return four
values, and @code{GL_LUMINANCE_ALPHA} returns two values for each pixel,
with all values corresponding to a single pixel occupying contiguous
space in @var{data}.  Storage parameters set by @code{glPixelStore},
such as @code{GL_PACK_LSB_FIRST} and @code{GL_PACK_SWAP_BYTES}, affect
the way that data is written into memory.  See @code{glPixelStore} for a
description.

@code{GL_INVALID_ENUM} is generated if @var{format} or @var{type} is not
an accepted value.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not @code{GL_COLOR_INDEX} or
@code{GL_STENCIL_INDEX}.

@code{GL_INVALID_VALUE} is generated if either @var{width} or
@var{height} is negative.

@code{GL_INVALID_OPERATION} is generated if @var{format} is
@code{GL_COLOR_INDEX} and the color buffers store RGBA color components.

@code{GL_INVALID_OPERATION} is generated if @var{format} is
@code{GL_STENCIL_INDEX} and there is no stencil buffer.

@code{GL_INVALID_OPERATION} is generated if @var{format} is
@code{GL_DEPTH_COMPONENT} and there is no depth buffer.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

The formats @code{GL_BGR}, and @code{GL_BGRA} and types
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV} are available only if the GL
version is 1.2 or greater.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and the data
would be packed to the buffer object such that the memory writes
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_PACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glReadPixels} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glRectd x1 y1 x2 y2
@deftypefunx void glRectf x1 y1 x2 y2
@deftypefunx void glRecti x1 y1 x2 y2
@deftypefunx void glRects x1 y1 x2 y2
@deftypefunx void glRectdv v1 v2
@deftypefunx void glRectfv v1 v2
@deftypefunx void glRectiv v1 v2
@deftypefunx void glRectsv v1 v2
Draw a rectangle.

@table @asis
@item @var{x1}
@itemx @var{y1}
Specify one vertex of a rectangle.

@item @var{x2}
@itemx @var{y2}
Specify the opposite vertex of the rectangle.

@end table

@code{glRect} supports efficient specification of rectangles as two
corner points.  Each rectangle command takes four arguments, organized
either as two consecutive pairs of @r{(@var{x},@var{y})} coordinates or
as two pointers to arrays, each containing an @r{(@var{x},@var{y})}
pair.  The resulting rectangle is defined in the @r{@var{z}=0} plane.

@code{glRect}(@var{x1}, @var{y1}, @var{x2}, @var{y2}) is exactly
equivalent to the following sequence: Note that if the second vertex is
above and to the right of the first vertex, the rectangle is constructed
with a counterclockwise winding.

@example 

glBegin(@code{GL_POLYGON});
glVertex2(@var{x1}, @var{y1});
glVertex2(@var{x2}, @var{y1});
glVertex2(@var{x2}, @var{y2});
glVertex2(@var{x1}, @var{y2});
glEnd(); 
@end example

@code{GL_INVALID_OPERATION} is generated if @code{glRect} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun GLint glRenderMode mode
Set rasterization mode.

@table @asis
@item @var{mode}
Specifies the rasterization mode.  Three values are accepted:
@code{GL_RENDER}, @code{GL_SELECT}, and @code{GL_FEEDBACK}.  The initial
value is @code{GL_RENDER}.

@end table

@code{glRenderMode} sets the rasterization mode.  It takes one argument,
@var{mode}, which can assume one of three predefined values:

@table @asis
@item @code{GL_RENDER}
Render mode.  Primitives are rasterized, producing pixel fragments,
which are written into the frame buffer.  This is the normal mode and
also the default mode.

@item @code{GL_SELECT}
Selection mode.  No pixel fragments are produced, and no change to the
frame buffer contents is made.  Instead, a record of the names of
primitives that would have been drawn if the render mode had been
@code{GL_RENDER} is returned in a select buffer, which must be created
(see @code{glSelectBuffer}) before selection mode is entered.

@item @code{GL_FEEDBACK}
Feedback mode.  No pixel fragments are produced, and no change to the
frame buffer contents is made.  Instead, the coordinates and attributes
of vertices that would have been drawn if the render mode had been
@code{GL_RENDER} is returned in a feedback buffer, which must be created
(see @code{glFeedbackBuffer}) before feedback mode is entered.

@end table

The return value of @code{glRenderMode} is determined by the render mode
at the time @code{glRenderMode} is called, rather than by @var{mode}.
The values returned for the three render modes are as follows:

@table @asis
@item @code{GL_RENDER}
0.

@item @code{GL_SELECT}
The number of hit records transferred to the select buffer.

@item @code{GL_FEEDBACK}
The number of values (not vertices) transferred to the feedback buffer.

@end table

See the @code{glSelectBuffer} and @code{glFeedbackBuffer} reference
pages for more details concerning selection and feedback operation.

@code{GL_INVALID_ENUM} is generated if @var{mode} is not one of the
three accepted values.

@code{GL_INVALID_OPERATION} is generated if @code{glSelectBuffer} is
called while the render mode is @code{GL_SELECT}, or if
@code{glRenderMode} is called with argument @code{GL_SELECT} before
@code{glSelectBuffer} is called at least once.

@code{GL_INVALID_OPERATION} is generated if @code{glFeedbackBuffer} is
called while the render mode is @code{GL_FEEDBACK}, or if
@code{glRenderMode} is called with argument @code{GL_FEEDBACK} before
@code{glFeedbackBuffer} is called at least once.

@code{GL_INVALID_OPERATION} is generated if @code{glRenderMode} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glResetHistogram target
Reset histogram table entries to zero.

@table @asis
@item @var{target}
Must be @code{GL_HISTOGRAM}.

@end table

@code{glResetHistogram} resets all the elements of the current histogram
table to zero.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_HISTOGRAM}.

@code{GL_INVALID_OPERATION} is generated if @code{glResetHistogram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glResetMinmax target
Reset minmax table entries to initial values.

@table @asis
@item @var{target}
Must be @code{GL_MINMAX}.

@end table

@code{glResetMinmax} resets the elements of the current minmax table to
their initial values: the ``maximum'' element receives the minimum
possible component values, and the ``minimum'' element receives the
maximum possible component values.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_MINMAX}.

@code{GL_INVALID_OPERATION} is generated if @code{glResetMinmax} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glRotated angle x y z
@deftypefunx void glRotatef angle x y z
Multiply the current matrix by a rotation matrix.

@table @asis
@item @var{angle}
Specifies the angle of rotation, in degrees.

@item @var{x}
@itemx @var{y}
@itemx @var{z}
Specify the @var{x}, @var{y}, and @var{z} coordinates of a vector,
respectively.

@end table

@code{glRotate} produces a rotation of @var{angle} degrees around the
vector @r{(@var{x},@var{y}@var{z})}.  The current matrix (see
@code{glMatrixMode}) is multiplied by a rotation matrix with the product
replacing the current matrix, as if @code{glMultMatrix} were called with
the following matrix as its argument:

@r{((@var{x}^2⁡(1-@var{c},)+@var{c}
@var{x}⁢@var{y}⁡(1-@var{c},)-@var{z}⁢@var{s}
@var{x}⁢@var{z}⁡(1-@var{c},)+@var{y}⁢@var{s} 0),
(@var{y}⁢@var{x}⁡(1-@var{c},)+@var{z}⁢@var{s}
@var{y}^2⁡(1-@var{c},)+@var{c}
@var{y}⁢@var{z}⁡(1-@var{c},)-@var{x}⁢@var{s} 0),
(@var{x}⁢@var{z}⁡(1-@var{c},)-@var{y}⁢@var{s}
@var{y}⁢@var{z}⁡(1-@var{c},)+@var{x}⁢@var{s}
@var{z}^2⁡(1-@var{c},)+@var{c} 0), (0 0 0 1),)}



Where @r{@var{c}=@var{cos}⁡(@var{angle},)},
@r{@var{s}=@var{sin}⁡(@var{angle},)}, and
@r{∥(@var{x},@var{y}@var{z}),∥=1} (if not, the GL will normalize this
vector).





If the matrix mode is either @code{GL_MODELVIEW} or
@code{GL_PROJECTION}, all objects drawn after @code{glRotate} is called
are rotated.  Use @code{glPushMatrix} and @code{glPopMatrix} to save and
restore the unrotated coordinate system.

@code{GL_INVALID_OPERATION} is generated if @code{glRotate} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glSampleCoverage value invert
Specify multisample coverage parameters.

@table @asis
@item @var{value}
Specify a single floating-point sample coverage value.  The value is
clamped to the range @r{[0,1]}.  The initial value is 1.0.

@item @var{invert}
Specify a single boolean value representing if the coverage masks should
be inverted.  @code{GL_TRUE} and @code{GL_FALSE} are accepted.  The
initial value is @code{GL_FALSE}.

@end table

Multisampling samples a pixel multiple times at various
implementation-dependent subpixel locations to generate antialiasing
effects.  Multisampling transparently antialiases points, lines,
polygons, bitmaps, and images if it is enabled.

@var{value} is used in constructing a temporary mask used in determining
which samples will be used in resolving the final fragment color.  This
mask is bitwise-anded with the coverage mask generated from the
multisampling computation.  If the @var{invert} flag is set, the
temporary mask is inverted (all bits flipped) and then the bitwise-and
is computed.

If an implementation does not have any multisample buffers available, or
multisampling is disabled, rasterization occurs with only a single
sample computing a pixel's final RGB color.

Provided an implementation supports multisample buffers, and
multisampling is enabled, then a pixel's final color is generated by
combining several samples per pixel.  Each sample contains color, depth,
and stencil information, allowing those operations to be performed on
each sample.

@code{GL_INVALID_OPERATION} is generated if @code{glSampleCoverage} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glScaled x y z
@deftypefunx void glScalef x y z
Multiply the current matrix by a general scaling matrix.

@table @asis
@item @var{x}
@itemx @var{y}
@itemx @var{z}
Specify scale factors along the @var{x}, @var{y}, and @var{z} axes,
respectively.

@end table

@code{glScale} produces a nonuniform scaling along the @var{x}, @var{y},
and @var{z} axes.  The three parameters indicate the desired scale
factor along each of the three axes.

The current matrix (see @code{glMatrixMode}) is multiplied by this scale
matrix, and the product replaces the current matrix as if
@code{glMultMatrix} were called with the following matrix as its
argument:

@r{((@var{x} 0 0 0), (0 @var{y} 0 0), (0 0 @var{z} 0), (0 0 0 1),)}

If the matrix mode is either @code{GL_MODELVIEW} or
@code{GL_PROJECTION}, all objects drawn after @code{glScale} is called
are scaled.

Use @code{glPushMatrix} and @code{glPopMatrix} to save and restore the
unscaled coordinate system.

@code{GL_INVALID_OPERATION} is generated if @code{glScale} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glScissor x y width height
Define the scissor box.

@table @asis
@item @var{x}
@itemx @var{y}
Specify the lower left corner of the scissor box.  Initially (0, 0).

@item @var{width}
@itemx @var{height}
Specify the width and height of the scissor box.  When a GL context is
first attached to a window, @var{width} and @var{height} are set to the
dimensions of that window.

@end table

@code{glScissor} defines a rectangle, called the scissor box, in window
coordinates.  The first two arguments, @var{x} and @var{y}, specify the
lower left corner of the box.  @var{width} and @var{height} specify the
width and height of the box.

To enable and disable the scissor test, call @code{glEnable} and
@code{glDisable} with argument @code{GL_SCISSOR_TEST}.  The test is
initially disabled.  While the test is enabled, only pixels that lie
within the scissor box can be modified by drawing commands.  Window
coordinates have integer values at the shared corners of frame buffer
pixels.  @code{glScissor(0,0,1,1)} allows modification of only the lower
left pixel in the window, and @code{glScissor(0,0,0,0)} doesn't allow
modification of any pixels in the window.

When the scissor test is disabled, it is as though the scissor box
includes the entire window.

@code{GL_INVALID_VALUE} is generated if either @var{width} or
@var{height} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glScissor} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glSecondaryColorPointer size type stride pointer
Define an array of secondary colors.

@table @asis
@item @var{size}
Specifies the number of components per color.  Must be 3.

@item @var{type}
Specifies the data type of each color component in the array.  Symbolic
constants @code{GL_BYTE}, @code{GL_UNSIGNED_BYTE}, @code{GL_SHORT},
@code{GL_UNSIGNED_SHORT}, @code{GL_INT}, @code{GL_UNSIGNED_INT},
@code{GL_FLOAT}, or @code{GL_DOUBLE} are accepted.  The initial value is
@code{GL_FLOAT}.

@item @var{stride}
Specifies the byte offset between consecutive colors.  If @var{stride}
is 0, the colors are understood to be tightly packed in the array.  The
initial value is 0.

@item @var{pointer}
Specifies a pointer to the first component of the first color element in
the array.  The initial value is 0.

@end table

@code{glSecondaryColorPointer} specifies the location and data format of
an array of color components to use when rendering.  @var{size}
specifies the number of components per color, and must be 3.  @var{type}
specifies the data type of each color component, and @var{stride}
specifies the byte stride from one color to the next, allowing vertices
and attributes to be packed into a single array or stored in separate
arrays.

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a secondary color array is
specified, @var{pointer} is treated as a byte offset into the buffer
object's data store.  Also, the buffer object binding
(@code{GL_ARRAY_BUFFER_BINDING}) is saved as secondary color vertex
array client-side state
(@code{GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING}).

When a secondary color array is specified, @var{size}, @var{type},
@var{stride}, and @var{pointer} are saved as client-side state, in
addition to the current vertex array buffer object binding.

To enable and disable the secondary color array, call
@code{glEnableClientState} and @code{glDisableClientState} with the
argument @code{GL_SECONDARY_COLOR_ARRAY}.  If enabled, the secondary
color array is used when @code{glArrayElement}, @code{glDrawArrays},
@code{glMultiDrawArrays}, @code{glDrawElements},
@code{glMultiDrawElements}, or @code{glDrawRangeElements} is called.

@code{GL_INVALID_VALUE} is generated if @var{size} is not 3.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glSecondaryColor3b red green blue
@deftypefunx void glSecondaryColor3s red green blue
@deftypefunx void glSecondaryColor3i red green blue
@deftypefunx void glSecondaryColor3f red green blue
@deftypefunx void glSecondaryColor3d red green blue
@deftypefunx void glSecondaryColor3ub red green blue
@deftypefunx void glSecondaryColor3us red green blue
@deftypefunx void glSecondaryColor3ui red green blue
@deftypefunx void glSecondaryColor3bv v
@deftypefunx void glSecondaryColor3sv v
@deftypefunx void glSecondaryColor3iv v
@deftypefunx void glSecondaryColor3fv v
@deftypefunx void glSecondaryColor3dv v
@deftypefunx void glSecondaryColor3ubv v
@deftypefunx void glSecondaryColor3usv v
@deftypefunx void glSecondaryColor3uiv v
Set the current secondary color.

@table @asis
@item @var{red}
@itemx @var{green}
@itemx @var{blue}
Specify new red, green, and blue values for the current secondary color.

@end table

The GL stores both a primary four-valued RGBA color and a secondary
four-valued RGBA color (where alpha is always set to 0.0) that is
associated with every vertex.

The secondary color is interpolated and applied to each fragment during
rasterization when @code{GL_COLOR_SUM} is enabled.  When lighting is
enabled, and @code{GL_SEPARATE_SPECULAR_COLOR} is specified, the value
of the secondary color is assigned the value computed from the specular
term of the lighting computation.  Both the primary and secondary
current colors are applied to each fragment, regardless of the state of
@code{GL_COLOR_SUM}, under such conditions.  When
@code{GL_SEPARATE_SPECULAR_COLOR} is specified, the value returned from
querying the current secondary color is undefined.

@code{glSecondaryColor3b}, @code{glSecondaryColor3s}, and
@code{glSecondaryColor3i} take three signed byte, short, or long
integers as arguments.  When @strong{v} is appended to the name, the
color commands can take a pointer to an array of such values.

Color values are stored in floating-point format, with unspecified
mantissa and exponent sizes.  Unsigned integer color components, when
specified, are linearly mapped to floating-point values such that the
largest representable value maps to 1.0 (full intensity), and 0 maps to
0.0 (zero intensity).  Signed integer color components, when specified,
are linearly mapped to floating-point values such that the most positive
representable value maps to 1.0, and the most negative representable
value maps to @r{-1.0}.  (Note that this mapping does not convert 0
precisely to 0.0).  Floating-point values are mapped directly.

Neither floating-point nor signed integer values are clamped to the
range @r{[0,1]} before the current color is updated.  However, color
components are clamped to this range before they are interpolated or
written into a color buffer.

@end deftypefun

@deftypefun void glSelectBuffer size buffer
Establish a buffer for selection mode values.

@table @asis
@item @var{size}
Specifies the size of @var{buffer}.

@item @var{buffer}
Returns the selection data.

@end table

@code{glSelectBuffer} has two arguments: @var{buffer} is a pointer to an
array of unsigned integers, and @var{size} indicates the size of the
array.  @var{buffer} returns values from the name stack (see
@code{glInitNames}, @code{glLoadName}, @code{glPushName}) when the
rendering mode is @code{GL_SELECT} (see @code{glRenderMode}).
@code{glSelectBuffer} must be issued before selection mode is enabled,
and it must not be issued while the rendering mode is @code{GL_SELECT}.

A programmer can use selection to determine which primitives are drawn
into some region of a window.  The region is defined by the current
modelview and perspective matrices.

In selection mode, no pixel fragments are produced from rasterization.
Instead, if a primitive or a raster position intersects the clipping
volume defined by the viewing frustum and the user-defined clipping
planes, this primitive causes a selection hit.  (With polygons, no hit
occurs if the polygon is culled.) When a change is made to the name
stack, or when @code{glRenderMode} is called, a hit record is copied to
@var{buffer} if any hits have occurred since the last such event (name
stack change or @code{glRenderMode} call).  The hit record consists of
the number of names in the name stack at the time of the event, followed
by the minimum and maximum depth values of all vertices that hit since
the previous event, followed by the name stack contents, bottom name
first.

Depth values (which are in the range [0,1]) are multiplied by
@r{2^32-1}, before being placed in the hit record.

An internal index into @var{buffer} is reset to 0 whenever selection
mode is entered.  Each time a hit record is copied into @var{buffer},
the index is incremented to point to the cell just past the end of the
block of names\(emthat is, to the next available cell If the hit record
is larger than the number of remaining locations in @var{buffer}, as
much data as can fit is copied, and the overflow flag is set.  If the
name stack is empty when a hit record is copied, that record consists of
0 followed by the minimum and maximum depth values.

To exit selection mode, call @code{glRenderMode} with an argument other
than @code{GL_SELECT}.  Whenever @code{glRenderMode} is called while the
render mode is @code{GL_SELECT}, it returns the number of hit records
copied to @var{buffer}, resets the overflow flag and the selection
buffer pointer, and initializes the name stack to be empty.  If the
overflow bit was set when @code{glRenderMode} was called, a negative hit
record count is returned.

@code{GL_INVALID_VALUE} is generated if @var{size} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glSelectBuffer} is
called while the render mode is @code{GL_SELECT}, or if
@code{glRenderMode} is called with argument @code{GL_SELECT} before
@code{glSelectBuffer} is called at least once.

@code{GL_INVALID_OPERATION} is generated if @code{glSelectBuffer} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glSeparableFilter2D target internalformat width height format type row column
Define a separable two-dimensional convolution filter.

@table @asis
@item @var{target}
Must be @code{GL_SEPARABLE_2D}.

@item @var{internalformat}
The internal format of the convolution filter kernel.  The allowable
values are @code{GL_ALPHA}, @code{GL_ALPHA4}, @code{GL_ALPHA8},
@code{GL_ALPHA12}, @code{GL_ALPHA16}, @code{GL_LUMINANCE},
@code{GL_LUMINANCE4}, @code{GL_LUMINANCE8}, @code{GL_LUMINANCE12},
@code{GL_LUMINANCE16}, @code{GL_LUMINANCE_ALPHA},
@code{GL_LUMINANCE4_ALPHA4}, @code{GL_LUMINANCE6_ALPHA2},
@code{GL_LUMINANCE8_ALPHA8}, @code{GL_LUMINANCE12_ALPHA4},
@code{GL_LUMINANCE12_ALPHA12}, @code{GL_LUMINANCE16_ALPHA16},
@code{GL_INTENSITY}, @code{GL_INTENSITY4}, @code{GL_INTENSITY8},
@code{GL_INTENSITY12}, @code{GL_INTENSITY16}, @code{GL_R3_G3_B2},
@code{GL_RGB}, @code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8},
@code{GL_RGB10}, @code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA},
@code{GL_RGBA2}, @code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8},
@code{GL_RGB10_A2}, @code{GL_RGBA12}, or @code{GL_RGBA16}.

@item @var{width}
The number of elements in the pixel array referenced by @var{row}.  (This
is the width of the separable filter kernel.)

@item @var{height}
The number of elements in the pixel array referenced by @var{column}.
(This is the height of the separable filter kernel.)

@item @var{format}
The format of the pixel data in @var{row} and @var{column}.  The
allowable values are @code{GL_RED}, @code{GL_GREEN}, @code{GL_BLUE},
@code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR}, @code{GL_RGBA},
@code{GL_BGRA}, @code{GL_INTENSITY}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
The type of the pixel data in @var{row} and @var{column}.  Symbolic
constants @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE}, @code{GL_BITMAP},
@code{GL_UNSIGNED_SHORT}, @code{GL_SHORT}, @code{GL_UNSIGNED_INT},
@code{GL_INT}, @code{GL_FLOAT}, @code{GL_UNSIGNED_BYTE_3_3_2},
@code{GL_UNSIGNED_BYTE_2_3_3_REV}, @code{GL_UNSIGNED_SHORT_5_6_5},
@code{GL_UNSIGNED_SHORT_5_6_5_REV}, @code{GL_UNSIGNED_SHORT_4_4_4_4},
@code{GL_UNSIGNED_SHORT_4_4_4_4_REV}, @code{GL_UNSIGNED_SHORT_5_5_5_1},
@code{GL_UNSIGNED_SHORT_1_5_5_5_REV}, @code{GL_UNSIGNED_INT_8_8_8_8},
@code{GL_UNSIGNED_INT_8_8_8_8_REV}, @code{GL_UNSIGNED_INT_10_10_10_2},
and @code{GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.

@item @var{row}
Pointer to a one-dimensional array of pixel data that is processed to
build the row filter kernel.

@item @var{column}
Pointer to a one-dimensional array of pixel data that is processed to
build the column filter kernel.

@end table

@code{glSeparableFilter2D} builds a two-dimensional separable
convolution filter kernel from two arrays of pixels.

The pixel arrays specified by (@var{width}, @var{format}, @var{type},
@var{row}) and (@var{height}, @var{format}, @var{type}, @var{column})
are processed just as if they had been passed to @code{glDrawPixels},
but processing stops after the final expansion to RGBA is completed.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
convolution filter is specified, @var{row} and @var{column} are treated
as byte offsets into the buffer object's data store.

Next, the R, G, B, and A components of all pixels in both arrays are
scaled by the four separable 2D @code{GL_CONVOLUTION_FILTER_SCALE}
parameters and biased by the four separable 2D
@code{GL_CONVOLUTION_FILTER_BIAS} parameters.  (The scale and bias
parameters are set by @code{glConvolutionParameter} using the
@code{GL_SEPARABLE_2D} target and the names
@code{GL_CONVOLUTION_FILTER_SCALE} and
@code{GL_CONVOLUTION_FILTER_BIAS}.  The parameters themselves are
vectors of four values that are applied to red, green, blue, and alpha,
in that order.) The R, G, B, and A values are not clamped to [0,1] at
any time during this process.

Each pixel is then converted to the internal format specified by
@var{internalformat}.  This conversion simply maps the component values
of the pixel (R, G, B, and A) to the values included in the internal
format (red, green, blue, alpha, luminance, and intensity).  The mapping
is as follows:

@table @asis
@item @strong{Internal Format}
@strong{Red}, @strong{Green}, @strong{Blue}, @strong{Alpha},
@strong{Luminance}, @strong{Intensity}

@item @code{GL_LUMINANCE}
, , , , R ,

@item @code{GL_LUMINANCE_ALPHA}
, , , A , R ,

@item @code{GL_INTENSITY}
, , , , , R

@item @code{GL_RGB}
R , G , B , , ,

@item @code{GL_RGBA}
R , G , B , A , ,

@end table

The red, green, blue, alpha, luminance, and/or intensity components of
the resulting pixels are stored in floating-point rather than integer
format.  They form two one-dimensional filter kernel images.  The row
image is indexed by coordinate @var{i} starting at zero and increasing
from left to right.  Each location in the row image is derived from
element @var{i} of @var{row}.  The column image is indexed by coordinate
@var{j} starting at zero and increasing from bottom to top.  Each
location in the column image is derived from element @var{j} of
@var{column}.

Note that after a convolution is performed, the resulting color
components are also scaled by their corresponding
@code{GL_POST_CONVOLUTION_c_SCALE} parameters and biased by their
corresponding @code{GL_POST_CONVOLUTION_c_BIAS} parameters (where
@var{c} takes on the values @strong{RED}, @strong{GREEN}, @strong{BLUE},
and @strong{ALPHA}).  These parameters are set by
@code{glPixelTransfer}.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_SEPARABLE_2D}.

@code{GL_INVALID_ENUM} is generated if @var{internalformat} is not one
of the allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{type} is not one of the
allowable values.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than zero or
greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_SEPARABLE_2D} and name @code{GL_MAX_CONVOLUTION_WIDTH}.

@code{GL_INVALID_VALUE} is generated if @var{height} is less than zero
or greater than the maximum supported value.  This value may be queried
with @code{glGetConvolutionParameter} using target
@code{GL_SEPARABLE_2D} and name @code{GL_MAX_CONVOLUTION_HEIGHT}.

@code{GL_INVALID_OPERATION} is generated if @var{height} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{height} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{row}
or @var{column} is not evenly divisible into the number of bytes needed
to store in memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glSeparableFilter2D}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glShadeModel mode
Select flat or smooth shading.

@table @asis
@item @var{mode}
Specifies a symbolic value representing a shading technique.  Accepted
values are @code{GL_FLAT} and @code{GL_SMOOTH}.  The initial value is
@code{GL_SMOOTH}.

@end table

GL primitives can have either flat or smooth shading.  Smooth shading,
the default, causes the computed colors of vertices to be interpolated
as the primitive is rasterized, typically assigning different colors to
each resulting pixel fragment.  Flat shading selects the computed color
of just one vertex and assigns it to all the pixel fragments generated
by rasterizing a single primitive.  In either case, the computed color
of a vertex is the result of lighting if lighting is enabled, or it is
the current color at the time the vertex was specified if lighting is
disabled.

Flat and smooth shading are indistinguishable for points.  Starting when
@code{glBegin} is issued and counting vertices and primitives from 1,
the GL gives each flat-shaded line segment @r{@var{i}} the computed
color of vertex @r{@var{i}+1}, its second vertex.  Counting similarly
from 1, the GL gives each flat-shaded polygon the computed color of the
vertex listed in the following table.  This is the last vertex to
specify the polygon in all cases except single polygons, where the first
vertex specifies the flat-shaded color.



@table @asis
@item @strong{ Primitive Type of Polygon @r{@var{i}}}
@strong{Vertex}

@item  Single polygon                          (@r{@var{i}==1}) 
1

@item  Triangle strip 
@r{@var{i}+2}

@item  Triangle fan 
@r{@var{i}+2}

@item  Independent triangle 
@r{3⁢@var{i}}

@item  Quad strip 
@r{2⁢@var{i}+2}

@item  Independent quad 
@r{4⁢@var{i}}

@end table

Flat and smooth shading are specified by @code{glShadeModel} with
@var{mode} set to @code{GL_FLAT} and @code{GL_SMOOTH}, respectively.

@code{GL_INVALID_ENUM} is generated if @var{mode} is any value other
than @code{GL_FLAT} or @code{GL_SMOOTH}.

@code{GL_INVALID_OPERATION} is generated if @code{glShadeModel} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glShaderSource shader count string length
Replaces the source code in a shader object.

@table @asis
@item @var{shader}
Specifies the handle of the shader object whose source code is to be
replaced.

@item @var{count}
Specifies the number of elements in the @var{string} and @var{length}
arrays.

@item @var{string}
Specifies an array of pointers to strings containing the source code to
be loaded into the shader.

@item @var{length}
Specifies an array of string lengths.

@end table

@code{glShaderSource} sets the source code in @var{shader} to the source
code in the array of strings specified by @var{string}.  Any source code
previously stored in the shader object is completely replaced.  The
number of strings in the array is specified by @var{count}.  If
@var{length} is @code{NULL}, each string is assumed to be null
terminated.  If @var{length} is a value other than @code{NULL}, it
points to an array containing a string length for each of the
corresponding elements of @var{string}.  Each element in the
@var{length} array may contain the length of the corresponding string
(the null character is not counted as part of the string length) or a
value less than 0 to indicate that the string is null terminated.  The
source code strings are not scanned or parsed at this time; they are
simply copied into the specified shader object.

@code{GL_INVALID_VALUE} is generated if @var{shader} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{shader} is not a shader
object.

@code{GL_INVALID_VALUE} is generated if @var{count} is less than 0.

@code{GL_INVALID_OPERATION} is generated if @code{glShaderSource} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glStencilFuncSeparate face func ref mask
Set front and/or back function and reference value for stencil testing.

@table @asis
@item @var{face}
Specifies whether front and/or back stencil state is updated.  Three
symbolic constants are valid: @code{GL_FRONT}, @code{GL_BACK}, and
@code{GL_FRONT_AND_BACK}.

@item @var{func}
Specifies the test function.  Eight symbolic constants are valid:
@code{GL_NEVER}, @code{GL_LESS}, @code{GL_LEQUAL}, @code{GL_GREATER},
@code{GL_GEQUAL}, @code{GL_EQUAL}, @code{GL_NOTEQUAL}, and
@code{GL_ALWAYS}.  The initial value is @code{GL_ALWAYS}.

@item @var{ref}
Specifies the reference value for the stencil test.  @var{ref} is
clamped to the range @r{[0,2^@var{n}-1]}, where @r{@var{n}} is the
number of bitplanes in the stencil buffer.  The initial value is 0.

@item @var{mask}
Specifies a mask that is ANDed with both the reference value and the
stored stencil value when the test is done.  The initial value is all
1's.

@end table

Stenciling, like depth-buffering, enables and disables drawing on a
per-pixel basis.  You draw into the stencil planes using GL drawing
primitives, then render geometry and images, using the stencil planes to
mask out portions of the screen.  Stenciling is typically used in
multipass rendering algorithms to achieve special effects, such as
decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome
of a comparison between the reference value and the value in the stencil
buffer.  To enable and disable the test, call @code{glEnable} and
@code{glDisable} with argument @code{GL_STENCIL_TEST}.  To specify
actions based on the outcome of the stencil test, call
@code{glStencilOp} or @code{glStencilOpSeparate}.

There can be two separate sets of @var{func}, @var{ref}, and @var{mask}
parameters; one affects back-facing polygons, and the other affects
front-facing polygons as well as other non-polygon primitives.
@code{glStencilFunc} sets both front and back stencil state to the same
values, as if @code{glStencilFuncSeparate} were called with @var{face}
set to @code{GL_FRONT_AND_BACK}.

@var{func} is a symbolic constant that determines the stencil comparison
function.  It accepts one of eight values, shown in the following list.
@var{ref} is an integer reference value that is used in the stencil
comparison.  It is clamped to the range @r{[0,2^@var{n}-1]}, where
@r{@var{n}} is the number of bitplanes in the stencil buffer.  @var{mask}
is bitwise ANDed with both the reference value and the stored stencil
value, with the ANDed values participating in the comparison.

If @var{stencil} represents the value stored in the corresponding
stencil buffer location, the following list shows the effect of each
comparison function that can be specified by @var{func}.  Only if the
comparison succeeds is the pixel passed through to the next stage in the
rasterization process (see @code{glStencilOp}).  All tests treat
@var{stencil} values as unsigned integers in the range
@r{[0,2^@var{n}-1]}, where @r{@var{n}} is the number of bitplanes in the
stencil buffer.

The following values are accepted by @var{func}:

@table @asis
@item @code{GL_NEVER}
Always fails.

@item @code{GL_LESS}
Passes if ( @var{ref} & @var{mask} ) < ( @var{stencil} & @var{mask} ).

@item @code{GL_LEQUAL}
Passes if ( @var{ref} & @var{mask} ) <= ( @var{stencil} & @var{mask} ).

@item @code{GL_GREATER}
Passes if ( @var{ref} & @var{mask} ) > ( @var{stencil} & @var{mask} ).

@item @code{GL_GEQUAL}
Passes if ( @var{ref} & @var{mask} ) >= ( @var{stencil} & @var{mask} ).

@item @code{GL_EQUAL}
Passes if ( @var{ref} & @var{mask} ) = ( @var{stencil} & @var{mask} ).

@item @code{GL_NOTEQUAL}
Passes if ( @var{ref} & @var{mask} ) != ( @var{stencil} & @var{mask} ).

@item @code{GL_ALWAYS}
Always passes.

@end table

@code{GL_INVALID_ENUM} is generated if @var{func} is not one of the
eight accepted values.

@code{GL_INVALID_OPERATION} is generated if @code{glStencilFuncSeparate}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glStencilFunc func ref mask
Set front and back function and reference value for stencil testing.

@table @asis
@item @var{func}
Specifies the test function.  Eight symbolic constants are valid:
@code{GL_NEVER}, @code{GL_LESS}, @code{GL_LEQUAL}, @code{GL_GREATER},
@code{GL_GEQUAL}, @code{GL_EQUAL}, @code{GL_NOTEQUAL}, and
@code{GL_ALWAYS}.  The initial value is @code{GL_ALWAYS}.

@item @var{ref}
Specifies the reference value for the stencil test.  @var{ref} is
clamped to the range @r{[0,2^@var{n}-1]}, where @r{@var{n}} is the
number of bitplanes in the stencil buffer.  The initial value is 0.

@item @var{mask}
Specifies a mask that is ANDed with both the reference value and the
stored stencil value when the test is done.  The initial value is all
1's.

@end table

Stenciling, like depth-buffering, enables and disables drawing on a
per-pixel basis.  Stencil planes are first drawn into using GL drawing
primitives, then geometry and images are rendered using the stencil
planes to mask out portions of the screen.  Stenciling is typically used
in multipass rendering algorithms to achieve special effects, such as
decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome
of a comparison between the reference value and the value in the stencil
buffer.  To enable and disable the test, call @code{glEnable} and
@code{glDisable} with argument @code{GL_STENCIL_TEST}.  To specify
actions based on the outcome of the stencil test, call
@code{glStencilOp} or @code{glStencilOpSeparate}.

There can be two separate sets of @var{func}, @var{ref}, and @var{mask}
parameters; one affects back-facing polygons, and the other affects
front-facing polygons as well as other non-polygon primitives.
@code{glStencilFunc} sets both front and back stencil state to the same
values.  Use @code{glStencilFuncSeparate} to set front and back stencil
state to different values.

@var{func} is a symbolic constant that determines the stencil comparison
function.  It accepts one of eight values, shown in the following list.
@var{ref} is an integer reference value that is used in the stencil
comparison.  It is clamped to the range @r{[0,2^@var{n}-1]}, where
@r{@var{n}} is the number of bitplanes in the stencil buffer.  @var{mask}
is bitwise ANDed with both the reference value and the stored stencil
value, with the ANDed values participating in the comparison.

If @var{stencil} represents the value stored in the corresponding
stencil buffer location, the following list shows the effect of each
comparison function that can be specified by @var{func}.  Only if the
comparison succeeds is the pixel passed through to the next stage in the
rasterization process (see @code{glStencilOp}).  All tests treat
@var{stencil} values as unsigned integers in the range
@r{[0,2^@var{n}-1]}, where @r{@var{n}} is the number of bitplanes in the
stencil buffer.

The following values are accepted by @var{func}:

@table @asis
@item @code{GL_NEVER}
Always fails.

@item @code{GL_LESS}
Passes if ( @var{ref} & @var{mask} ) < ( @var{stencil} & @var{mask} ).

@item @code{GL_LEQUAL}
Passes if ( @var{ref} & @var{mask} ) <= ( @var{stencil} & @var{mask} ).

@item @code{GL_GREATER}
Passes if ( @var{ref} & @var{mask} ) > ( @var{stencil} & @var{mask} ).

@item @code{GL_GEQUAL}
Passes if ( @var{ref} & @var{mask} ) >= ( @var{stencil} & @var{mask} ).

@item @code{GL_EQUAL}
Passes if ( @var{ref} & @var{mask} ) = ( @var{stencil} & @var{mask} ).

@item @code{GL_NOTEQUAL}
Passes if ( @var{ref} & @var{mask} ) != ( @var{stencil} & @var{mask} ).

@item @code{GL_ALWAYS}
Always passes.

@end table

@code{GL_INVALID_ENUM} is generated if @var{func} is not one of the
eight accepted values.

@code{GL_INVALID_OPERATION} is generated if @code{glStencilFunc} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glStencilMaskSeparate face mask
Control the front and/or back writing of individual bits in the stencil
planes.

@table @asis
@item @var{face}
Specifies whether the front and/or back stencil writemask is updated.
Three symbolic constants are valid: @code{GL_FRONT}, @code{GL_BACK}, and
@code{GL_FRONT_AND_BACK}.

@item @var{mask}
Specifies a bit mask to enable and disable writing of individual bits in
the stencil planes.  Initially, the mask is all 1's.

@end table

@code{glStencilMaskSeparate} controls the writing of individual bits in
the stencil planes.  The least significant @r{@var{n}} bits of
@var{mask}, where @r{@var{n}} is the number of bits in the stencil
buffer, specify a mask.  Where a 1 appears in the mask, it's possible to
write to the corresponding bit in the stencil buffer.  Where a 0
appears, the corresponding bit is write-protected.  Initially, all bits
are enabled for writing.

There can be two separate @var{mask} writemasks; one affects back-facing
polygons, and the other affects front-facing polygons as well as other
non-polygon primitives.  @code{glStencilMask} sets both front and back
stencil writemasks to the same values, as if
@code{glStencilMaskSeparate} were called with @var{face} set to
@code{GL_FRONT_AND_BACK}.

@code{GL_INVALID_OPERATION} is generated if @code{glStencilMaskSeparate}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glStencilMask mask
Control the front and back writing of individual bits in the stencil
planes.

@table @asis
@item @var{mask}
Specifies a bit mask to enable and disable writing of individual bits in
the stencil planes.  Initially, the mask is all 1's.

@end table

@code{glStencilMask} controls the writing of individual bits in the
stencil planes.  The least significant @r{@var{n}} bits of @var{mask},
where @r{@var{n}} is the number of bits in the stencil buffer, specify a
mask.  Where a 1 appears in the mask, it's possible to write to the
corresponding bit in the stencil buffer.  Where a 0 appears, the
corresponding bit is write-protected.  Initially, all bits are enabled
for writing.

There can be two separate @var{mask} writemasks; one affects back-facing
polygons, and the other affects front-facing polygons as well as other
non-polygon primitives.  @code{glStencilMask} sets both front and back
stencil writemasks to the same values.  Use @code{glStencilMaskSeparate}
to set front and back stencil writemasks to different values.

@code{GL_INVALID_OPERATION} is generated if @code{glStencilMask} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glStencilOpSeparate face sfail dpfail dppass
Set front and/or back stencil test actions.

@table @asis
@item @var{face}
Specifies whether front and/or back stencil state is updated.  Three
symbolic constants are valid: @code{GL_FRONT}, @code{GL_BACK}, and
@code{GL_FRONT_AND_BACK}.

@item @var{sfail}
Specifies the action to take when the stencil test fails.  Eight
symbolic constants are accepted: @code{GL_KEEP}, @code{GL_ZERO},
@code{GL_REPLACE}, @code{GL_INCR}, @code{GL_INCR_WRAP}, @code{GL_DECR},
@code{GL_DECR_WRAP}, and @code{GL_INVERT}.  The initial value is
@code{GL_KEEP}.

@item @var{dpfail}
Specifies the stencil action when the stencil test passes, but the depth
test fails.  @var{dpfail} accepts the same symbolic constants as
@var{sfail}.  The initial value is @code{GL_KEEP}.

@item @var{dppass}
Specifies the stencil action when both the stencil test and the depth
test pass, or when the stencil test passes and either there is no depth
buffer or depth testing is not enabled.  @var{dppass} accepts the same
symbolic constants as @var{sfail}.  The initial value is @code{GL_KEEP}.

@end table

Stenciling, like depth-buffering, enables and disables drawing on a
per-pixel basis.  You draw into the stencil planes using GL drawing
primitives, then render geometry and images, using the stencil planes to
mask out portions of the screen.  Stenciling is typically used in
multipass rendering algorithms to achieve special effects, such as
decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome
of a comparison between the value in the stencil buffer and a reference
value.  To enable and disable the test, call @code{glEnable} and
@code{glDisable} with argument @code{GL_STENCIL_TEST}; to control it,
call @code{glStencilFunc} or @code{glStencilFuncSeparate}.

There can be two separate sets of @var{sfail}, @var{dpfail}, and
@var{dppass} parameters; one affects back-facing polygons, and the other
affects front-facing polygons as well as other non-polygon primitives.
@code{glStencilOp} sets both front and back stencil state to the same
values, as if @code{glStencilOpSeparate} were called with @var{face} set
to @code{GL_FRONT_AND_BACK}.

@code{glStencilOpSeparate} takes three arguments that indicate what
happens to the stored stencil value while stenciling is enabled.  If the
stencil test fails, no change is made to the pixel's color or depth
buffers, and @var{sfail} specifies what happens to the stencil buffer
contents.  The following eight actions are possible.

@table @asis
@item @code{GL_KEEP}
Keeps the current value.

@item @code{GL_ZERO}
Sets the stencil buffer value to 0.

@item @code{GL_REPLACE}
Sets the stencil buffer value to @var{ref}, as specified by
@code{glStencilFunc}.

@item @code{GL_INCR}
Increments the current stencil buffer value.  Clamps to the maximum
representable unsigned value.

@item @code{GL_INCR_WRAP}
Increments the current stencil buffer value.  Wraps stencil buffer value
to zero when incrementing the maximum representable unsigned value.

@item @code{GL_DECR}
Decrements the current stencil buffer value.  Clamps to 0.

@item @code{GL_DECR_WRAP}
Decrements the current stencil buffer value.  Wraps stencil buffer value
to the maximum representable unsigned value when decrementing a stencil
buffer value of zero.

@item @code{GL_INVERT}
Bitwise inverts the current stencil buffer value.

@end table

Stencil buffer values are treated as unsigned integers.  When
incremented and decremented, values are clamped to 0 and
@r{2^@var{n}-1}, where @r{@var{n}} is the value returned by querying
@code{GL_STENCIL_BITS}.

The other two arguments to @code{glStencilOpSeparate} specify stencil
buffer actions that depend on whether subsequent depth buffer tests
succeed (@var{dppass}) or fail (@var{dpfail}) (see @code{glDepthFunc}).
The actions are specified using the same eight symbolic constants as
@var{sfail}.  Note that @var{dpfail} is ignored when there is no depth
buffer, or when the depth buffer is not enabled.  In these cases,
@var{sfail} and @var{dppass} specify stencil action when the stencil
test fails and passes, respectively.

@code{GL_INVALID_ENUM} is generated if @var{face} is any value other
than @code{GL_FRONT}, @code{GL_BACK}, or @code{GL_FRONT_AND_BACK}.

@code{GL_INVALID_ENUM} is generated if @var{sfail}, @var{dpfail}, or
@var{dppass} is any value other than the eight defined constant values.

@code{GL_INVALID_OPERATION} is generated if @code{glStencilOpSeparate}
is executed between the execution of @code{glBegin} and the
corresponding execution of @code{glEnd}.

@end deftypefun

@deftypefun void glStencilOp sfail dpfail dppass
Set front and back stencil test actions.

@table @asis
@item @var{sfail}
Specifies the action to take when the stencil test fails.  Eight
symbolic constants are accepted: @code{GL_KEEP}, @code{GL_ZERO},
@code{GL_REPLACE}, @code{GL_INCR}, @code{GL_INCR_WRAP}, @code{GL_DECR},
@code{GL_DECR_WRAP}, and @code{GL_INVERT}.  The initial value is
@code{GL_KEEP}.

@item @var{dpfail}
Specifies the stencil action when the stencil test passes, but the depth
test fails.  @var{dpfail} accepts the same symbolic constants as
@var{sfail}.  The initial value is @code{GL_KEEP}.

@item @var{dppass}
Specifies the stencil action when both the stencil test and the depth
test pass, or when the stencil test passes and either there is no depth
buffer or depth testing is not enabled.  @var{dppass} accepts the same
symbolic constants as @var{sfail}.  The initial value is @code{GL_KEEP}.

@end table

Stenciling, like depth-buffering, enables and disables drawing on a
per-pixel basis.  You draw into the stencil planes using GL drawing
primitives, then render geometry and images, using the stencil planes to
mask out portions of the screen.  Stenciling is typically used in
multipass rendering algorithms to achieve special effects, such as
decals, outlining, and constructive solid geometry rendering.

The stencil test conditionally eliminates a pixel based on the outcome
of a comparison between the value in the stencil buffer and a reference
value.  To enable and disable the test, call @code{glEnable} and
@code{glDisable} with argument @code{GL_STENCIL_TEST}; to control it,
call @code{glStencilFunc} or @code{glStencilFuncSeparate}.

There can be two separate sets of @var{sfail}, @var{dpfail}, and
@var{dppass} parameters; one affects back-facing polygons, and the other
affects front-facing polygons as well as other non-polygon primitives.
@code{glStencilOp} sets both front and back stencil state to the same
values.  Use @code{glStencilOpSeparate} to set front and back stencil
state to different values.

@code{glStencilOp} takes three arguments that indicate what happens to
the stored stencil value while stenciling is enabled.  If the stencil
test fails, no change is made to the pixel's color or depth buffers, and
@var{sfail} specifies what happens to the stencil buffer contents.  The
following eight actions are possible.

@table @asis
@item @code{GL_KEEP}
Keeps the current value.

@item @code{GL_ZERO}
Sets the stencil buffer value to 0.

@item @code{GL_REPLACE}
Sets the stencil buffer value to @var{ref}, as specified by
@code{glStencilFunc}.

@item @code{GL_INCR}
Increments the current stencil buffer value.  Clamps to the maximum
representable unsigned value.

@item @code{GL_INCR_WRAP}
Increments the current stencil buffer value.  Wraps stencil buffer value
to zero when incrementing the maximum representable unsigned value.

@item @code{GL_DECR}
Decrements the current stencil buffer value.  Clamps to 0.

@item @code{GL_DECR_WRAP}
Decrements the current stencil buffer value.  Wraps stencil buffer value
to the maximum representable unsigned value when decrementing a stencil
buffer value of zero.

@item @code{GL_INVERT}
Bitwise inverts the current stencil buffer value.

@end table

Stencil buffer values are treated as unsigned integers.  When
incremented and decremented, values are clamped to 0 and
@r{2^@var{n}-1}, where @r{@var{n}} is the value returned by querying
@code{GL_STENCIL_BITS}.

The other two arguments to @code{glStencilOp} specify stencil buffer
actions that depend on whether subsequent depth buffer tests succeed
(@var{dppass}) or fail (@var{dpfail}) (see @code{glDepthFunc}).  The
actions are specified using the same eight symbolic constants as
@var{sfail}.  Note that @var{dpfail} is ignored when there is no depth
buffer, or when the depth buffer is not enabled.  In these cases,
@var{sfail} and @var{dppass} specify stencil action when the stencil
test fails and passes, respectively.

@code{GL_INVALID_ENUM} is generated if @var{sfail}, @var{dpfail}, or
@var{dppass} is any value other than the eight defined constant values.

@code{GL_INVALID_OPERATION} is generated if @code{glStencilOp} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTexCoordPointer size type stride pointer
Define an array of texture coordinates.

@table @asis
@item @var{size}
Specifies the number of coordinates per array element.  Must be 1, 2, 3,
or 4.  The initial value is 4.

@item @var{type}
Specifies the data type of each texture coordinate.  Symbolic constants
@code{GL_SHORT}, @code{GL_INT}, @code{GL_FLOAT}, or @code{GL_DOUBLE} are
accepted.  The initial value is @code{GL_FLOAT}.

@item @var{stride}
Specifies the byte offset between consecutive texture coordinate sets.
If @var{stride} is 0, the array elements are understood to be tightly
packed.  The initial value is 0.

@item @var{pointer}
Specifies a pointer to the first coordinate of the first texture
coordinate set in the array.  The initial value is 0.

@end table

@code{glTexCoordPointer} specifies the location and data format of an
array of texture coordinates to use when rendering.  @var{size}
specifies the number of coordinates per texture coordinate set, and must
be 1, 2, 3, or 4.  @var{type} specifies the data type of each texture
coordinate, and @var{stride} specifies the byte stride from one texture
coordinate set to the next, allowing vertices and attributes to be
packed into a single array or stored in separate arrays.  (Single-array
storage may be more efficient on some implementations; see
@code{glInterleavedArrays}.)

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a texture coordinate array is
specified, @var{pointer} is treated as a byte offset into the buffer
object's data store.  Also, the buffer object binding
(@code{GL_ARRAY_BUFFER_BINDING}) is saved as texture coordinate vertex
array client-side state (@code{GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING}).

When a texture coordinate array is specified, @var{size}, @var{type},
@var{stride}, and @var{pointer} are saved as client-side state, in
addition to the current vertex array buffer object binding.

To enable and disable a texture coordinate array, call
@code{glEnableClientState} and @code{glDisableClientState} with the
argument @code{GL_TEXTURE_COORD_ARRAY}.  If enabled, the texture
coordinate array is used when @code{glArrayElement},
@code{glDrawArrays}, @code{glMultiDrawArrays}, @code{glDrawElements},
@code{glMultiDrawElements}, or @code{glDrawRangeElements} is called.

@code{GL_INVALID_VALUE} is generated if @var{size} is not 1, 2, 3, or 4.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glTexCoord1s s
@deftypefunx void glTexCoord1i s
@deftypefunx void glTexCoord1f s
@deftypefunx void glTexCoord1d s
@deftypefunx void glTexCoord2s s t
@deftypefunx void glTexCoord2i s t
@deftypefunx void glTexCoord2f s t
@deftypefunx void glTexCoord2d s t
@deftypefunx void glTexCoord3s s t r
@deftypefunx void glTexCoord3i s t r
@deftypefunx void glTexCoord3f s t r
@deftypefunx void glTexCoord3d s t r
@deftypefunx void glTexCoord4s s t r q
@deftypefunx void glTexCoord4i s t r q
@deftypefunx void glTexCoord4f s t r q
@deftypefunx void glTexCoord4d s t r q
@deftypefunx void glTexCoord1sv v
@deftypefunx void glTexCoord1iv v
@deftypefunx void glTexCoord1fv v
@deftypefunx void glTexCoord1dv v
@deftypefunx void glTexCoord2sv v
@deftypefunx void glTexCoord2iv v
@deftypefunx void glTexCoord2fv v
@deftypefunx void glTexCoord2dv v
@deftypefunx void glTexCoord3sv v
@deftypefunx void glTexCoord3iv v
@deftypefunx void glTexCoord3fv v
@deftypefunx void glTexCoord3dv v
@deftypefunx void glTexCoord4sv v
@deftypefunx void glTexCoord4iv v
@deftypefunx void glTexCoord4fv v
@deftypefunx void glTexCoord4dv v
Set the current texture coordinates.

@table @asis
@item @var{s}
@itemx @var{t}
@itemx @var{r}
@itemx @var{q}
Specify @var{s}, @var{t}, @var{r}, and @var{q} texture coordinates.  Not
all parameters are present in all forms of the command.

@end table

@code{glTexCoord} specifies texture coordinates in one, two, three, or
four dimensions.  @code{glTexCoord1} sets the current texture
coordinates to @r{(@var{s},001)}; a call to @code{glTexCoord2} sets them
to @r{(@var{s},@var{t}01)}.  Similarly, @code{glTexCoord3} specifies the
texture coordinates as @r{(@var{s},@var{t}@var{r}1)}, and
@code{glTexCoord4} defines all four components explicitly as
@r{(@var{s},@var{t}@var{r}@var{q})}.

The current texture coordinates are part of the data that is associated
with each vertex and with the current raster position.  Initially, the
values for @var{s}, @var{t}, @var{r}, and @var{q} are (0, 0, 0, 1).



@end deftypefun

@deftypefun void glTexEnvf target pname param
@deftypefunx void glTexEnvi target pname param
@deftypefunx void glTexEnvfv target pname params
@deftypefunx void glTexEnviv target pname params
Set texture environment parameters.

@table @asis
@item @var{target}
Specifies a texture environment.  May be @code{GL_TEXTURE_ENV},
@code{GL_TEXTURE_FILTER_CONTROL} or @code{GL_POINT_SPRITE}.

@item @var{pname}
Specifies the symbolic name of a single-valued texture environment
parameter.  May be either @code{GL_TEXTURE_ENV_MODE},
@code{GL_TEXTURE_LOD_BIAS}, @code{GL_COMBINE_RGB},
@code{GL_COMBINE_ALPHA}, @code{GL_SRC0_RGB}, @code{GL_SRC1_RGB},
@code{GL_SRC2_RGB}, @code{GL_SRC0_ALPHA}, @code{GL_SRC1_ALPHA},
@code{GL_SRC2_ALPHA}, @code{GL_OPERAND0_RGB}, @code{GL_OPERAND1_RGB},
@code{GL_OPERAND2_RGB}, @code{GL_OPERAND0_ALPHA},
@code{GL_OPERAND1_ALPHA}, @code{GL_OPERAND2_ALPHA}, @code{GL_RGB_SCALE},
@code{GL_ALPHA_SCALE}, or @code{GL_COORD_REPLACE}.

@item @var{param}
Specifies a single symbolic constant, one of @code{GL_ADD},
@code{GL_ADD_SIGNED}, @code{GL_INTERPOLATE}, @code{GL_MODULATE},
@code{GL_DECAL}, @code{GL_BLEND}, @code{GL_REPLACE}, @code{GL_SUBTRACT},
@code{GL_COMBINE}, @code{GL_TEXTURE}, @code{GL_CONSTANT},
@code{GL_PRIMARY_COLOR}, @code{GL_PREVIOUS}, @code{GL_SRC_COLOR},
@code{GL_ONE_MINUS_SRC_COLOR}, @code{GL_SRC_ALPHA},
@code{GL_ONE_MINUS_SRC_ALPHA}, a single boolean value for the point
sprite texture coordinate replacement, a single floating-point value for
the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying
the @code{GL_RGB_SCALE} or @code{GL_ALPHA_SCALE}.

@end table

A texture environment specifies how texture values are interpreted when
a fragment is textured.  When @var{target} is
@code{GL_TEXTURE_FILTER_CONTROL}, @var{pname} must be
@code{GL_TEXTURE_LOD_BIAS}.  When @var{target} is @code{GL_TEXTURE_ENV},
@var{pname} can be @code{GL_TEXTURE_ENV_MODE},
@code{GL_TEXTURE_ENV_COLOR}, @code{GL_COMBINE_RGB},
@code{GL_COMBINE_ALPHA}, @code{GL_RGB_SCALE}, @code{GL_ALPHA_SCALE},
@code{GL_SRC0_RGB}, @code{GL_SRC1_RGB}, @code{GL_SRC2_RGB},
@code{GL_SRC0_ALPHA}, @code{GL_SRC1_ALPHA}, or @code{GL_SRC2_ALPHA}.

If @var{pname} is @code{GL_TEXTURE_ENV_MODE}, then @var{params} is (or
points to) the symbolic name of a texture function.  Six texture
functions may be specified: @code{GL_ADD}, @code{GL_MODULATE},
@code{GL_DECAL}, @code{GL_BLEND}, @code{GL_REPLACE}, or
@code{GL_COMBINE}.

The following table shows the correspondence of filtered texture values
@r{@var{R}_@var{t}}, @r{@var{G}_@var{t}}, @r{@var{B}_@var{t}},
@r{@var{A}_@var{t}}, @r{@var{L}_@var{t}}, @r{@var{I}_@var{t}} to texture
source components.  @r{@var{C}_@var{s}} and @r{@var{A}_@var{s}} are used
by the texture functions described below.



@table @asis
@item  Texture Base Internal Format 
@r{@code{C}_@var{s}}, @r{@code{A}_@var{s}}

@item @code{GL_ALPHA}
(0, 0, 0) , @r{@var{A}_@var{t}}

@item @code{GL_LUMINANCE}
( @r{@var{L}_@var{t}}, @r{@var{L}_@var{t}}, @r{@var{L}_@var{t}} ) , 1

@item @code{GL_LUMINANCE_ALPHA}
( @r{@var{L}_@var{t}}, @r{@var{L}_@var{t}}, @r{@var{L}_@var{t}} ) ,
@r{@var{A}_@var{t}}

@item @code{GL_INTENSITY}
( @r{@var{I}_@var{t}}, @r{@var{I}_@var{t}}, @r{@var{I}_@var{t}} ) ,
@r{@var{I}_@var{t}}

@item @code{GL_RGB}
( @r{@var{R}_@var{t}}, @r{@var{G}_@var{t}}, @r{@var{B}_@var{t}} ) , 1

@item @code{GL_RGBA}
( @r{@var{R}_@var{t}}, @r{@var{G}_@var{t}}, @r{@var{B}_@var{t}} ) ,
@r{@var{A}_@var{t}}

@end table

A texture function acts on the fragment to be textured using the texture
image value that applies to the fragment (see @code{glTexParameter}) and
produces an RGBA color for that fragment.  The following table shows how
the RGBA color is produced for each of the first five texture functions
that can be chosen.  @r{@var{C}} is a triple of color values (RGB) and
@r{@var{A}} is the associated alpha value.  RGBA values extracted from a
texture image are in the range [0,1].  The subscript @r{@var{p}} refers
to the color computed from the previous texture stage (or the incoming
fragment if processing texture stage 0), the subscript @r{@var{s}} to
the texture source color, the subscript @r{@var{c}} to the texture
environment color, and the subscript @r{@var{v}} indicates a value
produced by the texture function.



@table @asis
@item  Texture Base Internal Format 
@code{Value}, @code{GL_REPLACE} Function , @code{GL_MODULATE} Function ,
@code{GL_DECAL} Function , @code{GL_BLEND} Function , @code{GL_ADD}
Function

@item @code{GL_ALPHA}
@r{@var{C}_@var{v}=}, @r{@var{C}_@var{p}}, @r{@var{C}_@var{p}},
undefined , @r{@var{C}_@var{p}}, @r{@var{C}_@var{p}}

@item .
@r{@var{A}_@var{v}=}, @r{@var{A}_@var{s}},
@r{@var{A}_@var{p}⁢@var{A}_@var{s}}, ,
@r{@var{A}_@var{v}=@var{A}_@var{p}⁢@var{A}_@var{s}},
@r{@var{A}_@var{p}⁢@var{A}_@var{s}}

@item @code{GL_LUMINANCE}
@r{@var{C}_@var{v}=}, @r{@var{C}_@var{s}},
@r{@var{C}_@var{p}⁢@var{C}_@var{s}}, undefined ,
@r{@var{C}_@var{p}⁢(1-@var{C}_@var{s},)+@var{C}_@var{c}⁢@var{C}_@var{s}},
@r{@var{C}_@var{p}+@var{C}_@var{s}}

@item  (or 1) 
@r{@var{A}_@var{v}=}, @r{@var{A}_@var{p}}, @r{@var{A}_@var{p}}, ,
@r{@var{A}_@var{p}}, @r{@var{A}_@var{p}}

@item @code{GL_LUMINANCE_ALPHA}
@r{@var{C}_@var{v}=}, @r{@var{C}_@var{s}},
@r{@var{C}_@var{p}⁢@var{C}_@var{s}}, undefined ,
@r{@var{C}_@var{p}⁢(1-@var{C}_@var{s},)+@var{C}_@var{c}⁢@var{C}_@var{s}},
@r{@var{C}_@var{p}+@var{C}_@var{s}}

@item  (or 2) 
@r{@var{A}_@var{v}=}, @r{@var{A}_@var{s}},
@r{@var{A}_@var{p}⁢@var{A}_@var{s}}, ,
@r{@var{A}_@var{p}⁢@var{A}_@var{s}}, @r{@var{A}_@var{p}⁢@var{A}_@var{s}}

@item @code{GL_INTENSITY}
@r{@var{C}_@var{v}=}, @r{@var{C}_@var{s}},
@r{@var{C}_@var{p}⁢@var{C}_@var{s}}, undefined ,
@r{@var{C}_@var{p}⁢(1-@var{C}_@var{s},)+@var{C}_@var{c}⁢@var{C}_@var{s}},
@r{@var{C}_@var{p}+@var{C}_@var{s}}

@item .
@r{@var{A}_@var{v}=}, @r{@var{A}_@var{s}},
@r{@var{A}_@var{p}⁢@var{A}_@var{s}}, ,
@r{@var{A}_@var{p}⁢(1-@var{A}_@var{s},)+@var{A}_@var{c}⁢@var{A}_@var{s}},
@r{@var{A}_@var{p}+@var{A}_@var{s}}

@item @code{GL_RGB}
@r{@var{C}_@var{v}=}, @r{@var{C}_@var{s}},
@r{@var{C}_@var{p}⁢@var{C}_@var{s}}, @r{@var{C}_@var{s}},
@r{@var{C}_@var{p}⁢(1-@var{C}_@var{s},)+@var{C}_@var{c}⁢@var{C}_@var{s}},
@r{@var{C}_@var{p}+@var{C}_@var{s}}

@item  (or 3) 
@r{@var{A}_@var{v}=}, @r{@var{A}_@var{p}}, @r{@var{A}_@var{p}},
@r{@var{A}_@var{p}}, @r{@var{A}_@var{p}}, @r{@var{A}_@var{p}}

@item @code{GL_RGBA}
@r{@var{C}_@var{v}=}, @r{@var{C}_@var{s}},
@r{@var{C}_@var{p}⁢@var{C}_@var{s}},
@r{@var{C}_@var{p}⁢(1-@var{A}_@var{s},)+@var{C}_@var{s}⁢@var{A}_@var{s}},
@r{@var{C}_@var{p}⁢(1-@var{C}_@var{s},)+@var{C}_@var{c}⁢@var{C}_@var{s}},
@r{@var{C}_@var{p}+@var{C}_@var{s}}

@item  (or 4) 
@r{@var{A}_@var{v}=}, @r{@var{A}_@var{s}},
@r{@var{A}_@var{p}⁢@var{A}_@var{s}}, @r{@var{A}_@var{p}},
@r{@var{A}_@var{p}⁢@var{A}_@var{s}}, @r{@var{A}_@var{p}⁢@var{A}_@var{s}}

@end table

If @var{pname} is @code{GL_TEXTURE_ENV_MODE}, and @var{params} is
@code{GL_COMBINE}, the form of the texture function depends on the
values of @code{GL_COMBINE_RGB} and @code{GL_COMBINE_ALPHA}.

The following describes how the texture sources, as specified by
@code{GL_SRC0_RGB}, @code{GL_SRC1_RGB}, @code{GL_SRC2_RGB},
@code{GL_SRC0_ALPHA}, @code{GL_SRC1_ALPHA}, and @code{GL_SRC2_ALPHA},
are combined to produce a final texture color.  In the following tables,
@code{GL_SRC0_c} is represented by @r{@var{Arg0}}, @code{GL_SRC1_c} is
represented by @r{@var{Arg1}}, and @code{GL_SRC2_c} is represented by
@r{@var{Arg2}}.

@code{GL_COMBINE_RGB} accepts any of @code{GL_REPLACE},
@code{GL_MODULATE}, @code{GL_ADD}, @code{GL_ADD_SIGNED},
@code{GL_INTERPOLATE}, @code{GL_SUBTRACT}, @code{GL_DOT3_RGB}, or
@code{GL_DOT3_RGBA}.



@table @asis
@item @strong{@code{GL_COMBINE_RGB}}
@strong{Texture Function}

@item @code{GL_REPLACE}
@r{@var{Arg0}}

@item @code{GL_MODULATE}
@r{@var{Arg0}×@var{Arg1}}

@item @code{GL_ADD}
@r{@var{Arg0}+@var{Arg1}}

@item @code{GL_ADD_SIGNED}
@r{@var{Arg0}+@var{Arg1}-0.5}

@item @code{GL_INTERPOLATE}
@r{@var{Arg0}×@var{Arg2}+@var{Arg1}×(1-@var{Arg2},)}

@item @code{GL_SUBTRACT}
@r{@var{Arg0}-@var{Arg1}}

@item @code{GL_DOT3_RGB} or @code{GL_DOT3_RGBA}
@r{4×(((@var{Arg0}_@var{r},-0.5,)×(@var{Arg1}_@var{r},-0.5,),)+((@var{Arg0}_@var{g},-0.5,)×(@var{Arg1}_@var{g},-0.5,),)+((@var{Arg0}_@var{b},-0.5,)×(@var{Arg1}_@var{b},-0.5,),),)}

@end table

The scalar results for @code{GL_DOT3_RGB} and @code{GL_DOT3_RGBA} are
placed into each of the 3 (RGB) or 4 (RGBA) components on output.

Likewise, @code{GL_COMBINE_ALPHA} accepts any of @code{GL_REPLACE},
@code{GL_MODULATE}, @code{GL_ADD}, @code{GL_ADD_SIGNED},
@code{GL_INTERPOLATE}, or @code{GL_SUBTRACT}.  The following table
describes how alpha values are combined:



@table @asis
@item @strong{@code{GL_COMBINE_ALPHA}}
@strong{Texture Function}

@item @code{GL_REPLACE}
@r{@var{Arg0}}

@item @code{GL_MODULATE}
@r{@var{Arg0}×@var{Arg1}}

@item @code{GL_ADD}
@r{@var{Arg0}+@var{Arg1}}

@item @code{GL_ADD_SIGNED}
@r{@var{Arg0}+@var{Arg1}-0.5}

@item @code{GL_INTERPOLATE}
@r{@var{Arg0}×@var{Arg2}+@var{Arg1}×(1-@var{Arg2},)}

@item @code{GL_SUBTRACT}
@r{@var{Arg0}-@var{Arg1}}

@end table

In the following tables, the value @r{@var{C}_@var{s}} represents the
color sampled from the currently bound texture, @r{@var{C}_@var{c}}
represents the constant texture-environment color, @r{@var{C}_@var{f}}
represents the primary color of the incoming fragment, and
@r{@var{C}_@var{p}} represents the color computed from the previous
texture stage or @r{@var{C}_@var{f}} if processing texture stage 0.
Likewise, @r{@var{A}_@var{s}}, @r{@var{A}_@var{c}}, @r{@var{A}_@var{f}},
and @r{@var{A}_@var{p}} represent the respective alpha values.

The following table describes the values assigned to @r{@var{Arg0}},
@r{@var{Arg1}}, and @r{@var{Arg2}} based upon the RGB sources and
operands:



@table @asis
@item @strong{@code{GL_SRCn_RGB}}
@strong{@code{GL_OPERANDn_RGB}}, @strong{Argument Value}

@item @code{GL_TEXTURE}
@code{GL_SRC_COLOR}, @r{@var{C}_@var{s},}

@item .
@code{GL_ONE_MINUS_SRC_COLOR}, @r{1-@var{C}_@var{s},}

@item .
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{s},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{s},}

@item @code{GL_TEXTUREn}
@code{GL_SRC_COLOR}, @r{@var{C}_@var{s},}

@item .
@code{GL_ONE_MINUS_SRC_COLOR}, @r{1-@var{C}_@var{s},}

@item .
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{s},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{s},}

@item @code{GL_CONSTANT}
@code{GL_SRC_COLOR}, @r{@var{C}_@var{c},}

@item .
@code{GL_ONE_MINUS_SRC_COLOR}, @r{1-@var{C}_@var{c},}

@item .
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{c},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{c},}

@item @code{GL_PRIMARY_COLOR}
@code{GL_SRC_COLOR}, @r{@var{C}_@var{f},}

@item .
@code{GL_ONE_MINUS_SRC_COLOR}, @r{1-@var{C}_@var{f},}

@item .
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{f},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{f},}

@item @code{GL_PREVIOUS}
@code{GL_SRC_COLOR}, @r{@var{C}_@var{p},}

@item .
@code{GL_ONE_MINUS_SRC_COLOR}, @r{1-@var{C}_@var{p},}

@item .
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{p},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{p},}

@end table

For @code{GL_TEXTUREn} sources, @r{@var{C}_@var{s}} and
@r{@var{A}_@var{s}} represent the color and alpha, respectively,
produced from texture stage @r{@var{n}}.

The follow table describes the values assigned to @r{@var{Arg0}},
@r{@var{Arg1}}, and @r{@var{Arg2}} based upon the alpha sources and
operands:



@table @asis
@item @strong{@code{GL_SRCn_ALPHA}}
@strong{@code{GL_OPERANDn_ALPHA}}, @strong{Argument Value}

@item @code{GL_TEXTURE}
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{s},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{s},}

@item @code{GL_TEXTUREn}
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{s},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{s},}

@item @code{GL_CONSTANT}
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{c},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{c},}

@item @code{GL_PRIMARY_COLOR}
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{f},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{f},}

@item @code{GL_PREVIOUS}
@code{GL_SRC_ALPHA}, @r{@var{A}_@var{p},}

@item .
@code{GL_ONE_MINUS_SRC_ALPHA}, @r{1-@var{A}_@var{p},}

@end table

The RGB and alpha results of the texture function are multipled by the
values of @code{GL_RGB_SCALE} and @code{GL_ALPHA_SCALE}, respectively,
and clamped to the range @r{[0,1]}.

If @var{pname} is @code{GL_TEXTURE_ENV_COLOR}, @var{params} is a pointer
to an array that holds an RGBA color consisting of four values.  Integer
color components are interpreted linearly such that the most positive
integer maps to 1.0, and the most negative integer maps to -1.0.  The
values are clamped to the range [0,1] when they are specified.
@r{@var{C}_@var{c}} takes these four values.

If @var{pname} is @code{GL_TEXTURE_LOD_BIAS}, the value specified is
added to the texture level-of-detail parameter, that selects which
mipmap, or mipmaps depending upon the selected
@code{GL_TEXTURE_MIN_FILTER}, will be sampled.

@code{GL_TEXTURE_ENV_MODE} defaults to @code{GL_MODULATE} and
@code{GL_TEXTURE_ENV_COLOR} defaults to (0, 0, 0, 0).

If @var{target} is @code{GL_POINT_SPRITE} and @var{pname} is
@code{GL_COORD_REPLACE}, the boolean value specified is used to either
enable or disable point sprite texture coordinate replacement.  The
default value is @code{GL_FALSE}.

@code{GL_INVALID_ENUM} is generated when @var{target} or @var{pname} is
not one of the accepted defined values, or when @var{params} should have
a defined constant value (based on the value of @var{pname}) and does
not.

@code{GL_INVALID_VALUE} is generated if the @var{params} value for
@code{GL_RGB_SCALE} or @code{GL_ALPHA_SCALE} are not one of 1.0, 2.0, or
4.0.

@code{GL_INVALID_OPERATION} is generated if @code{glTexEnv} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glTexGeni coord pname param
@deftypefunx void glTexGenf coord pname param
@deftypefunx void glTexGend coord pname param
@deftypefunx void glTexGeniv coord pname params
@deftypefunx void glTexGenfv coord pname params
@deftypefunx void glTexGendv coord pname params
Control the generation of texture coordinates.

@table @asis
@item @var{coord}
Specifies a texture coordinate.  Must be one of @code{GL_S},
@code{GL_T}, @code{GL_R}, or @code{GL_Q}.

@item @var{pname}
Specifies the symbolic name of the texture-coordinate generation
function.  Must be @code{GL_TEXTURE_GEN_MODE}.

@item @var{param}
Specifies a single-valued texture generation parameter, one of
@code{GL_OBJECT_LINEAR}, @code{GL_EYE_LINEAR}, @code{GL_SPHERE_MAP},
@code{GL_NORMAL_MAP}, or @code{GL_REFLECTION_MAP}.

@end table

@code{glTexGen} selects a texture-coordinate generation function or
supplies coefficients for one of the functions.  @var{coord} names one
of the (@var{s}, @var{t}, @var{r}, @var{q}) texture coordinates; it must
be one of the symbols @code{GL_S}, @code{GL_T}, @code{GL_R}, or
@code{GL_Q}.  @var{pname} must be one of three symbolic constants:
@code{GL_TEXTURE_GEN_MODE}, @code{GL_OBJECT_PLANE}, or
@code{GL_EYE_PLANE}.  If @var{pname} is @code{GL_TEXTURE_GEN_MODE}, then
@var{params} chooses a mode, one of @code{GL_OBJECT_LINEAR},
@code{GL_EYE_LINEAR}, @code{GL_SPHERE_MAP}, @code{GL_NORMAL_MAP}, or
@code{GL_REFLECTION_MAP}.  If @var{pname} is either
@code{GL_OBJECT_PLANE} or @code{GL_EYE_PLANE}, @var{params} contains
coefficients for the corresponding texture generation function.

If the texture generation function is @code{GL_OBJECT_LINEAR}, the
function

@r{@var{g}=@var{p}_1×@var{x}_@var{o}+@var{p}_2×@var{y}_@var{o}+@var{p}_3×@var{z}_@var{o}+@var{p}_4×@var{w}_@var{o}}

is used, where @r{@var{g}} is the value computed for the coordinate
named in @var{coord}, @r{@var{p}_1}, @r{@var{p}_2}, @r{@var{p}_3}, and
@r{@var{p}_4} are the four values supplied in @var{params}, and
@r{@var{x}_@var{o}}, @r{@var{y}_@var{o}}, @r{@var{z}_@var{o}}, and
@r{@var{w}_@var{o}} are the object coordinates of the vertex.  This
function can be used, for example, to texture-map terrain using sea
level as a reference plane (defined by @r{@var{p}_1}, @r{@var{p}_2},
@r{@var{p}_3}, and @r{@var{p}_4}).  The altitude of a terrain vertex is
computed by the @code{GL_OBJECT_LINEAR} coordinate generation function
as its distance from sea level; that altitude can then be used to index
the texture image to map white snow onto peaks and green grass onto
foothills.

If the texture generation function is @code{GL_EYE_LINEAR}, the function

@r{@var{g}=@var{p}_1,^″×@var{x}_@var{e}+@var{p}_2,^″×@var{y}_@var{e}+@var{p}_3,^″×@var{z}_@var{e}+@var{p}_4,^″×@var{w}_@var{e}}

is used, where

@r{(@var{p}_1,^″⁢@var{p}_2,^″⁢@var{p}_3,^″⁢@var{p}_4,^″,)=(@var{p}_1⁢@var{p}_2⁢@var{p}_3⁢@var{p}_4,)⁢@var{M}^-1}

and @r{@var{x}_@var{e}}, @r{@var{y}_@var{e}}, @r{@var{z}_@var{e}}, and
@r{@var{w}_@var{e}} are the eye coordinates of the vertex,
@r{@var{p}_1}, @r{@var{p}_2}, @r{@var{p}_3}, and @r{@var{p}_4} are the
values supplied in @var{params}, and @r{@var{M}} is the modelview matrix
when @code{glTexGen} is invoked.  If @r{@var{M}} is poorly conditioned
or singular, texture coordinates generated by the resulting function may
be inaccurate or undefined.

Note that the values in @var{params} define a reference plane in eye
coordinates.  The modelview matrix that is applied to them may not be
the same one in effect when the polygon vertices are transformed.  This
function establishes a field of texture coordinates that can produce
dynamic contour lines on moving objects.

If the texture generation function is @code{GL_SPHERE_MAP} and
@var{coord} is either @code{GL_S} or @code{GL_T}, @r{@var{s}} and
@r{@var{t}} texture coordinates are generated as follows.  Let @var{u}
be the unit vector pointing from the origin to the polygon vertex (in
eye coordinates).  Let @var{n} sup prime be the current normal, after
transformation to eye coordinates.  Let

@r{@var{f}=(@var{f}_@var{x}⁢@var{f}_@var{y}⁢@var{f}_@var{z},)^@var{T}}
be the reflection vector such that

@r{@var{f}=@var{u}-2⁢@var{n}^″⁢@var{n}^″,^@var{T}⁢@var{u}}

Finally, let
@r{@var{m}=2⁢√(@var{f}_@var{x},^2+@var{f}_@var{y},^2+(@var{f}_@var{z}+1,)^2,)}.
Then the values assigned to the @r{@var{s}} and @r{@var{t}} texture
coordinates are

@r{@var{s}=@var{f}_@var{x}/@var{m}+1/2}

@r{@var{t}=@var{f}_@var{y}/@var{m}+1/2}

To enable or disable a texture-coordinate generation function, call
@code{glEnable} or @code{glDisable} with one of the symbolic
texture-coordinate names (@code{GL_TEXTURE_GEN_S},
@code{GL_TEXTURE_GEN_T}, @code{GL_TEXTURE_GEN_R}, or
@code{GL_TEXTURE_GEN_Q}) as the argument.  When enabled, the specified
texture coordinate is computed according to the generating function
associated with that coordinate.  When disabled, subsequent vertices
take the specified texture coordinate from the current set of texture
coordinates.  Initially, all texture generation functions are set to
@code{GL_EYE_LINEAR} and are disabled.  Both @r{@var{s}} plane equations
are (1, 0, 0, 0), both @r{@var{t}} plane equations are (0, 1, 0, 0), and
all @r{@var{r}} and @r{@var{q}} plane equations are (0, 0, 0, 0).

When the @code{ARB_multitexture} extension is supported, @code{glTexGen}
sets the texture generation parameters for the currently active texture
unit, selected with @code{glActiveTexture}.

@code{GL_INVALID_ENUM} is generated when @var{coord} or @var{pname} is
not an accepted defined value, or when @var{pname} is
@code{GL_TEXTURE_GEN_MODE} and @var{params} is not an accepted defined
value.

@code{GL_INVALID_ENUM} is generated when @var{pname} is
@code{GL_TEXTURE_GEN_MODE}, @var{params} is @code{GL_SPHERE_MAP}, and
@var{coord} is either @code{GL_R} or @code{GL_Q}.

@code{GL_INVALID_OPERATION} is generated if @code{glTexGen} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glTexImage1D target level internalFormat width border format type data
Specify a one-dimensional texture image.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_1D} or
@code{GL_PROXY_TEXTURE_1D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{internalFormat}
Specifies the number of color components in the texture.  Must be 1, 2,
3, or 4, or one of the following symbolic constants: @code{GL_ALPHA},
@code{GL_ALPHA4}, @code{GL_ALPHA8}, @code{GL_ALPHA12},
@code{GL_ALPHA16}, @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB},
@code{GL_COMPRESSED_RGBA}, @code{GL_DEPTH_COMPONENT},
@code{GL_DEPTH_COMPONENT16}, @code{GL_DEPTH_COMPONENT24},
@code{GL_DEPTH_COMPONENT32}, @code{GL_LUMINANCE}, @code{GL_LUMINANCE4},
@code{GL_LUMINANCE8}, @code{GL_LUMINANCE12}, @code{GL_LUMINANCE16},
@code{GL_LUMINANCE_ALPHA}, @code{GL_LUMINANCE4_ALPHA4},
@code{GL_LUMINANCE6_ALPHA2}, @code{GL_LUMINANCE8_ALPHA8},
@code{GL_LUMINANCE12_ALPHA4}, @code{GL_LUMINANCE12_ALPHA12},
@code{GL_LUMINANCE16_ALPHA16}, @code{GL_INTENSITY},
@code{GL_INTENSITY4}, @code{GL_INTENSITY8}, @code{GL_INTENSITY12},
@code{GL_INTENSITY16}, @code{GL_R3_G3_B2}, @code{GL_RGB},
@code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8}, @code{GL_RGB10},
@code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA}, @code{GL_RGBA2},
@code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8}, @code{GL_RGB10_A2},
@code{GL_RGBA12}, @code{GL_RGBA16}, @code{GL_SLUMINANCE},
@code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
@code{GL_SLUMINANCE8_ALPHA8}, @code{GL_SRGB}, @code{GL_SRGB8},
@code{GL_SRGB_ALPHA}, or @code{GL_SRGB8_ALPHA8}.

@item @var{width}
Specifies the width of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  All
implementations support texture images that are at least 64 texels wide.
The height of the 1D texture image is 1.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@item @var{format}
Specifies the format of the pixel data.  The following symbolic values
are accepted: @code{GL_COLOR_INDEX}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR},
@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies the data type of the pixel data.  The following symbolic
values are accepted: @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE},
@code{GL_BITMAP}, @code{GL_UNSIGNED_SHORT}, @code{GL_SHORT},
@code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Specifies a pointer to the image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable one-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_1D}.

Texture images are defined with @code{glTexImage1D}.  The arguments
describe the parameters of the texture image, such as width, width of
the border, level-of-detail number (see @code{glTexParameter}), and the
internal resolution and format used to store the image.  The last three
arguments describe how the image is represented in memory; they are
identical to the pixel formats used for @code{glDrawPixels}.

If @var{target} is @code{GL_PROXY_TEXTURE_1D}, no data is read from
@var{data}, but all of the texture image state is recalculated, checked
for consistency, and checked against the implementation's capabilities.
If the implementation cannot handle a texture of the requested texture
size, it sets all of the image state to 0, but does not generate an
error (see @code{glGetError}).  To query for an entire mipmap array, use
an image array level greater than or equal to 1.

If @var{target} is @code{GL_TEXTURE_1D}, data is read from @var{data} as
a sequence of signed or unsigned bytes, shorts, or longs, or
single-precision floating-point values, depending on @var{type}.  These
values are grouped into sets of one, two, three, or four values,
depending on @var{format}, to form elements.  If @var{type} is
@code{GL_BITMAP}, the data is considered as a string of unsigned bytes
(and @var{format} must be @code{GL_COLOR_INDEX}).  Each data byte is
treated as eight 1-bit elements, with bit ordering determined by
@code{GL_UNPACK_LSB_FIRST} (see @code{glPixelStore}).

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

The first element corresponds to the left end of the texture array.
Subsequent elements progress left-to-right through the remaining texels
in the texture array.  The final element corresponds to the right end of
the texture array.

@var{format} determines the composition of each element in @var{data}.
It can assume one of these symbolic values:

@table @asis
@item @code{GL_COLOR_INDEX}
Each element is a single value, a color index.  The GL converts it to
fixed point (with an unspecified number of zero bits to the right of the
binary point), shifted left or right depending on the value and sign of
@code{GL_INDEX_SHIFT}, and added to @code{GL_INDEX_OFFSET} (see
@code{glPixelTransfer}).  The resulting index is converted to a set of
color components using the @code{GL_PIXEL_MAP_I_TO_R},
@code{GL_PIXEL_MAP_I_TO_G}, @code{GL_PIXEL_MAP_I_TO_B}, and
@code{GL_PIXEL_MAP_I_TO_A} tables, and clamped to the range [0,1].

@item @code{GL_RED}
Each element is a single red component.  The GL converts it to floating
point and assembles it into an RGBA element by attaching 0 for green and
blue, and 1 for alpha.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_GREEN}
Each element is a single green component.  The GL converts it to
floating point and assembles it into an RGBA element by attaching 0 for
red and blue, and 1 for alpha.  Each component is then multiplied by the
signed scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_BLUE}
Each element is a single blue component.  The GL converts it to floating
point and assembles it into an RGBA element by attaching 0 for red and
green, and 1 for alpha.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_ALPHA}
Each element is a single alpha component.  The GL converts it to
floating point and assembles it into an RGBA element by attaching 0 for
red, green, and blue.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_INTENSITY}
Each element is a single intensity value.  The GL converts it to
floating point, then assembles it into an RGBA element by replicating
the intensity value three times for red, green, blue, and alpha.  Each
component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_RGB}
@item @code{GL_BGR}
Each element is an RGB triple.  The GL converts it to floating point and
assembles it into an RGBA element by attaching 1 for alpha.  Each
component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_RGBA}
@item @code{GL_BGRA}
Each element contains all four components.  Each component is multiplied
by the signed scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_LUMINANCE}
Each element is a single luminance value.  The GL converts it to
floating point, then assembles it into an RGBA element by replicating
the luminance value three times for red, green, and blue and attaching 1
for alpha.  Each component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_LUMINANCE_ALPHA}
Each element is a luminance/alpha pair.  The GL converts it to floating
point, then assembles it into an RGBA element by replicating the
luminance value three times for red, green, and blue.  Each component is
then multiplied by the signed scale factor @code{GL_c_SCALE}, added to
the signed bias @code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_DEPTH_COMPONENT}
Each element is a single depth value.  The GL converts it to floating
point, multiplies by the signed scale factor @code{GL_DEPTH_SCALE}, adds
the signed bias @code{GL_DEPTH_BIAS}, and clamps to the range [0,1] (see
@code{glPixelTransfer}).

@end table

Refer to the @code{glDrawPixels} reference page for a description of the
acceptable values for the @var{type} parameter.

If an application wants to store the texture at a certain resolution or
in a certain format, it can request the resolution and format with
@var{internalFormat}.  The GL will choose an internal representation
that closely approximates that requested by @var{internalFormat}, but it
may not match exactly.  (The representations specified by
@code{GL_LUMINANCE}, @code{GL_LUMINANCE_ALPHA}, @code{GL_RGB}, and
@code{GL_RGBA} must match exactly.  The numeric values 1, 2, 3, and 4
may also be used to specify the above representations.)

If the @var{internalFormat} parameter is one of the generic compressed
formats, @code{GL_COMPRESSED_ALPHA}, @code{GL_COMPRESSED_INTENSITY},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_RGB}, or @code{GL_COMPRESSED_RGBA}, the GL will
replace the internal format with the symbolic constant for a specific
internal format and compress the texture before storage.  If no
corresponding internal format is available, or the GL can not compress
that image for any reason, the internal format is instead replaced with
a corresponding base internal format.

If the @var{internalFormat} parameter is @code{GL_SRGB},
@code{GL_SRGB8}, @code{GL_SRGB_ALPHA}, @code{GL_SRGB8_ALPHA8},
@code{GL_SLUMINANCE}, @code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
or @code{GL_SLUMINANCE8_ALPHA8}, the texture is treated as if the red,
green, blue, or luminance components are encoded in the sRGB color
space.  Any alpha component is left unchanged.  The conversion from the
sRGB encoded component @r{@var{c}_@var{s}} to a linear component
@r{@var{c}_@var{l}} is:

@r{@var{c}_@var{l}=@{(@var{c}_@var{s}/12.92 if @var{c}_@var{s}≤0.04045),
((@code{c}_@code{s}+0.055/1.055)^2.4 if @var{c}_@var{s}>0.04045)}

Assume @r{@var{c}_@var{s}} is the sRGB component in the range [0,1].

Use the @code{GL_PROXY_TEXTURE_1D} target to try out a resolution and
format.  The implementation will update and recompute its best match for
the requested storage resolution and format.  To then query this state,
call @code{glGetTexLevelParameter}.  If the texture cannot be
accommodated, texture state is set to 0.

A one-component texture image uses only the red component of the RGBA
color from @var{data}.  A two-component image uses the R and A values.  A
three-component image uses the R, G, and B values.  A four-component
image uses all of the RGBA components.

Depth textures can be treated as LUMINANCE, INTENSITY or ALPHA textures
during texture filtering and application.  Image-based shadowing can be
 enabled by comparing texture r coordinates to depth texture values to
generate a boolean result.  See @code{glTexParameter} for details on
texture comparison.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_TEXTURE_1D} or @code{GL_PROXY_TEXTURE_1D}.

@code{GL_INVALID_ENUM} is generated if @var{format} is not an accepted
format constant.  Format constants other than @code{GL_STENCIL_INDEX}
are accepted.

@code{GL_INVALID_ENUM} is generated if @var{type} is not a type
constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not @code{GL_COLOR_INDEX}.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2⁡(@var{max},)}, where @var{max} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @var{internalFormat} is not 1,
2, 3, 4, or one of the accepted resolution and format symbolic
constants.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than 0 or
greater than 2 + @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if non-power-of-two textures are
not supported and the @var{width} cannot be represented as
@r{2^@var{n}+2⁡(@var{border},)} for some integer value of @var{n}.

@code{GL_INVALID_VALUE} is generated if @var{border} is not 0 or 1.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if @var{format} is
@code{GL_DEPTH_COMPONENT} and @var{internalFormat} is not
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, or @code{GL_DEPTH_COMPONENT32}.

@code{GL_INVALID_OPERATION} is generated if @var{internalFormat} is
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, or @code{GL_DEPTH_COMPONENT32}, and
@var{format} is not @code{GL_DEPTH_COMPONENT}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glTexImage1D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTexImage2D target level internalFormat width height border format type data
Specify a two-dimensional texture image.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_2D},
@code{GL_PROXY_TEXTURE_2D}, @code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or
@code{GL_PROXY_TEXTURE_CUBE_MAP}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{internalFormat}
Specifies the number of color components in the texture.  Must be 1, 2,
3, or 4, or one of the following symbolic constants: @code{GL_ALPHA},
@code{GL_ALPHA4}, @code{GL_ALPHA8}, @code{GL_ALPHA12},
@code{GL_ALPHA16}, @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB},
@code{GL_COMPRESSED_RGBA}, @code{GL_DEPTH_COMPONENT},
@code{GL_DEPTH_COMPONENT16}, @code{GL_DEPTH_COMPONENT24},
@code{GL_DEPTH_COMPONENT32}, @code{GL_LUMINANCE}, @code{GL_LUMINANCE4},
@code{GL_LUMINANCE8}, @code{GL_LUMINANCE12}, @code{GL_LUMINANCE16},
@code{GL_LUMINANCE_ALPHA}, @code{GL_LUMINANCE4_ALPHA4},
@code{GL_LUMINANCE6_ALPHA2}, @code{GL_LUMINANCE8_ALPHA8},
@code{GL_LUMINANCE12_ALPHA4}, @code{GL_LUMINANCE12_ALPHA12},
@code{GL_LUMINANCE16_ALPHA16}, @code{GL_INTENSITY},
@code{GL_INTENSITY4}, @code{GL_INTENSITY8}, @code{GL_INTENSITY12},
@code{GL_INTENSITY16}, @code{GL_R3_G3_B2}, @code{GL_RGB},
@code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8}, @code{GL_RGB10},
@code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA}, @code{GL_RGBA2},
@code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8}, @code{GL_RGB10_A2},
@code{GL_RGBA12}, @code{GL_RGBA16}, @code{GL_SLUMINANCE},
@code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
@code{GL_SLUMINANCE8_ALPHA8}, @code{GL_SRGB}, @code{GL_SRGB8},
@code{GL_SRGB_ALPHA}, or @code{GL_SRGB8_ALPHA8}.

@item @var{width}
Specifies the width of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  All
implementations support texture images that are at least 64 texels wide.

@item @var{height}
Specifies the height of the texture image including the border if any.
If the GL version does not support non-power-of-two sizes, this value
must be @r{2^@var{m}+2⁡(@var{border},)} for some integer @r{@var{m}}.
All implementations support texture images that are at least 64 texels
high.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@item @var{format}
Specifies the format of the pixel data.  The following symbolic values
are accepted: @code{GL_COLOR_INDEX}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR},
@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies the data type of the pixel data.  The following symbolic
values are accepted: @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE},
@code{GL_BITMAP}, @code{GL_UNSIGNED_SHORT}, @code{GL_SHORT},
@code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Specifies a pointer to the image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable two-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_2D}.  To enable and
disable texturing using cube-mapped texture, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_CUBE_MAP}.

To define texture images, call @code{glTexImage2D}.  The arguments
describe the parameters of the texture image, such as height, width,
width of the border, level-of-detail number (see @code{glTexParameter}),
and number of color components provided.  The last three arguments
describe how the image is represented in memory; they are identical to
the pixel formats used for @code{glDrawPixels}.

If @var{target} is @code{GL_PROXY_TEXTURE_2D} or
@code{GL_PROXY_TEXTURE_CUBE_MAP}, no data is read from @var{data}, but
all of the texture image state is recalculated, checked for consistency,
and checked against the implementation's capabilities.  If the
implementation cannot handle a texture of the requested texture size, it
sets all of the image state to 0, but does not generate an error (see
@code{glGetError}).  To query for an entire mipmap array, use an image
array level greater than or equal to 1.

If @var{target} is @code{GL_TEXTURE_2D}, or one of the
@code{GL_TEXTURE_CUBE_MAP} targets, data is read from @var{data} as a
sequence of signed or unsigned bytes, shorts, or longs, or
single-precision floating-point values, depending on @var{type}.  These
values are grouped into sets of one, two, three, or four values,
depending on @var{format}, to form elements.  If @var{type} is
@code{GL_BITMAP}, the data is considered as a string of unsigned bytes
(and @var{format} must be @code{GL_COLOR_INDEX}).  Each data byte is
treated as eight 1-bit elements, with bit ordering determined by
@code{GL_UNPACK_LSB_FIRST} (see @code{glPixelStore}).

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

The first element corresponds to the lower left corner of the texture
image.  Subsequent elements progress left-to-right through the remaining
texels in the lowest row of the texture image, and then in successively
higher rows of the texture image.  The final element corresponds to the
upper right corner of the texture image.

@var{format} determines the composition of each element in @var{data}.
It can assume one of these symbolic values:

@table @asis
@item @code{GL_COLOR_INDEX}
Each element is a single value, a color index.  The GL converts it to
fixed point (with an unspecified number of zero bits to the right of the
binary point), shifted left or right depending on the value and sign of
@code{GL_INDEX_SHIFT}, and added to @code{GL_INDEX_OFFSET} (see
@code{glPixelTransfer}).  The resulting index is converted to a set of
color components using the @code{GL_PIXEL_MAP_I_TO_R},
@code{GL_PIXEL_MAP_I_TO_G}, @code{GL_PIXEL_MAP_I_TO_B}, and
@code{GL_PIXEL_MAP_I_TO_A} tables, and clamped to the range [0,1].

@item @code{GL_RED}
Each element is a single red component.  The GL converts it to floating
point and assembles it into an RGBA element by attaching 0 for green and
blue, and 1 for alpha.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_GREEN}
Each element is a single green component.  The GL converts it to
floating point and assembles it into an RGBA element by attaching 0 for
red and blue, and 1 for alpha.  Each component is then multiplied by the
signed scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_BLUE}
Each element is a single blue component.  The GL converts it to floating
point and assembles it into an RGBA element by attaching 0 for red and
green, and 1 for alpha.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_ALPHA}
Each element is a single alpha component.  The GL converts it to
floating point and assembles it into an RGBA element by attaching 0 for
red, green, and blue.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_INTENSITY}
Each element is a single intensity value.  The GL converts it to
floating point, then assembles it into an RGBA element by replicating
the intensity value three times for red, green, blue, and alpha.  Each
component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_RGB}
@item @code{GL_BGR}
Each element is an RGB triple.  The GL converts it to floating point and
assembles it into an RGBA element by attaching 1 for alpha.  Each
component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_RGBA}
@item @code{GL_BGRA}
Each element contains all four components.  Each component is multiplied
by the signed scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_LUMINANCE}
Each element is a single luminance value.  The GL converts it to
floating point, then assembles it into an RGBA element by replicating
the luminance value three times for red, green, and blue and attaching 1
for alpha.  Each component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_LUMINANCE_ALPHA}
Each element is a luminance/alpha pair.  The GL converts it to floating
point, then assembles it into an RGBA element by replicating the
luminance value three times for red, green, and blue.  Each component is
then multiplied by the signed scale factor @code{GL_c_SCALE}, added to
the signed bias @code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_DEPTH_COMPONENT}
Each element is a single depth value.  The GL converts it to floating
point, multiplies by the signed scale factor @code{GL_DEPTH_SCALE}, adds
the signed bias @code{GL_DEPTH_BIAS}, and clamps to the range [0,1] (see
@code{glPixelTransfer}).

@end table

Refer to the @code{glDrawPixels} reference page for a description of the
acceptable values for the @var{type} parameter.

If an application wants to store the texture at a certain resolution or
in a certain format, it can request the resolution and format with
@var{internalFormat}.  The GL will choose an internal representation
that closely approximates that requested by @var{internalFormat}, but it
may not match exactly.  (The representations specified by
@code{GL_LUMINANCE}, @code{GL_LUMINANCE_ALPHA}, @code{GL_RGB}, and
@code{GL_RGBA} must match exactly.  The numeric values 1, 2, 3, and 4
may also be used to specify the above representations.)

If the @var{internalFormat} parameter is one of the generic compressed
formats, @code{GL_COMPRESSED_ALPHA}, @code{GL_COMPRESSED_INTENSITY},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_RGB}, or @code{GL_COMPRESSED_RGBA}, the GL will
replace the internal format with the symbolic constant for a specific
internal format and compress the texture before storage.  If no
corresponding internal format is available, or the GL can not compress
that image for any reason, the internal format is instead replaced with
a corresponding base internal format.

If the @var{internalFormat} parameter is @code{GL_SRGB},
@code{GL_SRGB8}, @code{GL_SRGB_ALPHA}, @code{GL_SRGB8_ALPHA8},
@code{GL_SLUMINANCE}, @code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
or @code{GL_SLUMINANCE8_ALPHA8}, the texture is treated as if the red,
green, blue, or luminance components are encoded in the sRGB color
space.  Any alpha component is left unchanged.  The conversion from the
sRGB encoded component @r{@var{c}_@var{s}} to a linear component
@r{@var{c}_@var{l}} is:

@r{@var{c}_@var{l}=@{(@var{c}_@var{s}/12.92 if @var{c}_@var{s}≤0.04045),
((@code{c}_@code{s}+0.055/1.055)^2.4 if @var{c}_@var{s}>0.04045)}

Assume @r{@var{c}_@var{s}} is the sRGB component in the range [0,1].

Use the @code{GL_PROXY_TEXTURE_2D} or @code{GL_PROXY_TEXTURE_CUBE_MAP}
target to try out a resolution and format.  The implementation will
update and recompute its best match for the requested storage resolution
and format.  To then query this state, call
@code{glGetTexLevelParameter}.  If the texture cannot be accommodated,
texture state is set to 0.

A one-component texture image uses only the red component of the RGBA
color extracted from @var{data}.  A two-component image uses the R and A
values.  A three-component image uses the R, G, and B values.  A
four-component image uses all of the RGBA components.

Depth textures can be treated as LUMINANCE, INTENSITY or ALPHA textures
during texture filtering and application.  Image-based shadowing can be
 enabled by comparing texture r coordinates to depth texture values to
generate a boolean result.  See @code{glTexParameter} for details on
texture comparison.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_TEXTURE_2D}, @code{GL_PROXY_TEXTURE_2D},
@code{GL_PROXY_TEXTURE_CUBE_MAP}, @code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@code{GL_INVALID_ENUM} is generated if @var{target} is one of the six
cube map 2D image targets and the width and height parameters are not
equal.

@code{GL_INVALID_ENUM} is generated if @var{type} is not a type
constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not @code{GL_COLOR_INDEX}.

@code{GL_INVALID_VALUE} is generated if @var{width} or @var{height} is
less than 0 or greater than 2 + @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2⁡(@var{max},)}, where @var{max} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @var{internalFormat} is not 1,
2, 3, 4, or one of the accepted resolution and format symbolic
constants.

@code{GL_INVALID_VALUE} is generated if @var{width} or @var{height} is
less than 0 or greater than 2 + @code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if non-power-of-two textures are
not supported and the @var{width} or @var{height} cannot be represented
as @r{2^@var{k}+2⁡(@var{border},)} for some integer value of @var{k}.

@code{GL_INVALID_VALUE} is generated if @var{border} is not 0 or 1.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if @var{target} is not
@code{GL_TEXTURE_2D} or @code{GL_PROXY_TEXTURE_2D} and
@var{internalFormat} is @code{GL_DEPTH_COMPONENT},
@code{GL_DEPTH_COMPONENT16}, @code{GL_DEPTH_COMPONENT24}, or
@code{GL_DEPTH_COMPONENT32}.

@code{GL_INVALID_OPERATION} is generated if @var{format} is
@code{GL_DEPTH_COMPONENT} and @var{internalFormat} is not
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, or @code{GL_DEPTH_COMPONENT32}.

@code{GL_INVALID_OPERATION} is generated if @var{internalFormat} is
@code{GL_DEPTH_COMPONENT}, @code{GL_DEPTH_COMPONENT16},
@code{GL_DEPTH_COMPONENT24}, or @code{GL_DEPTH_COMPONENT32}, and
@var{format} is not @code{GL_DEPTH_COMPONENT}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glTexImage2D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTexImage3D target level internalFormat width height depth border format type data
Specify a three-dimensional texture image.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_3D} or
@code{GL_PROXY_TEXTURE_3D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @r{@var{n}} is the @r{@var{n}^@var{th}} mipmap reduction image.

@item @var{internalFormat}
Specifies the number of color components in the texture.  Must be 1, 2,
3, or 4, or one of the following symbolic constants: @code{GL_ALPHA},
@code{GL_ALPHA4}, @code{GL_ALPHA8}, @code{GL_ALPHA12},
@code{GL_ALPHA16}, @code{GL_COMPRESSED_ALPHA},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_INTENSITY}, @code{GL_COMPRESSED_RGB},
@code{GL_COMPRESSED_RGBA}, @code{GL_LUMINANCE}, @code{GL_LUMINANCE4},
@code{GL_LUMINANCE8}, @code{GL_LUMINANCE12}, @code{GL_LUMINANCE16},
@code{GL_LUMINANCE_ALPHA}, @code{GL_LUMINANCE4_ALPHA4},
@code{GL_LUMINANCE6_ALPHA2}, @code{GL_LUMINANCE8_ALPHA8},
@code{GL_LUMINANCE12_ALPHA4}, @code{GL_LUMINANCE12_ALPHA12},
@code{GL_LUMINANCE16_ALPHA16}, @code{GL_INTENSITY},
@code{GL_INTENSITY4}, @code{GL_INTENSITY8}, @code{GL_INTENSITY12},
@code{GL_INTENSITY16}, @code{GL_R3_G3_B2}, @code{GL_RGB},
@code{GL_RGB4}, @code{GL_RGB5}, @code{GL_RGB8}, @code{GL_RGB10},
@code{GL_RGB12}, @code{GL_RGB16}, @code{GL_RGBA}, @code{GL_RGBA2},
@code{GL_RGBA4}, @code{GL_RGB5_A1}, @code{GL_RGBA8}, @code{GL_RGB10_A2},
@code{GL_RGBA12}, @code{GL_RGBA16}, @code{GL_SLUMINANCE},
@code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
@code{GL_SLUMINANCE8_ALPHA8}, @code{GL_SRGB}, @code{GL_SRGB8},
@code{GL_SRGB_ALPHA}, or @code{GL_SRGB8_ALPHA8}.

@item @var{width}
Specifies the width of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{n}+2⁡(@var{border},)} for some integer @r{@var{n}}.  All
implementations support 3D texture images that are at least 16 texels
wide.

@item @var{height}
Specifies the height of the texture image including the border if any.
If the GL version does not support non-power-of-two sizes, this value
must be @r{2^@var{m}+2⁡(@var{border},)} for some integer @r{@var{m}}.
All implementations support 3D texture images that are at least 16
texels high.

@item @var{depth}
Specifies the depth of the texture image including the border if any.  If
the GL version does not support non-power-of-two sizes, this value must
be @r{2^@var{k}+2⁡(@var{border},)} for some integer @r{@var{k}}.  All
implementations support 3D texture images that are at least 16 texels
deep.

@item @var{border}
Specifies the width of the border.  Must be either 0 or 1.

@item @var{format}
Specifies the format of the pixel data.  The following symbolic values
are accepted: @code{GL_COLOR_INDEX}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR},
@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies the data type of the pixel data.  The following symbolic
values are accepted: @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE},
@code{GL_BITMAP}, @code{GL_UNSIGNED_SHORT}, @code{GL_SHORT},
@code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Specifies a pointer to the image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable three-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_3D}.

To define texture images, call @code{glTexImage3D}.  The arguments
describe the parameters of the texture image, such as height, width,
depth, width of the border, level-of-detail number (see
@code{glTexParameter}), and number of color components provided.  The
last three arguments describe how the image is represented in memory;
they are identical to the pixel formats used for @code{glDrawPixels}.

If @var{target} is @code{GL_PROXY_TEXTURE_3D}, no data is read from
@var{data}, but all of the texture image state is recalculated, checked
for consistency, and checked against the implementation's capabilities.
If the implementation cannot handle a texture of the requested texture
size, it sets all of the image state to 0, but does not generate an
error (see @code{glGetError}).  To query for an entire mipmap array, use
an image array level greater than or equal to 1.

If @var{target} is @code{GL_TEXTURE_3D}, data is read from @var{data} as
a sequence of signed or unsigned bytes, shorts, or longs, or
single-precision floating-point values, depending on @var{type}.  These
values are grouped into sets of one, two, three, or four values,
depending on @var{format}, to form elements.  If @var{type} is
@code{GL_BITMAP}, the data is considered as a string of unsigned bytes
(and @var{format} must be @code{GL_COLOR_INDEX}).  Each data byte is
treated as eight 1-bit elements, with bit ordering determined by
@code{GL_UNPACK_LSB_FIRST} (see @code{glPixelStore}).

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

The first element corresponds to the lower left corner of the texture
image.  Subsequent elements progress left-to-right through the remaining
texels in the lowest row of the texture image, and then in successively
higher rows of the texture image.  The final element corresponds to the
upper right corner of the texture image.

@var{format} determines the composition of each element in @var{data}.
It can assume one of these symbolic values:

@table @asis
@item @code{GL_COLOR_INDEX}
Each element is a single value, a color index.  The GL converts it to
fixed point (with an unspecified number of zero bits to the right of the
binary point), shifted left or right depending on the value and sign of
@code{GL_INDEX_SHIFT}, and added to @code{GL_INDEX_OFFSET} (see
@code{glPixelTransfer}).  The resulting index is converted to a set of
color components using the @code{GL_PIXEL_MAP_I_TO_R},
@code{GL_PIXEL_MAP_I_TO_G}, @code{GL_PIXEL_MAP_I_TO_B}, and
@code{GL_PIXEL_MAP_I_TO_A} tables, and clamped to the range [0,1].

@item @code{GL_RED}
Each element is a single red component.  The GL converts it to floating
point and assembles it into an RGBA element by attaching 0 for green and
blue, and 1 for alpha.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_GREEN}
Each element is a single green component.  The GL converts it to
floating point and assembles it into an RGBA element by attaching 0 for
red and blue, and 1 for alpha.  Each component is then multiplied by the
signed scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_BLUE}
Each element is a single blue component.  The GL converts it to floating
point and assembles it into an RGBA element by attaching 0 for red and
green, and 1 for alpha.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_ALPHA}
Each element is a single alpha component.  The GL converts it to
floating point and assembles it into an RGBA element by attaching 0 for
red, green, and blue.  Each component is then multiplied by the signed
scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_INTENSITY}
Each element is a single intensity value.  The GL converts it to
floating point, then assembles it into an RGBA element by replicating
the intensity value three times for red, green, blue, and alpha.  Each
component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_RGB}
@item @code{GL_BGR}
Each element is an RGB triple.  The GL converts it to floating point and
assembles it into an RGBA element by attaching 1 for alpha.  Each
component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_RGBA}
@item @code{GL_BGRA}
Each element contains all four components.  Each component is multiplied
by the signed scale factor @code{GL_c_SCALE}, added to the signed bias
@code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@item @code{GL_LUMINANCE}
Each element is a single luminance value.  The GL converts it to
floating point, then assembles it into an RGBA element by replicating
the luminance value three times for red, green, and blue and attaching 1
for alpha.  Each component is then multiplied by the signed scale factor
@code{GL_c_SCALE}, added to the signed bias @code{GL_c_BIAS}, and
clamped to the range [0,1] (see @code{glPixelTransfer}).

@item @code{GL_LUMINANCE_ALPHA}
Each element is a luminance/alpha pair.  The GL converts it to floating
point, then assembles it into an RGBA element by replicating the
luminance value three times for red, green, and blue.  Each component is
then multiplied by the signed scale factor @code{GL_c_SCALE}, added to
the signed bias @code{GL_c_BIAS}, and clamped to the range [0,1] (see
@code{glPixelTransfer}).

@end table

Refer to the @code{glDrawPixels} reference page for a description of the
acceptable values for the @var{type} parameter.

If an application wants to store the texture at a certain resolution or
in a certain format, it can request the resolution and format with
@var{internalFormat}.  The GL will choose an internal representation
that closely approximates that requested by @var{internalFormat}, but it
may not match exactly.  (The representations specified by
@code{GL_LUMINANCE}, @code{GL_LUMINANCE_ALPHA}, @code{GL_RGB}, and
@code{GL_RGBA} must match exactly.  The numeric values 1, 2, 3, and 4
may also be used to specify the above representations.)

If the @var{internalFormat} parameter is one of the generic compressed
formats, @code{GL_COMPRESSED_ALPHA}, @code{GL_COMPRESSED_INTENSITY},
@code{GL_COMPRESSED_LUMINANCE}, @code{GL_COMPRESSED_LUMINANCE_ALPHA},
@code{GL_COMPRESSED_RGB}, or @code{GL_COMPRESSED_RGBA}, the GL will
replace the internal format with the symbolic constant for a specific
internal format and compress the texture before storage.  If no
corresponding internal format is available, or the GL can not compress
that image for any reason, the internal format is instead replaced with
a corresponding base internal format.

If the @var{internalFormat} parameter is @code{GL_SRGB},
@code{GL_SRGB8}, @code{GL_SRGB_ALPHA}, @code{GL_SRGB8_ALPHA8},
@code{GL_SLUMINANCE}, @code{GL_SLUMINANCE8}, @code{GL_SLUMINANCE_ALPHA},
or @code{GL_SLUMINANCE8_ALPHA8}, the texture is treated as if the red,
green, blue, or luminance components are encoded in the sRGB color
space.  Any alpha component is left unchanged.  The conversion from the
sRGB encoded component @r{@var{c}_@var{s}} to a linear component
@r{@var{c}_@var{l}} is:

@r{@var{c}_@var{l}=@{(@var{c}_@var{s}/12.92 if @var{c}_@var{s}≤0.04045),
((@code{c}_@code{s}+0.055/1.055)^2.4 if @var{c}_@var{s}>0.04045)}

Assume @r{@var{c}_@var{s}} is the sRGB component in the range [0,1].

Use the @code{GL_PROXY_TEXTURE_3D} target to try out a resolution and
format.  The implementation will update and recompute its best match for
the requested storage resolution and format.  To then query this state,
call @code{glGetTexLevelParameter}.  If the texture cannot be
accommodated, texture state is set to 0.

A one-component texture image uses only the red component of the RGBA
color extracted from @var{data}.  A two-component image uses the R and A
values.  A three-component image uses the R, G, and B values.  A
four-component image uses all of the RGBA components.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_TEXTURE_3D} or @code{GL_PROXY_TEXTURE_3D}.

@code{GL_INVALID_ENUM} is generated if @var{format} is not an accepted
format constant.  Format constants other than @code{GL_STENCIL_INDEX}
and @code{GL_DEPTH_COMPONENT} are accepted.

@code{GL_INVALID_ENUM} is generated if @var{type} is not a type
constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not @code{GL_COLOR_INDEX}.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2⁡(@var{max},)}, where @var{max} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @var{internalFormat} is not 1,
2, 3, 4, or one of the accepted resolution and format symbolic
constants.

@code{GL_INVALID_VALUE} is generated if @var{width}, @var{height}, or
@var{depth} is less than 0 or greater than 2 +
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if non-power-of-two textures are
not supported and the @var{width}, @var{height}, or @var{depth} cannot
be represented as @r{2^@var{k}+2⁡(@var{border},)} for some integer value
of @var{k}.

@code{GL_INVALID_VALUE} is generated if @var{border} is not 0 or 1.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if @var{format} or
@var{internalFormat} is @code{GL_DEPTH_COMPONENT},
@code{GL_DEPTH_COMPONENT16}, @code{GL_DEPTH_COMPONENT24}, or
@code{GL_DEPTH_COMPONENT32}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glTexImage3D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTexParameterf target pname param
@deftypefunx void glTexParameteri target pname param
@deftypefunx void glTexParameterfv target pname params
@deftypefunx void glTexParameteriv target pname params
Set texture parameters.

@table @asis
@item @var{target}
Specifies the target texture, which must be either @code{GL_TEXTURE_1D},
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_3D}, or
@code{GL_TEXTURE_CUBE_MAP}.

@item @var{pname}
Specifies the symbolic name of a single-valued texture parameter.
@var{pname} can be one of the following: @code{GL_TEXTURE_MIN_FILTER},
@code{GL_TEXTURE_MAG_FILTER}, @code{GL_TEXTURE_MIN_LOD},
@code{GL_TEXTURE_MAX_LOD}, @code{GL_TEXTURE_BASE_LEVEL},
@code{GL_TEXTURE_MAX_LEVEL}, @code{GL_TEXTURE_WRAP_S},
@code{GL_TEXTURE_WRAP_T}, @code{GL_TEXTURE_WRAP_R},
@code{GL_TEXTURE_PRIORITY}, @code{GL_TEXTURE_COMPARE_MODE},
@code{GL_TEXTURE_COMPARE_FUNC}, @code{GL_DEPTH_TEXTURE_MODE}, or
@code{GL_GENERATE_MIPMAP}.

@item @var{param}
Specifies the value of @var{pname}.

@end table

Texture mapping is a technique that applies an image onto an object's
surface as if the image were a decal or cellophane shrink-wrap.  The
image is created in texture space, with an (@r{@var{s}}, @r{@var{t}})
coordinate system.  A texture is a one- or two-dimensional image and a
set of parameters that determine how samples are derived from the image.

@code{glTexParameter} assigns the value or values in @var{params} to the
texture parameter specified as @var{pname}.  @var{target} defines the
target texture, either @code{GL_TEXTURE_1D}, @code{GL_TEXTURE_2D}, or
@code{GL_TEXTURE_3D}.  The following symbols are accepted in
@var{pname}:

@table @asis
@item @code{GL_TEXTURE_MIN_FILTER}
The texture minifying function is used whenever the pixel being textured
maps to an area greater than one texture element.  There are six defined
minifying functions.  Two of them use the nearest one or nearest four
texture elements to compute the texture value.  The other four use
mipmaps.

A mipmap is an ordered set of arrays representing the same image at
progressively lower resolutions.  If the texture has dimensions
@r{2^@var{n}×2^@var{m}}, there are @r{@var{max}⁡(@var{n},@var{m})+1}
mipmaps.  The first mipmap is the original texture, with dimensions
@r{2^@var{n}×2^@var{m}}.  Each subsequent mipmap has dimensions
@r{2^@var{k}-1,×2^@var{l}-1,}, where @r{2^@var{k}×2^@var{l}} are the
dimensions of the previous mipmap, until either @r{@var{k}=0} or
@r{@var{l}=0}.  At that point, subsequent mipmaps have dimension
@r{1×2^@var{l}-1,} or @r{2^@var{k}-1,×1} until the final mipmap, which
has dimension @r{1×1}.  To define the mipmaps, call @code{glTexImage1D},
@code{glTexImage2D}, @code{glTexImage3D}, @code{glCopyTexImage1D}, or
@code{glCopyTexImage2D} with the @var{level} argument indicating the
order of the mipmaps.  Level 0 is the original texture; level
@r{@var{max}⁡(@var{n},@var{m})} is the final @r{1×1} mipmap.

@var{params} supplies a function for minifying the texture as one of the
following:

As more texture elements are sampled in the minification process, fewer
aliasing artifacts will be apparent.  While the @code{GL_NEAREST} and
@code{GL_LINEAR} minification functions can be faster than the other
four, they sample only one or four texture elements to determine the
texture value of the pixel being rendered and can produce moire patterns
or ragged transitions.  The initial value of
@code{GL_TEXTURE_MIN_FILTER} is @code{GL_NEAREST_MIPMAP_LINEAR}.

@item @code{GL_TEXTURE_MAG_FILTER}
The texture magnification function is used when the pixel being textured
maps to an area less than or equal to one texture element.  It sets the
texture magnification function to either @code{GL_NEAREST} or
@code{GL_LINEAR} (see below).  @code{GL_NEAREST} is generally faster
than @code{GL_LINEAR}, but it can produce textured images with sharper
edges because the transition between texture elements is not as smooth.
The initial value of @code{GL_TEXTURE_MAG_FILTER} is @code{GL_LINEAR}.

@end table

@table @asis
@item @code{GL_NEAREST}
Returns the value of the texture element that is nearest (in Manhattan
distance) to the center of the pixel being textured.

@item @code{GL_LINEAR}
Returns the weighted average of the four texture elements that are
closest to the center of the pixel being textured.  These can include
border texture elements, depending on the values of
@code{GL_TEXTURE_WRAP_S} and @code{GL_TEXTURE_WRAP_T}, and on the exact
mapping.

@item @code{GL_NEAREST_MIPMAP_NEAREST}
Chooses the mipmap that most closely matches the size of the pixel being
textured and uses the @code{GL_NEAREST} criterion (the texture element
nearest to the center of the pixel) to produce a texture value.

@item @code{GL_LINEAR_MIPMAP_NEAREST}
Chooses the mipmap that most closely matches the size of the pixel being
textured and uses the @code{GL_LINEAR} criterion (a weighted average of
the four texture elements that are closest to the center of the pixel)
to produce a texture value.

@item @code{GL_NEAREST_MIPMAP_LINEAR}
Chooses the two mipmaps that most closely match the size of the pixel
being textured and uses the @code{GL_NEAREST} criterion (the texture
element nearest to the center of the pixel) to produce a texture value
from each mipmap.  The final texture value is a weighted average of
those two values.

@item @code{GL_LINEAR_MIPMAP_LINEAR}
Chooses the two mipmaps that most closely match the size of the pixel
being textured and uses the @code{GL_LINEAR} criterion (a weighted
average of the four texture elements that are closest to the center of
the pixel) to produce a texture value from each mipmap.  The final
texture value is a weighted average of those two values.

@end table

@table @asis
@item @code{GL_NEAREST}
Returns the value of the texture element that is nearest (in Manhattan
distance) to the center of the pixel being textured.

@item @code{GL_LINEAR}
Returns the weighted average of the four texture elements that are
closest to the center of the pixel being textured.  These can include
border texture elements, depending on the values of
@code{GL_TEXTURE_WRAP_S} and @code{GL_TEXTURE_WRAP_T}, and on the exact
mapping.

@end table



@table @asis
@item @code{GL_TEXTURE_MIN_LOD}
Sets the minimum level-of-detail parameter.  This floating-point value
limits the selection of highest resolution mipmap (lowest mipmap level).
The initial value is -1000.

@end table



@table @asis
@item @code{GL_TEXTURE_MAX_LOD}
Sets the maximum level-of-detail parameter.  This floating-point value
limits the selection of the lowest resolution mipmap (highest mipmap
level).  The initial value is 1000.

@end table



@table @asis
@item @code{GL_TEXTURE_BASE_LEVEL}
Specifies the index of the lowest defined mipmap level.  This is an
integer value.  The initial value is 0.

@end table



@table @asis
@item @code{GL_TEXTURE_MAX_LEVEL}
Sets the index of the highest defined mipmap level.  This is an integer
value.  The initial value is 1000.

@end table



@table @asis
@item @code{GL_TEXTURE_WRAP_S}
Sets the wrap parameter for texture coordinate @r{@var{s}} to either
@code{GL_CLAMP}, @code{GL_CLAMP_TO_BORDER}, @code{GL_CLAMP_TO_EDGE},
@code{GL_MIRRORED_REPEAT}, or @code{GL_REPEAT}.  @code{GL_CLAMP} causes
@r{@var{s}} coordinates to be clamped to the range [0,1] and is useful
for preventing wrapping artifacts when mapping a single image onto an
object.  @code{GL_CLAMP_TO_BORDER} causes the @r{@var{s}} coordinate to
be clamped to the range @r{[-1/2@var{N},,1+1/2@var{N},]}, where
@r{@var{N}} is the size of the texture in the direction of
clamping.@code{GL_CLAMP_TO_EDGE} causes @r{@var{s}} coordinates to be
clamped to the range @r{[1/2@var{N},,1-1/2@var{N},]}, where @r{@var{N}}
is the size of the texture in the direction of clamping.
@code{GL_REPEAT} causes the integer part of the @r{@var{s}} coordinate
to be ignored; the GL uses only the fractional part, thereby creating a
repeating pattern.  @code{GL_MIRRORED_REPEAT} causes the @r{@var{s}}
coordinate to be set to the fractional part of the texture coordinate if
the integer part of @r{@var{s}} is even; if the integer part of
@r{@var{s}} is odd, then the @r{@var{s}} texture coordinate is set to
@r{1-@var{frac}⁡(@var{s},)}, where @r{@var{frac}⁡(@var{s},)} represents
the fractional part of @r{@var{s}}.  Border texture elements are
accessed only if wrapping is set to @code{GL_CLAMP} or
@code{GL_CLAMP_TO_BORDER}.  Initially, @code{GL_TEXTURE_WRAP_S} is set
to @code{GL_REPEAT}.

@end table



@table @asis
@item @code{GL_TEXTURE_WRAP_T}
Sets the wrap parameter for texture coordinate @r{@var{t}} to either
@code{GL_CLAMP}, @code{GL_CLAMP_TO_BORDER}, @code{GL_CLAMP_TO_EDGE},
@code{GL_MIRRORED_REPEAT}, or @code{GL_REPEAT}.  See the discussion
under @code{GL_TEXTURE_WRAP_S}.  Initially, @code{GL_TEXTURE_WRAP_T} is
set to @code{GL_REPEAT}.

@item @code{GL_TEXTURE_WRAP_R}
Sets the wrap parameter for texture coordinate @r{@var{r}} to either
@code{GL_CLAMP}, @code{GL_CLAMP_TO_BORDER}, @code{GL_CLAMP_TO_EDGE},
@code{GL_MIRRORED_REPEAT}, or @code{GL_REPEAT}.  See the discussion
under @code{GL_TEXTURE_WRAP_S}.  Initially, @code{GL_TEXTURE_WRAP_R} is
set to @code{GL_REPEAT}.

@item @code{GL_TEXTURE_BORDER_COLOR}
Sets a border color.  @var{params} contains four values that comprise
the RGBA color of the texture border.  Integer color components are
interpreted linearly such that the most positive integer maps to 1.0,
and the most negative integer maps to -1.0.  The values are clamped to
the range [0,1] when they are specified.  Initially, the border color is
(0, 0, 0, 0).

@item @code{GL_TEXTURE_PRIORITY}
Specifies the texture residence priority of the currently bound texture.
Permissible values are in the range @r{[0,1]}.  See
@code{glPrioritizeTextures} and @code{glBindTexture} for more
information.

@item @code{GL_TEXTURE_COMPARE_MODE}
Specifies the texture comparison mode for currently bound depth
textures.  That is, a texture whose internal format is
@code{GL_DEPTH_COMPONENT_*}; see @code{glTexImage2D}) Permissible values
are:

@item @code{GL_TEXTURE_COMPARE_FUNC}
Specifies the comparison operator used when
@code{GL_TEXTURE_COMPARE_MODE} is set to @code{GL_COMPARE_R_TO_TEXTURE}.
Permissible values are: where @r{@var{r}} is the current interpolated
texture coordinate, and @r{@var{D}_@var{t}} is the depth texture value
sampled from the currently bound depth texture.  @r{@var{result}} is
assigned to the either the luminance, intensity, or alpha (as specified
by @code{GL_DEPTH_TEXTURE_MODE}.)

@item @code{GL_DEPTH_TEXTURE_MODE}
Specifies a single symbolic constant indicating how depth values should
be treated during filtering and texture application.  Accepted values
are @code{GL_LUMINANCE}, @code{GL_INTENSITY}, and @code{GL_ALPHA}.  The
initial value is @code{GL_LUMINANCE}.

@item @code{GL_GENERATE_MIPMAP}
Specifies a boolean value that indicates if all levels of a mipmap array
should be automatically updated when any modification to the base level
mipmap is done.  The initial value is @code{GL_FALSE}.

@end table

@table @asis
@item @code{GL_COMPARE_R_TO_TEXTURE}
Specifies that the interpolated and clamped @r{@var{r}} texture
coordinate should be compared to the value in the currently bound depth
texture.  See the discussion of @code{GL_TEXTURE_COMPARE_FUNC} for
details of how the comparison is evaluated.  The result of the
comparison is assigned to luminance, intensity, or alpha (as specified
by @code{GL_DEPTH_TEXTURE_MODE}).

@item @code{GL_NONE}
Specifies that the luminance, intensity, or alpha (as specified by
@code{GL_DEPTH_TEXTURE_MODE}) should be assigned the appropriate value
from the currently bound depth texture.

@end table

@table @asis
@item @strong{Texture Comparison Function}
@strong{Computed result}

@item @code{GL_LEQUAL}
@r{@var{result}=@{(1.0), (0.0)⁢ (@var{r}<=@var{D}_@var{t},),
(@var{r}>@var{D}_@var{t},),}

@item @code{GL_GEQUAL}
@r{@var{result}=@{(1.0), (0.0)⁢ (@var{r}>=@var{D}_@var{t},),
(@var{r}<@var{D}_@var{t},),}

@item @code{GL_LESS}
@r{@var{result}=@{(1.0), (0.0)⁢ (@var{r}<@var{D}_@var{t},),
(@var{r}>=@var{D}_@var{t},),}

@item @code{GL_GREATER}
@r{@var{result}=@{(1.0), (0.0)⁢ (@var{r}>@var{D}_@var{t},),
(@var{r}<=@var{D}_@var{t},),}

@item @code{GL_EQUAL}
@r{@var{result}=@{(1.0), (0.0)⁢ (@var{r}=@var{D}_@var{t},),
(@var{r}≠@var{D}_@var{t},),}

@item @code{GL_NOTEQUAL}
@r{@var{result}=@{(1.0), (0.0)⁢ (@var{r}≠@var{D}_@var{t},),
(@var{r}=@var{D}_@var{t},),}

@item @code{GL_ALWAYS}
@r{@var{result}=@code{1.0}}

@item @code{GL_NEVER}
@r{@var{result}=@code{0.0}}

@end table

@code{GL_INVALID_ENUM} is generated if @var{target} or @var{pname} is
not one of the accepted defined values.

@code{GL_INVALID_ENUM} is generated if @var{params} should have a
defined constant value (based on the value of @var{pname}) and does not.

@code{GL_INVALID_OPERATION} is generated if @code{glTexParameter} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTexSubImage1D target level xoffset width format type data
Specify a one-dimensional texture subimage.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_1D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{format}
Specifies the format of the pixel data.  The following symbolic values
are accepted: @code{GL_COLOR_INDEX}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR},
@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies the data type of the pixel data.  The following symbolic
values are accepted: @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE},
@code{GL_BITMAP}, @code{GL_UNSIGNED_SHORT}, @code{GL_SHORT},
@code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Specifies a pointer to the image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable or
disable one-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_1D}.

@code{glTexSubImage1D} redefines a contiguous subregion of an existing
one-dimensional texture image.  The texels referenced by @var{data}
replace the portion of the existing texture array with x indices
@var{xoffset} and @r{@var{xoffset}+@var{width}-1}, inclusive.  This
region may not include any texels outside the range of the texture array
as it was originally specified.  It is not an error to specify a
subtexture with width of 0, but such a specification has no effect.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{target} is not one of the
allowable values.

@code{GL_INVALID_ENUM} is generated if @var{format} is not an accepted
format constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is not a type
constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not @code{GL_COLOR_INDEX}.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2}@var{max}, where @var{max} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @r{@var{xoffset}<-@var{b}}, or
if @r{(@var{xoffset}+@var{width},)>(@var{w}-@var{b},)}, where
@r{@var{w}} is the @code{GL_TEXTURE_WIDTH}, and @r{@var{b}} is the width
of the @code{GL_TEXTURE_BORDER} of the texture image being modified.
Note that @r{@var{w}} includes twice the border width.

@code{GL_INVALID_VALUE} is generated if @var{width} is less than 0.

@code{GL_INVALID_OPERATION} is generated if the texture array has not
been defined by a previous @code{glTexImage1D} operation.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glTexSubImage1D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTexSubImage2D target level xoffset yoffset width height format type data
Specify a two-dimensional texture subimage.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_2D},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{yoffset}
Specifies a texel offset in the y direction within the texture array.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{height}
Specifies the height of the texture subimage.

@item @var{format}
Specifies the format of the pixel data.  The following symbolic values
are accepted: @code{GL_COLOR_INDEX}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR},
@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies the data type of the pixel data.  The following symbolic
values are accepted: @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE},
@code{GL_BITMAP}, @code{GL_UNSIGNED_SHORT}, @code{GL_SHORT},
@code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Specifies a pointer to the image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable two-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_2D}.

@code{glTexSubImage2D} redefines a contiguous subregion of an existing
two-dimensional texture image.  The texels referenced by @var{data}
replace the portion of the existing texture array with x indices
@var{xoffset} and @r{@var{xoffset}+@var{width}-1}, inclusive, and y
indices @var{yoffset} and @r{@var{yoffset}+@var{height}-1}, inclusive.
This region may not include any texels outside the range of the texture
array as it was originally specified.  It is not an error to specify a
subtexture with zero width or height, but such a specification has no
effect.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if @var{target} is not
@code{GL_TEXTURE_2D}, @code{GL_TEXTURE_CUBE_MAP_POSITIVE_X},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_X},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Y},
@code{GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or
@code{GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.

@code{GL_INVALID_ENUM} is generated if @var{format} is not an accepted
format constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is not a type
constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not @code{GL_COLOR_INDEX}.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2}@var{max}, where @var{max} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @r{@var{xoffset}<-@var{b}},
@r{(@var{xoffset}+@var{width},)>(@var{w}-@var{b},)},
@r{@var{yoffset}<-@var{b}}, or
@r{(@var{yoffset}+@var{height},)>(@var{h}-@var{b},)}, where @r{@var{w}}
is the @code{GL_TEXTURE_WIDTH}, @r{@var{h}} is the
@code{GL_TEXTURE_HEIGHT}, and @r{@var{b}} is the border width of the
texture image being modified.  Note that @r{@var{w}} and @r{@var{h}}
include twice the border width.

@code{GL_INVALID_VALUE} is generated if @var{width} or @var{height} is
less than 0.

@code{GL_INVALID_OPERATION} is generated if the texture array has not
been defined by a previous @code{glTexImage2D} operation.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glTexSubImage2D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTexSubImage3D target level xoffset yoffset zoffset width height depth format type data
Specify a three-dimensional texture subimage.

@table @asis
@item @var{target}
Specifies the target texture.  Must be @code{GL_TEXTURE_3D}.

@item @var{level}
Specifies the level-of-detail number.  Level 0 is the base image level.
Level @var{n} is the @var{n}th mipmap reduction image.

@item @var{xoffset}
Specifies a texel offset in the x direction within the texture array.

@item @var{yoffset}
Specifies a texel offset in the y direction within the texture array.

@item @var{zoffset}
Specifies a texel offset in the z direction within the texture array.

@item @var{width}
Specifies the width of the texture subimage.

@item @var{height}
Specifies the height of the texture subimage.

@item @var{depth}
Specifies the depth of the texture subimage.

@item @var{format}
Specifies the format of the pixel data.  The following symbolic values
are accepted: @code{GL_COLOR_INDEX}, @code{GL_RED}, @code{GL_GREEN},
@code{GL_BLUE}, @code{GL_ALPHA}, @code{GL_RGB}, @code{GL_BGR},
@code{GL_RGBA}, @code{GL_BGRA}, @code{GL_LUMINANCE}, and
@code{GL_LUMINANCE_ALPHA}.

@item @var{type}
Specifies the data type of the pixel data.  The following symbolic
values are accepted: @code{GL_UNSIGNED_BYTE}, @code{GL_BYTE},
@code{GL_BITMAP}, @code{GL_UNSIGNED_SHORT}, @code{GL_SHORT},
@code{GL_UNSIGNED_INT}, @code{GL_INT}, @code{GL_FLOAT},
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, @code{GL_UNSIGNED_SHORT_5_6_5_REV},
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, and
@code{GL_UNSIGNED_INT_2_10_10_10_REV}.

@item @var{data}
Specifies a pointer to the image data in memory.

@end table

Texturing maps a portion of a specified texture image onto each
graphical primitive for which texturing is enabled.  To enable and
disable three-dimensional texturing, call @code{glEnable} and
@code{glDisable} with argument @code{GL_TEXTURE_3D}.

@code{glTexSubImage3D} redefines a contiguous subregion of an existing
three-dimensional texture image.  The texels referenced by @var{data}
replace the portion of the existing texture array with x indices
@var{xoffset} and @r{@var{xoffset}+@var{width}-1}, inclusive, y indices
@var{yoffset} and @r{@var{yoffset}+@var{height}-1}, inclusive, and z
indices @var{zoffset} and @r{@var{zoffset}+@var{depth}-1}, inclusive.
This region may not include any texels outside the range of the texture
array as it was originally specified.  It is not an error to specify a
subtexture with zero width, height, or depth but such a specification
has no effect.

If a non-zero named buffer object is bound to the
@code{GL_PIXEL_UNPACK_BUFFER} target (see @code{glBindBuffer}) while a
texture image is specified, @var{data} is treated as a byte offset into
the buffer object's data store.

@code{GL_INVALID_ENUM} is generated if /@var{target} is not
@code{GL_TEXTURE_3D}.

@code{GL_INVALID_ENUM} is generated if @var{format} is not an accepted
format constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is not a type
constant.

@code{GL_INVALID_ENUM} is generated if @var{type} is @code{GL_BITMAP}
and @var{format} is not @code{GL_COLOR_INDEX}.

@code{GL_INVALID_VALUE} is generated if @var{level} is less than 0.

@code{GL_INVALID_VALUE} may be generated if @var{level} is greater than
@r{@var{log}_2}@var{max}, where @var{max} is the returned value of
@code{GL_MAX_TEXTURE_SIZE}.

@code{GL_INVALID_VALUE} is generated if @r{@var{xoffset}<-@var{b}},
@r{(@var{xoffset}+@var{width},)>(@var{w}-@var{b},)},
@r{@var{yoffset}<-@var{b}}, or
@r{(@var{yoffset}+@var{height},)>(@var{h}-@var{b},)}, or
@r{@var{zoffset}<-@var{b}}, or
@r{(@var{zoffset}+@var{depth},)>(@var{d}-@var{b},)}, where @r{@var{w}}
is the @code{GL_TEXTURE_WIDTH}, @r{@var{h}} is the
@code{GL_TEXTURE_HEIGHT}, @r{@var{d}} is the @code{GL_TEXTURE_DEPTH} and
@r{@var{b}} is the border width of the texture image being modified.
Note that @r{@var{w}}, @r{@var{h}}, and @r{@var{d}} include twice the
border width.

@code{GL_INVALID_VALUE} is generated if @var{width}, @var{height}, or
@var{depth} is less than 0.

@code{GL_INVALID_OPERATION} is generated if the texture array has not
been defined by a previous @code{glTexImage3D} operation.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_BYTE_3_3_2}, @code{GL_UNSIGNED_BYTE_2_3_3_REV},
@code{GL_UNSIGNED_SHORT_5_6_5}, or @code{GL_UNSIGNED_SHORT_5_6_5_REV}
and @var{format} is not @code{GL_RGB}.

@code{GL_INVALID_OPERATION} is generated if @var{type} is one of
@code{GL_UNSIGNED_SHORT_4_4_4_4}, @code{GL_UNSIGNED_SHORT_4_4_4_4_REV},
@code{GL_UNSIGNED_SHORT_5_5_5_1}, @code{GL_UNSIGNED_SHORT_1_5_5_5_REV},
@code{GL_UNSIGNED_INT_8_8_8_8}, @code{GL_UNSIGNED_INT_8_8_8_8_REV},
@code{GL_UNSIGNED_INT_10_10_10_2}, or
@code{GL_UNSIGNED_INT_2_10_10_10_REV} and @var{format} is neither
@code{GL_RGBA} nor @code{GL_BGRA}.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the buffer
object's data store is currently mapped.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and the data
would be unpacked from the buffer object such that the memory reads
required would exceed the data store size.

@code{GL_INVALID_OPERATION} is generated if a non-zero buffer object
name is bound to the @code{GL_PIXEL_UNPACK_BUFFER} target and @var{data}
is not evenly divisible into the number of bytes needed to store in
memory a datum indicated by @var{type}.

@code{GL_INVALID_OPERATION} is generated if @code{glTexSubImage3D} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glTranslated x y z
@deftypefunx void glTranslatef x y z
Multiply the current matrix by a translation matrix.

@table @asis
@item @var{x}
@itemx @var{y}
@itemx @var{z}
Specify the @var{x}, @var{y}, and @var{z} coordinates of a translation
vector.

@end table

@code{glTranslate} produces a translation by
@r{(@var{x},@var{y}@var{z})}.  The current matrix (see
@code{glMatrixMode}) is multiplied by this translation matrix, with the
product replacing the current matrix, as if @code{glMultMatrix} were
called with the following matrix for its argument:

@r{((1 0 0 @var{x}), (0 1 0 @var{y}), (0 0 1 @var{z}), (0 0 0 1),)}



If the matrix mode is either @code{GL_MODELVIEW} or
@code{GL_PROJECTION}, all objects drawn after a call to
@code{glTranslate} are translated.

Use @code{glPushMatrix} and @code{glPopMatrix} to save and restore the
untranslated coordinate system.

@code{GL_INVALID_OPERATION} is generated if @code{glTranslate} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glUniform1f location v0
@deftypefunx void glUniform2f location v0 v1
@deftypefunx void glUniform3f location v0 v1 v2
@deftypefunx void glUniform4f location v0 v1 v2 v3
@deftypefunx void glUniform1i location v0
@deftypefunx void glUniform2i location v0 v1
@deftypefunx void glUniform3i location v0 v1 v2
@deftypefunx void glUniform4i location v0 v1 v2 v3
@deftypefunx void glUniform1fv location count value
@deftypefunx void glUniform2fv location count value
@deftypefunx void glUniform3fv location count value
@deftypefunx void glUniform4fv location count value
@deftypefunx void glUniform1iv location count value
@deftypefunx void glUniform2iv location count value
@deftypefunx void glUniform3iv location count value
@deftypefunx void glUniform4iv location count value
@deftypefunx void glUniformMatrix2fv location count transpose value
@deftypefunx void glUniformMatrix3fv location count transpose value
@deftypefunx void glUniformMatrix4fv location count transpose value
@deftypefunx void glUniformMatrix2x3fv location count transpose value
@deftypefunx void glUniformMatrix3x2fv location count transpose value
@deftypefunx void glUniformMatrix2x4fv location count transpose value
@deftypefunx void glUniformMatrix4x2fv location count transpose value
@deftypefunx void glUniformMatrix3x4fv location count transpose value
@deftypefunx void glUniformMatrix4x3fv location count transpose value
Specify the value of a uniform variable for the current program object.

@table @asis
@item @var{location}
Specifies the location of the uniform variable to be modified.

@item @var{v0}, @var{v1}, @var{v2}, @var{v3}
Specifies the new values to be used for the specified uniform variable.

@end table

@code{glUniform} modifies the value of a uniform variable or a uniform
variable array.  The location of the uniform variable to be modified is
specified by @var{location}, which should be a value returned by
@code{glGetUniformLocation}.  @code{glUniform} operates on the program
object that was made part of current state by calling
@code{glUseProgram}.

The commands @code{glUniform@{1|2|3|4@}@{f|i@}} are used to change the
value of the uniform variable specified by @var{location} using the
values passed as arguments.  The number specified in the command should
match the number of components in the data type of the specified uniform
variable (e.g., @code{1} for float, int, bool; @code{2} for vec2, ivec2,
bvec2, etc.).  The suffix @code{f} indicates that floating-point values
are being passed; the suffix @code{i} indicates that integer values are
being passed, and this type should also match the data type of the
specified uniform variable.  The @code{i} variants of this function
should be used to provide values for uniform variables defined as int,
ivec2, ivec3, ivec4, or arrays of these.  The @code{f} variants should
be used to provide values for uniform variables of type float, vec2,
vec3, vec4, or arrays of these.  Either the @code{i} or the @code{f}
variants may be used to provide values for uniform variables of type
bool, bvec2, bvec3, bvec4, or arrays of these.  The uniform variable
will be set to false if the input value is 0 or 0.0f, and it will be set
to true otherwise.

All active uniform variables defined in a program object are initialized
to 0 when the program object is linked successfully.  They retain the
values assigned to them by a call to @code{glUniform } until the next
successful link operation occurs on the program object, when they are
once again initialized to 0.

The commands @code{glUniform@{1|2|3|4@}@{f|i@}v} can be used to modify a
single uniform variable or a uniform variable array.  These commands
pass a count and a pointer to the values to be loaded into a uniform
variable or a uniform variable array.  A count of 1 should be used if
modifying the value of a single uniform variable, and a count of 1 or
greater can be used to modify an entire array or part of an array.  When
loading @var{n} elements starting at an arbitrary position @var{m} in a
uniform variable array, elements @var{m} + @var{n} - 1 in the array will
be replaced with the new values.  If @var{m} + @var{n} - 1 is larger
than the size of the uniform variable array, values for all array
elements beyond the end of the array will be ignored.  The number
specified in the name of the command indicates the number of components
for each element in @var{value}, and it should match the number of
components in the data type of the specified uniform variable (e.g.,
@code{1} for float, int, bool; @code{2} for vec2, ivec2, bvec2, etc.).
The data type specified in the name of the command must match the data
type for the specified uniform variable as described previously for
@code{glUniform@{1|2|3|4@}@{f|i@}}.

For uniform variable arrays, each element of the array is considered to
be of the type indicated in the name of the command (e.g.,
@code{glUniform3f} or @code{glUniform3fv} can be used to load a uniform
variable array of type vec3).  The number of elements of the uniform
variable array to be modified is specified by @var{count}

The commands @code{glUniformMatrix@{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3@}fv}
are used to modify a matrix or an array of matrices.  The numbers in the
command name are interpreted as the dimensionality of the matrix.  The
number @code{2} indicates a 2 × 2 matrix (i.e., 4 values), the number
@code{3} indicates a 3 × 3 matrix (i.e., 9 values), and the number
@code{4} indicates a 4 × 4 matrix (i.e., 16 values).  Non-square matrix
dimensionality is explicit, with the first number representing the
number of columns and the second number representing the number of rows.
For example, @code{2x4} indicates a 2 × 4 matrix with 2 columns and 4
rows (i.e., 8 values).  If @var{transpose} is @code{GL_FALSE}, each
matrix is assumed to be supplied in column major order.  If
@var{transpose} is @code{GL_TRUE}, each matrix is assumed to be supplied
in row major order.  The @var{count} argument indicates the number of
matrices to be passed.  A count of 1 should be used if modifying the
value of a single matrix, and a count greater than 1 can be used to
modify an array of matrices.

@code{GL_INVALID_OPERATION} is generated if there is no current program
object.

@code{GL_INVALID_OPERATION} is generated if the size of the uniform
variable declared in the shader does not match the size indicated by the
@code{glUniform} command.

@code{GL_INVALID_OPERATION} is generated if one of the integer variants
of this function is used to load a uniform variable of type float, vec2,
vec3, vec4, or an array of these, or if one of the floating-point
variants of this function is used to load a uniform variable of type
int, ivec2, ivec3, or ivec4, or an array of these.

@code{GL_INVALID_OPERATION} is generated if @var{location} is an invalid
uniform location for the current program object and @var{location} is
not equal to -1.

@code{GL_INVALID_VALUE} is generated if @var{count} is less than 0.

@code{GL_INVALID_OPERATION} is generated if @var{count} is greater than
1 and the indicated uniform variable is not an array variable.

@code{GL_INVALID_OPERATION} is generated if a sampler is loaded using a
command other than @code{glUniform1i} and @code{glUniform1iv}.

@code{GL_INVALID_OPERATION} is generated if @code{glUniform} is executed
between the execution of @code{glBegin} and the corresponding execution
of @code{glEnd}.

@end deftypefun

@deftypefun void glUseProgram program
Installs a program object as part of current rendering state.

@table @asis
@item @var{program}
Specifies the handle of the program object whose executables are to be
used as part of current rendering state.

@end table

@code{glUseProgram} installs the program object specified by
@var{program} as part of current rendering state.  One or more
executables are created in a program object by successfully attaching
shader objects to it with @code{glAttachShader}, successfully compiling
the shader objects with @code{glCompileShader}, and successfully linking
the program object with @code{glLinkProgram}.

A program object will contain an executable that will run on the vertex
processor if it contains one or more shader objects of type
@code{GL_VERTEX_SHADER} that have been successfully compiled and linked.
Similarly, a program object will contain an executable that will run on
the fragment processor if it contains one or more shader objects of type
@code{GL_FRAGMENT_SHADER} that have been successfully compiled and
linked.

Successfully installing an executable on a programmable processor will
cause the corresponding fixed functionality of OpenGL to be disabled.
Specifically, if an executable is installed on the vertex processor, the
OpenGL fixed functionality will be disabled as follows.

@itemize 
@item
The modelview matrix is not applied to vertex coordinates.

@item
The projection matrix is not applied to vertex coordinates.

@item
The texture matrices are not applied to texture coordinates.

@item
Normals are not transformed to eye coordinates.

@item
Normals are not rescaled or normalized.

@item
Normalization of @code{GL_AUTO_NORMAL} evaluated normals is not
performed.

@item
Texture coordinates are not generated automatically.

@item
Per-vertex lighting is not performed.

@item
Color material computations are not performed.

@item
Color index lighting is not performed.

@item
This list also applies when setting the current raster position.

@end itemize

The executable that is installed on the vertex processor is expected to
implement any or all of the desired functionality from the preceding
list.  Similarly, if an executable is installed on the fragment
processor, the OpenGL fixed functionality will be disabled as follows.

@itemize 
@item
Texture environment and texture functions are not applied.

@item
Texture application is not applied.

@item
Color sum is not applied.

@item
Fog is not applied.

@end itemize

Again, the fragment shader that is installed is expected to implement
any or all of the desired functionality from the preceding list.

While a program object is in use, applications are free to modify
attached shader objects, compile attached shader objects, attach
additional shader objects, and detach or delete shader objects.  None of
these operations will affect the executables that are part of the
current state.  However, relinking the program object that is currently
in use will install the program object as part of the current rendering
state if the link operation was successful (see @code{glLinkProgram} ).
If the program object currently in use is relinked unsuccessfully, its
link status will be set to @code{GL_FALSE}, but the executables and
associated state will remain part of the current state until a
subsequent call to @code{glUseProgram} removes it from use.  After it is
removed from use, it cannot be made part of current state until it has
been successfully relinked.

If @var{program} contains shader objects of type @code{GL_VERTEX_SHADER}
but it does not contain shader objects of type
@code{GL_FRAGMENT_SHADER}, an executable will be installed on the vertex
processor, but fixed functionality will be used for fragment processing.
Similarly, if @var{program} contains shader objects of type
@code{GL_FRAGMENT_SHADER} but it does not contain shader objects of type
@code{GL_VERTEX_SHADER}, an executable will be installed on the fragment
processor, but fixed functionality will be used for vertex processing.
If @var{program} is 0, the programmable processors will be disabled, and
fixed functionality will be used for both vertex and fragment
processing.

@code{GL_INVALID_VALUE} is generated if @var{program} is neither 0 nor a
value generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @var{program} could not be
made part of current state.

@code{GL_INVALID_OPERATION} is generated if @code{glUseProgram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glValidateProgram program
Validates a program object.

@table @asis
@item @var{program}
Specifies the handle of the program object to be validated.

@end table

@code{glValidateProgram} checks to see whether the executables contained
in @var{program} can execute given the current OpenGL state.  The
information generated by the validation process will be stored in
@var{program}'s information log.  The validation information may consist
of an empty string, or it may be a string containing information about
how the current program object interacts with the rest of current OpenGL
state.  This provides a way for OpenGL implementers to convey more
information about why the current program is inefficient, suboptimal,
failing to execute, and so on.

The status of the validation operation will be stored as part of the
program object's state.  This value will be set to @code{GL_TRUE} if the
validation succeeded, and @code{GL_FALSE} otherwise.  It can be queried
by calling @code{glGetProgram} with arguments @var{program} and
@code{GL_VALIDATE_STATUS}.  If validation is successful, @var{program}
is guaranteed to execute given the current state.  Otherwise,
@var{program} is guaranteed to not execute.

This function is typically useful only during application development.
The informational string stored in the information log is completely
implementation dependent; therefore, an application should not expect
different OpenGL implementations to produce identical information
strings.

@code{GL_INVALID_VALUE} is generated if @var{program} is not a value
generated by OpenGL.

@code{GL_INVALID_OPERATION} is generated if @var{program} is not a
program object.

@code{GL_INVALID_OPERATION} is generated if @code{glValidateProgram} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glVertexAttribPointer index size type normalized stride pointer
Define an array of generic vertex attribute data.

@table @asis
@item @var{index}
Specifies the index of the generic vertex attribute to be modified.

@item @var{size}
Specifies the number of components per generic vertex attribute.  Must
be 1, 2, 3, or 4.  The initial value is 4.

@item @var{type}
Specifies the data type of each component in the array.  Symbolic
constants @code{GL_BYTE}, @code{GL_UNSIGNED_BYTE}, @code{GL_SHORT},
@code{GL_UNSIGNED_SHORT}, @code{GL_INT}, @code{GL_UNSIGNED_INT},
@code{GL_FLOAT}, or @code{GL_DOUBLE} are accepted.  The initial value is
@code{GL_FLOAT}.

@item @var{normalized}
Specifies whether fixed-point data values should be normalized
(@code{GL_TRUE}) or converted directly as fixed-point values
(@code{GL_FALSE}) when they are accessed.

@item @var{stride}
Specifies the byte offset between consecutive generic vertex attributes.
If @var{stride} is 0, the generic vertex attributes are understood to be
tightly packed in the array.  The initial value is 0.

@item @var{pointer}
Specifies a pointer to the first component of the first generic vertex
attribute in the array.  The initial value is 0.

@end table

@code{glVertexAttribPointer} specifies the location and data format of
the array of generic vertex attributes at index @var{index} to use when
rendering.  @var{size} specifies the number of components per attribute
and must be 1, 2, 3, or 4.  @var{type} specifies the data type of each
component, and @var{stride} specifies the byte stride from one attribute
to the next, allowing vertices and attributes to be packed into a single
array or stored in separate arrays.  If set to @code{GL_TRUE},
@var{normalized} indicates that values stored in an integer format are
to be mapped to the range [-1,1] (for signed values) or [0,1] (for
unsigned values) when they are accessed and converted to floating point.
Otherwise, values will be converted to floats directly without
normalization.

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a generic vertex attribute array
is specified, @var{pointer} is treated as a byte offset into the buffer
object's data store.  Also, the buffer object binding
(@code{GL_ARRAY_BUFFER_BINDING}) is saved as generic vertex attribute
array client-side state (@code{GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING})
for index @var{index}.

When a generic vertex attribute array is specified, @var{size},
@var{type}, @var{normalized}, @var{stride}, and @var{pointer} are saved
as client-side state, in addition to the current vertex array buffer
object binding.

To enable and disable a generic vertex attribute array, call
@code{glEnableVertexAttribArray} and @code{glDisableVertexAttribArray}
with @var{index}.  If enabled, the generic vertex attribute array is
used when @code{glArrayElement}, @code{glDrawArrays},
@code{glMultiDrawArrays}, @code{glDrawElements},
@code{glMultiDrawElements}, or @code{glDrawRangeElements} is called.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to @code{GL_MAX_VERTEX_ATTRIBS}.

@code{GL_INVALID_VALUE} is generated if @var{size} is not 1, 2, 3, or 4.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glVertexAttrib1f index v0
@deftypefunx void glVertexAttrib1s index v0
@deftypefunx void glVertexAttrib1d index v0
@deftypefunx void glVertexAttrib2f index v0 v1
@deftypefunx void glVertexAttrib2s index v0 v1
@deftypefunx void glVertexAttrib2d index v0 v1
@deftypefunx void glVertexAttrib3f index v0 v1 v2
@deftypefunx void glVertexAttrib3s index v0 v1 v2
@deftypefunx void glVertexAttrib3d index v0 v1 v2
@deftypefunx void glVertexAttrib4f index v0 v1 v2 v3
@deftypefunx void glVertexAttrib4s index v0 v1 v2 v3
@deftypefunx void glVertexAttrib4d index v0 v1 v2 v3
@deftypefunx void glVertexAttrib4Nub index v0 v1 v2 v3
@deftypefunx void glVertexAttrib1fv index v
@deftypefunx void glVertexAttrib1sv index v
@deftypefunx void glVertexAttrib1dv index v
@deftypefunx void glVertexAttrib2fv index v
@deftypefunx void glVertexAttrib2sv index v
@deftypefunx void glVertexAttrib2dv index v
@deftypefunx void glVertexAttrib3fv index v
@deftypefunx void glVertexAttrib3sv index v
@deftypefunx void glVertexAttrib3dv index v
@deftypefunx void glVertexAttrib4fv index v
@deftypefunx void glVertexAttrib4sv index v
@deftypefunx void glVertexAttrib4dv index v
@deftypefunx void glVertexAttrib4iv index v
@deftypefunx void glVertexAttrib4bv index v
@deftypefunx void glVertexAttrib4ubv index v
@deftypefunx void glVertexAttrib4usv index v
@deftypefunx void glVertexAttrib4uiv index v
@deftypefunx void glVertexAttrib4Nbv index v
@deftypefunx void glVertexAttrib4Nsv index v
@deftypefunx void glVertexAttrib4Niv index v
@deftypefunx void glVertexAttrib4Nubv index v
@deftypefunx void glVertexAttrib4Nusv index v
@deftypefunx void glVertexAttrib4Nuiv index v
Specifies the value of a generic vertex attribute.

@table @asis
@item @var{index}
Specifies the index of the generic vertex attribute to be modified.

@item @var{v0}, @var{v1}, @var{v2}, @var{v3}
Specifies the new values to be used for the specified vertex attribute.

@end table

OpenGL defines a number of standard vertex attributes that applications
can modify with standard API entry points (color, normal, texture
coordinates, etc.).  The @code{glVertexAttrib} family of entry points
allows an application to pass generic vertex attributes in numbered
locations.

Generic attributes are defined as four-component values that are
organized into an array.  The first entry of this array is numbered 0,
and the size of the array is specified by the implementation-dependent
constant @code{GL_MAX_VERTEX_ATTRIBS}.  Individual elements of this
array can be modified with a @code{glVertexAttrib} call that specifies
the index of the element to be modified and a value for that element.

These commands can be used to specify one, two, three, or all four
components of the generic vertex attribute specified by @var{index}.  A
@code{1} in the name of the command indicates that only one value is
passed, and it will be used to modify the first component of the generic
vertex attribute.  The second and third components will be set to 0, and
the fourth component will be set to 1.  Similarly, a @code{2} in the
name of the command indicates that values are provided for the first two
components, the third component will be set to 0, and the fourth
component will be set to 1.  A @code{3} in the name of the command
indicates that values are provided for the first three components and
the fourth component will be set to 1, whereas a @code{4} in the name
indicates that values are provided for all four components.

The letters @code{s}, @code{f}, @code{i}, @code{d}, @code{ub},
@code{us}, and @code{ui} indicate whether the arguments are of type
short, float, int, double, unsigned byte, unsigned short, or unsigned
int.  When @code{v} is appended to the name, the commands can take a
pointer to an array of such values.  The commands containing @code{N}
indicate that the arguments will be passed as fixed-point values that
are scaled to a normalized range according to the component conversion
rules defined by the OpenGL specification.  Signed values are understood
to represent fixed-point values in the range [-1,1], and unsigned values
are understood to represent fixed-point values in the range [0,1].

OpenGL Shading Language attribute variables are allowed to be of type
mat2, mat3, or mat4.  Attributes of these types may be loaded using the
@code{glVertexAttrib} entry points.  Matrices must be loaded into
successive generic attribute slots in column major order, with one
column of the matrix in each generic attribute slot.

A user-defined attribute variable declared in a vertex shader can be
bound to a generic attribute index by calling
@code{glBindAttribLocation}.  This allows an application to use more
descriptive variable names in a vertex shader.  A subsequent change to
the specified generic vertex attribute will be immediately reflected as
a change to the corresponding attribute variable in the vertex shader.

The binding between a generic vertex attribute index and a user-defined
attribute variable in a vertex shader is part of the state of a program
object, but the current value of the generic vertex attribute is not.
The value of each generic vertex attribute is part of current state,
just like standard vertex attributes, and it is maintained even if a
different program object is used.

An application may freely modify generic vertex attributes that are not
bound to a named vertex shader attribute variable.  These values are
simply maintained as part of current state and will not be accessed by
the vertex shader.  If a generic vertex attribute bound to an attribute
variable in a vertex shader is not updated while the vertex shader is
executing, the vertex shader will repeatedly use the current value for
the generic vertex attribute.

The generic vertex attribute with index 0 is the same as the vertex
position attribute previously defined by OpenGL.  A @code{glVertex2},
@code{glVertex3}, or @code{glVertex4} command is completely equivalent
to the corresponding @code{glVertexAttrib} command with an index
argument of 0.  A vertex shader can access generic vertex attribute 0 by
using the built-in attribute variable @var{gl_Vertex}.  There are no
current values for generic vertex attribute 0.  This is the only generic
vertex attribute with this property; calls to set other standard vertex
attributes can be freely mixed with calls to set any of the other
generic vertex attributes.

@code{GL_INVALID_VALUE} is generated if @var{index} is greater than or
equal to @code{GL_MAX_VERTEX_ATTRIBS}.

@end deftypefun

@deftypefun void glVertexPointer size type stride pointer
Define an array of vertex data.

@table @asis
@item @var{size}
Specifies the number of coordinates per vertex.  Must be 2, 3, or 4.  The
initial value is 4.

@item @var{type}
Specifies the data type of each coordinate in the array.  Symbolic
constants @code{GL_SHORT}, @code{GL_INT}, @code{GL_FLOAT}, or
@code{GL_DOUBLE} are accepted.  The initial value is @code{GL_FLOAT}.

@item @var{stride}
Specifies the byte offset between consecutive vertices.  If @var{stride}
is 0, the vertices are understood to be tightly packed in the array.  The
initial value is 0.

@item @var{pointer}
Specifies a pointer to the first coordinate of the first vertex in the
array.  The initial value is 0.

@end table

@code{glVertexPointer} specifies the location and data format of an
array of vertex coordinates to use when rendering.  @var{size} specifies
the number of coordinates per vertex, and must be 2, 3, or 4.  @var{type}
specifies the data type of each coordinate, and @var{stride} specifies
the byte stride from one vertex to the next, allowing vertices and
attributes to be packed into a single array or stored in separate
arrays.  (Single-array storage may be more efficient on some
implementations; see @code{glInterleavedArrays}.)

If a non-zero named buffer object is bound to the @code{GL_ARRAY_BUFFER}
target (see @code{glBindBuffer}) while a vertex array is specified,
@var{pointer} is treated as a byte offset into the buffer object's data
store.  Also, the buffer object binding (@code{GL_ARRAY_BUFFER_BINDING})
is saved as vertex array client-side state
(@code{GL_VERTEX_ARRAY_BUFFER_BINDING}).

When a vertex array is specified, @var{size}, @var{type}, @var{stride},
and @var{pointer} are saved as client-side state, in addition to the
current vertex array buffer object binding.

To enable and disable the vertex array, call @code{glEnableClientState}
and @code{glDisableClientState} with the argument
@code{GL_VERTEX_ARRAY}.  If enabled, the vertex array is used when
@code{glArrayElement}, @code{glDrawArrays}, @code{glMultiDrawArrays},
@code{glDrawElements}, @code{glMultiDrawElements}, or
@code{glDrawRangeElements} is called.

@code{GL_INVALID_VALUE} is generated if @var{size} is not 2, 3, or 4.

@code{GL_INVALID_ENUM} is generated if @var{type} is not an accepted
value.

@code{GL_INVALID_VALUE} is generated if @var{stride} is negative.

@end deftypefun

@deftypefun void glVertex2s x y
@deftypefunx void glVertex2i x y
@deftypefunx void glVertex2f x y
@deftypefunx void glVertex2d x y
@deftypefunx void glVertex3s x y z
@deftypefunx void glVertex3i x y z
@deftypefunx void glVertex3f x y z
@deftypefunx void glVertex3d x y z
@deftypefunx void glVertex4s x y z w
@deftypefunx void glVertex4i x y z w
@deftypefunx void glVertex4f x y z w
@deftypefunx void glVertex4d x y z w
@deftypefunx void glVertex2sv v
@deftypefunx void glVertex2iv v
@deftypefunx void glVertex2fv v
@deftypefunx void glVertex2dv v
@deftypefunx void glVertex3sv v
@deftypefunx void glVertex3iv v
@deftypefunx void glVertex3fv v
@deftypefunx void glVertex3dv v
@deftypefunx void glVertex4sv v
@deftypefunx void glVertex4iv v
@deftypefunx void glVertex4fv v
@deftypefunx void glVertex4dv v
Specify a vertex.

@table @asis
@item @var{x}
@itemx @var{y}
@itemx @var{z}
@itemx @var{w}
Specify @var{x}, @var{y}, @var{z}, and @var{w} coordinates of a vertex.
Not all parameters are present in all forms of the command.

@end table

@code{glVertex} commands are used within @code{glBegin}/@code{glEnd}
pairs to specify point, line, and polygon vertices.  The current color,
normal, texture coordinates, and fog coordinate are associated with the
vertex when @code{glVertex} is called.

When only @r{@var{x}} and @r{@var{y}} are specified, @r{@var{z}}
defaults to 0 and @r{@var{w}} defaults to 1.  When @r{@var{x}},
@r{@var{y}}, and @r{@var{z}} are specified, @r{@var{w}} defaults to 1.

@end deftypefun

@deftypefun void glViewport x y width height
Set the viewport.

@table @asis
@item @var{x}
@itemx @var{y}
Specify the lower left corner of the viewport rectangle, in pixels.  The
initial value is (0,0).

@item @var{width}
@itemx @var{height}
Specify the width and height of the viewport.  When a GL context is
first attached to a window, @var{width} and @var{height} are set to the
dimensions of that window.

@end table

@code{glViewport} specifies the affine transformation of @r{@var{x}} and
@r{@var{y}} from normalized device coordinates to window coordinates.
Let @r{(@var{x}_@var{nd},@var{y}_@var{nd})} be normalized device
coordinates.  Then the window coordinates
@r{(@var{x}_@var{w},@var{y}_@var{w})} are computed as follows:

@r{@var{x}_@var{w}=(@var{x}_@var{nd}+1,)⁢(@var{width}/2,)+@var{x}}

@r{@var{y}_@var{w}=(@var{y}_@var{nd}+1,)⁢(@var{height}/2,)+@var{y}}

Viewport width and height are silently clamped to a range that depends
on the implementation.  To query this range, call @code{glGet} with
argument @code{GL_MAX_VIEWPORT_DIMS}.

@code{GL_INVALID_VALUE} is generated if either @var{width} or
@var{height} is negative.

@code{GL_INVALID_OPERATION} is generated if @code{glViewport} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun

@deftypefun void glWindowPos2s x y
@deftypefunx void glWindowPos2i x y
@deftypefunx void glWindowPos2f x y
@deftypefunx void glWindowPos2d x y
@deftypefunx void glWindowPos3s x y z
@deftypefunx void glWindowPos3i x y z
@deftypefunx void glWindowPos3f x y z
@deftypefunx void glWindowPos3d x y z
@deftypefunx void glWindowPos2sv v
@deftypefunx void glWindowPos2iv v
@deftypefunx void glWindowPos2fv v
@deftypefunx void glWindowPos2dv v
@deftypefunx void glWindowPos3sv v
@deftypefunx void glWindowPos3iv v
@deftypefunx void glWindowPos3fv v
@deftypefunx void glWindowPos3dv v
Specify the raster position in window coordinates for pixel operations.

@table @asis
@item @var{x}
@itemx @var{y}
@itemx @var{z}
Specify the @r{@var{x}}, @r{@var{y}}, @r{@var{z}} coordinates for the
raster position.

@end table

The GL maintains a 3D position in window coordinates.  This position,
called the raster position, is used to position pixel and bitmap write
operations.  It is maintained with subpixel accuracy.  See
@code{glBitmap}, @code{glDrawPixels}, and @code{glCopyPixels}.

@code{glWindowPos2} specifies the @r{@var{x}} and @r{@var{y}}
coordinates, while @r{@var{z}} is implicitly set to 0.
@code{glWindowPos3} specifies all three coordinates.  The @r{@var{w}}
coordinate of the current raster position is always set to 1.0.

@code{glWindowPos} directly updates the @r{@var{x}} and @r{@var{y}}
coordinates of the current raster position with the values specified.
That is, the values are neither transformed by the current modelview and
projection matrices, nor by the viewport-to-window transform.  The
@r{@var{z}} coordinate of the current raster position is updated in the
following manner:

@r{@var{z}=@{(@var{n}), (@var{f}),
(@var{n}+@var{z}×(@var{f}-@var{n},),)⁢(@var{if}⁢@var{z}<=0),
(@var{if}⁢@var{z}>=1), (@code{otherwise},),}



where @r{@var{n}} is @code{GL_DEPTH_RANGE}'s near value, and @r{@var{f}}
is @code{GL_DEPTH_RANGE}'s far value.  See @code{glDepthRange}.

The specified coordinates are not clip-tested, causing the raster
position to always be valid.

The current raster position also includes some associated color data and
texture coordinates.  If lighting is enabled, then
@code{GL_CURRENT_RASTER_COLOR} (in RGBA mode) or
@code{GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color
produced by the lighting calculation (see @code{glLight},
@code{glLightModel}, and @code{glShadeModel}).  If lighting is disabled,
current color (in RGBA mode, state variable @code{GL_CURRENT_COLOR}) or
color index (in color index mode, state variable
@code{GL_CURRENT_INDEX}) is used to update the current raster color.
@code{GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise
updated.

Likewise, @code{GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a
function of @code{GL_CURRENT_TEXTURE_COORDS}, based on the texture
matrix and the texture generation functions (see @code{glTexGen}).  The
@code{GL_CURRENT_RASTER_DISTANCE} is set to the
@code{GL_CURRENT_FOG_COORD}.



@code{GL_INVALID_OPERATION} is generated if @code{glWindowPos} is
executed between the execution of @code{glBegin} and the corresponding
execution of @code{glEnd}.

@end deftypefun


@c %end of fragment
